(function(window, angular, undefined) {
    'use strict';
    var $resourceMinErr = angular.$$minErr('$resource');
    var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;

    function isValidDottedPath(path) {
        return (path != null && path !== '' && path !== 'hasOwnProperty' && MEMBER_NAME_REGEX.test('.' + path));
    }

    function lookupDottedPath(obj, path) {
        if (!isValidDottedPath(path)) {
            throw $resourceMinErr('badmember', 'Dotted member path "@{0}" is invalid.', path);
        }
        var keys = path.split('.');
        for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {
            var key = keys[i];
            obj = (obj !== null) ? obj[key] : undefined;
        }
        return obj;
    }

    function shallowClearAndCopy(src, dst) {
        dst = dst || {};
        angular.forEach(dst, function(value, key) {
            delete dst[key];
        });
        for (var key in src) {
            if (src.hasOwnProperty(key) && !(key.charAt(0) === '$' && key.charAt(1) === '$')) {
                dst[key] = src[key];
            }
        }
        return dst;
    }
    angular.module('ngResource', ['ng']).provider('$resource', function() {
        var provider = this;
        this.defaults = {
            stripTrailingSlashes: true,
            actions: {
                'get': {
                    method: 'GET'
                },
                'save': {
                    method: 'POST'
                },
                'query': {
                    method: 'GET',
                    isArray: true
                },
                'remove': {
                    method: 'DELETE'
                },
                'delete': {
                    method: 'DELETE'
                }
            }
        };
        this.$get = ['$http', '$q', function($http, $q) {
            var noop = angular.noop,
                forEach = angular.forEach,
                extend = angular.extend,
                copy = angular.copy,
                isFunction = angular.isFunction;

            function encodeUriSegment(val) {
                return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
            }

            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
            }

            function Route(template, defaults) {
                this.template = template;
                this.defaults = extend({}, provider.defaults, defaults);
                this.urlParams = {};
            }
            Route.prototype = {
                setUrlParams: function(config, params, actionUrl) {
                    var self = this,
                        url = actionUrl || self.template,
                        val, encodedVal;
                    var urlParams = self.urlParams = {};
                    forEach(url.split(/\W/), function(param) {
                        if (param === 'hasOwnProperty') {
                            throw $resourceMinErr('badname', "hasOwnProperty is not a valid parameter name.");
                        }
                        if (!(new RegExp("^\\d+$").test(param)) && param && (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
                            urlParams[param] = true;
                        }
                    });
                    url = url.replace(/\\:/g, ':');
                    params = params || {};
                    forEach(self.urlParams, function(_, urlParam) {
                        val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
                        if (angular.isDefined(val) && val !== null) {
                            encodedVal = encodeUriSegment(val);
                            url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                                return encodedVal + p1;
                            });
                        } else {
                            url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                                if (tail.charAt(0) == '/') {
                                    return tail;
                                } else {
                                    return leadingSlashes + tail;
                                }
                            });
                        }
                    });
                    if (self.defaults.stripTrailingSlashes) {
                        url = url.replace(/\/+$/, '') || '/';
                    }
                    url = url.replace(/\/\.(?=\w+($|\?))/, '.');
                    config.url = url.replace(/\/\\\./, '/.');
                    forEach(params, function(value, key) {
                        if (!self.urlParams[key]) {
                            config.params = config.params || {};
                            config.params[key] = value;
                        }
                    });
                }
            };

            function resourceFactory(url, paramDefaults, actions, options) {
                var route = new Route(url, options);
                actions = extend({}, provider.defaults.actions, actions);

                function extractParams(data, actionParams) {
                    var ids = {};
                    actionParams = extend({}, paramDefaults, actionParams);
                    forEach(actionParams, function(value, key) {
                        if (isFunction(value)) {
                            value = value();
                        }
                        ids[key] = value && value.charAt && value.charAt(0) == '@' ? lookupDottedPath(data, value.substr(1)) : value;
                    });
                    return ids;
                }

                function defaultResponseInterceptor(response) {
                    return response.resource;
                }

                function Resource(value) {
                    shallowClearAndCopy(value || {}, this);
                }
                Resource.prototype.toJSON = function() {
                    var data = extend({}, this);
                    delete data.$promise;
                    delete data.$resolved;
                    return data;
                };
                forEach(actions, function(action, name) {
                    var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);
                    Resource[name] = function(a1, a2, a3, a4) {
                        var params = {},
                            data, success, error;
                        switch (arguments.length) {
                            case 4:
                                error = a4;
                                success = a3;
                            case 3:
                            case 2:
                                if (isFunction(a2)) {
                                    if (isFunction(a1)) {
                                        success = a1;
                                        error = a2;
                                        break;
                                    }
                                    success = a2;
                                    error = a3;
                                } else {
                                    params = a1;
                                    data = a2;
                                    success = a3;
                                    break;
                                }
                            case 1:
                                if (isFunction(a1)) success = a1;
                                else if (hasBody) data = a1;
                                else params = a1;
                                break;
                            case 0:
                                break;
                            default:
                                throw $resourceMinErr('badargs', "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                        }
                        var isInstanceCall = this instanceof Resource;
                        var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));
                        var httpConfig = {};
                        var responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor;
                        var responseErrorInterceptor = action.interceptor && action.interceptor.responseError || undefined;
                        forEach(action, function(value, key) {
                            if (key != 'params' && key != 'isArray' && key != 'interceptor') {
                                httpConfig[key] = copy(value);
                            }
                        });
                        if (hasBody) httpConfig.data = data;
                        route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                        var promise = $http(httpConfig).then(function(response) {
                            var data = response.data,
                                promise = value.$promise;
                            if (data) {
                                if (angular.isArray(data) !== (!!action.isArray)) {
                                    throw $resourceMinErr('badcfg', 'Error in resource configuration for action `{0}`. Expected response to ' + 'contain an {1} but got an {2} (Request: {3} {4})', name, action.isArray ? 'array' : 'object', angular.isArray(data) ? 'array' : 'object', httpConfig.method, httpConfig.url);
                                }
                                if (action.isArray) {
                                    value.length = 0;
                                    forEach(data, function(item) {
                                        if (typeof item === "object") {
                                            value.push(new Resource(item));
                                        } else {
                                            value.push(item);
                                        }
                                    });
                                } else {
                                    shallowClearAndCopy(data, value);
                                    value.$promise = promise;
                                }
                            }
                            value.$resolved = true;
                            response.resource = value;
                            return response;
                        }, function(response) {
                            value.$resolved = true;
                            (error || noop)(response);
                            return $q.reject(response);
                        });
                        promise = promise.then(function(response) {
                            var value = responseInterceptor(response);
                            (success || noop)(value, response.headers);
                            return value;
                        }, responseErrorInterceptor);
                        if (!isInstanceCall) {
                            value.$promise = promise;
                            value.$resolved = false;
                            return value;
                        }
                        return promise;
                    };
                    Resource.prototype['$' + name] = function(params, success, error) {
                        if (isFunction(params)) {
                            error = success;
                            success = params;
                            params = {};
                        }
                        var result = Resource[name].call(this, params, this, success, error);
                        return result.$promise || result;
                    };
                });
                Resource.bind = function(additionalParamDefaults) {
                    return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
                };
                return Resource;
            }
            return resourceFactory;
        }];
    });
})(window, window.angular);
angular.module('ngCacheBuster', []).config(['$httpProvider', function($httpProvider) {
    return $httpProvider.interceptors.push('httpRequestInterceptorCacheBuster');
}]).provider('httpRequestInterceptorCacheBuster', function() {
    this.matchlist = [/.*partials.*/, /.*views.*/];
    this.logRequests = false;
    this.black = false;
    this.setMatchlist = function(list, black) {
        this.black = typeof black != 'undefined' ? black : false
        this.matchlist = list;
    };
    this.setLogRequests = function(logRequests) {
        this.logRequests = logRequests;
    };
    this.$get = ['$q', '$log', function($q, $log) {
        var matchlist = this.matchlist;
        var logRequests = this.logRequests;
        var black = this.black;
        if (logRequests) {
            $log.log("Blacklist? ", black);
        }
        return {
            'request': function(config) {
                var busted = !black;
                for (var i = 0; i < matchlist.length; i++) {
                    if (config.url.match(matchlist[i])) {
                        busted = black;
                        break;
                    }
                }
                if (busted) {
                    var d = new Date();
                    config.url = config.url.replace(/[?|&]cacheBuster=\d+/, '');
                    config.url += config.url.indexOf('?') === -1 ? '?' : '&'
                    config.url += 'cacheBuster=' + d.getTime();
                }
                if (logRequests) {
                    var log = 'request.url =' + config.url
                    busted ? $log.warn(log) : $log.info(log)
                }
                return config || $q.when(config);
            }
        }
    }];
});
(function(window, angular, undefined) {
    'use strict';
    angular.module('ngCookies', ['ng']).provider('$cookies', [function $CookiesProvider() {
        var defaults = this.defaults = {};

        function calcOptions(options) {
            return options ? angular.extend({}, defaults, options) : defaults;
        }
        this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {
            return {
                get: function(key) {
                    return $$cookieReader()[key];
                },
                getObject: function(key) {
                    var value = this.get(key);
                    return value ? angular.fromJson(value) : value;
                },
                getAll: function() {
                    return $$cookieReader();
                },
                put: function(key, value, options) {
                    $$cookieWriter(key, value, calcOptions(options));
                },
                putObject: function(key, value, options) {
                    this.put(key, angular.toJson(value), options);
                },
                remove: function(key, options) {
                    $$cookieWriter(key, undefined, calcOptions(options));
                }
            };
        }];
    }]);
    angular.module('ngCookies').factory('$cookieStore', ['$cookies', function($cookies) {
        return {
            get: function(key) {
                return $cookies.getObject(key);
            },
            put: function(key, value) {
                $cookies.putObject(key, value);
            },
            remove: function(key) {
                $cookies.remove(key);
            }
        };
    }]);

    function $$CookieWriter($document, $log, $browser) {
        var cookiePath = $browser.baseHref();
        var rawDocument = $document[0];

        function buildCookieString(name, value, options) {
            var path, expires;
            options = options || {};
            expires = options.expires;
            path = angular.isDefined(options.path) ? options.path : cookiePath;
            if (value === undefined) {
                expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
                value = '';
            }
            if (angular.isString(expires)) {
                expires = new Date(expires);
            }
            var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
            str += path ? ';path=' + path : '';
            str += options.domain ? ';domain=' + options.domain : '';
            str += expires ? ';expires=' + expires.toUTCString() : '';
            str += options.secure ? ';secure' : '';
            var cookieLength = str.length + 1;
            if (cookieLength > 4096) {
                $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
            }
            return str;
        }
        return function(name, value, options) {
            rawDocument.cookie = buildCookieString(name, value, options);
        };
    }
    $$CookieWriter.$inject = ['$document', '$log', '$browser'];
    angular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {
        this.$get = $$CookieWriter;
    });
})(window, window.angular);
(function(window) {
    'use strict';
    angular.module('tmh.dynamicLocale', []).config(['$provide', function($provide) {
        function makeStateful($delegate) {
            $delegate.$stateful = true;
            return $delegate;
        }
        $provide.decorator('dateFilter', ['$delegate', makeStateful]);
        $provide.decorator('numberFilter', ['$delegate', makeStateful]);
        $provide.decorator('currencyFilter', ['$delegate', makeStateful]);
    }]).constant('tmhDynamicLocale.STORAGE_KEY', 'tmhDynamicLocale.locale').provider('tmhDynamicLocale', ['tmhDynamicLocale.STORAGE_KEY', function(STORAGE_KEY) {
        var defaultLocale, localeLocationPattern = 'angular/i18n/angular-locale_{{locale}}.js',
            storageFactory = 'tmhDynamicLocaleStorageCache',
            storage, storageKey = STORAGE_KEY,
            promiseCache = {},
            activeLocale;

        function loadScript(url, callback, errorCallback, $timeout) {
            var script = document.createElement('script'),
                body = document.getElementsByTagName('body')[0],
                removed = false;
            script.type = 'text/javascript';
            if (script.readyState) {
                script.onreadystatechange = function() {
                    if (script.readyState === 'complete' || script.readyState === 'loaded') {
                        script.onreadystatechange = null;
                        $timeout(function() {
                            if (removed) return;
                            removed = true;
                            body.removeChild(script);
                            callback();
                        }, 30, false);
                    }
                };
            } else {
                script.onload = function() {
                    if (removed) return;
                    removed = true;
                    body.removeChild(script);
                    callback();
                };
                script.onerror = function() {
                    if (removed) return;
                    removed = true;
                    body.removeChild(script);
                    errorCallback();
                };
            }
            script.src = url;
            script.async = false;
            body.appendChild(script);
        }

        function loadLocale(localeUrl, $locale, localeId, $rootScope, $q, localeCache, $timeout) {
            function overrideValues(oldObject, newObject) {
                if (activeLocale !== localeId) {
                    return;
                }
                angular.forEach(oldObject, function(value, key) {
                    if (!newObject[key]) {
                        delete oldObject[key];
                    } else if (angular.isArray(newObject[key])) {
                        oldObject[key].length = newObject[key].length;
                    }
                });
                angular.forEach(newObject, function(value, key) {
                    if (angular.isArray(newObject[key]) || angular.isObject(newObject[key])) {
                        if (!oldObject[key]) {
                            oldObject[key] = angular.isArray(newObject[key]) ? [] : {};
                        }
                        overrideValues(oldObject[key], newObject[key]);
                    } else {
                        oldObject[key] = newObject[key];
                    }
                });
            }
            if (promiseCache[localeId]) return promiseCache[localeId];
            var cachedLocale, deferred = $q.defer();
            if (localeId === activeLocale) {
                deferred.resolve($locale);
            } else if ((cachedLocale = localeCache.get(localeId))) {
                activeLocale = localeId;
                $rootScope.$evalAsync(function() {
                    overrideValues($locale, cachedLocale);
                    $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);
                    storage.put(storageKey, localeId);
                    deferred.resolve($locale);
                });
            } else {
                activeLocale = localeId;
                promiseCache[localeId] = deferred.promise;
                loadScript(localeUrl, function() {
                    var localInjector = angular.injector(['ngLocale']),
                        externalLocale = localInjector.get('$locale');
                    overrideValues($locale, externalLocale);
                    localeCache.put(localeId, externalLocale);
                    delete promiseCache[localeId];
                    $rootScope.$apply(function() {
                        $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);
                        storage.put(storageKey, localeId);
                        deferred.resolve($locale);
                    });
                }, function() {
                    delete promiseCache[localeId];
                    $rootScope.$apply(function() {
                        if (activeLocale === localeId) activeLocale = $locale.id;
                        $rootScope.$broadcast('$localeChangeError', localeId);
                        deferred.reject(localeId);
                    });
                }, $timeout);
            }
            return deferred.promise;
        }
        this.localeLocationPattern = function(value) {
            if (value) {
                localeLocationPattern = value;
                return this;
            } else {
                return localeLocationPattern;
            }
        };
        this.useStorage = function(storageName) {
            storageFactory = storageName;
        };
        this.useCookieStorage = function() {
            this.useStorage('$cookieStore');
        };
        this.defaultLocale = function(value) {
            defaultLocale = value;
        };
        this.storageKey = function(value) {
            if (value) {
                storageKey = value;
                return this;
            } else {
                return storageKey;
            }
        };
        this.$get = ['$rootScope', '$injector', '$interpolate', '$locale', '$q', 'tmhDynamicLocaleCache', '$timeout', function($rootScope, $injector, interpolate, locale, $q, tmhDynamicLocaleCache, $timeout) {
            var localeLocation = interpolate(localeLocationPattern);
            storage = $injector.get(storageFactory);
            $rootScope.$evalAsync(function() {
                var initialLocale;
                if ((initialLocale = (storage.get(storageKey) || defaultLocale))) {
                    loadLocale(localeLocation({
                        locale: initialLocale
                    }), locale, initialLocale, $rootScope, $q, tmhDynamicLocaleCache, $timeout);
                }
            });
            return {
                set: function(value) {
                    return loadLocale(localeLocation({
                        locale: value
                    }), locale, value, $rootScope, $q, tmhDynamicLocaleCache, $timeout);
                },
                get: function() {
                    return activeLocale;
                }
            };
        }];
    }]).provider('tmhDynamicLocaleCache', function() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
            return $cacheFactory('tmh.dynamicLocales');
        }];
    }).provider('tmhDynamicLocaleStorageCache', function() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
            return $cacheFactory('tmh.dynamicLocales.store');
        }];
    }).run(['tmhDynamicLocale', angular.noop]);
}(window));
(function(window, angular, undefined) {
    'use strict';
    var $sanitizeMinErr = angular.$$minErr('$sanitize');

    function $SanitizeProvider() {
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                }));
                return buf.join('');
            };
        }];
    }

    function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
        END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
        ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
        BEGIN_TAG_REGEXP = /^</,
        BEGING_END_TAGE_REGEXP = /^<\//,
        COMMENT_REGEXP = /<!--(.*?)-->/g,
        DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
        CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
        SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
        optionalEndTagInlineElements = makeMap("rp,rt"),
        optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
    var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,target,title,type,' + 'valign,value,vspace,width');
    var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
    var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);

    function makeMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
            obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
    }

    function htmlParser(html, handler) {
        if (typeof html !== 'string') {
            if (html === null || typeof html === 'undefined') {
                html = '';
            } else {
                html = '' + html;
            }
        }
        var index, chars, match, stack = [],
            last = html,
            text;
        stack.last = function() {
            return stack[stack.length - 1];
        };
        while (html) {
            text = '';
            chars = true;
            if (!stack.last() || !specialElements[stack.last()]) {
                if (html.indexOf("<!--") === 0) {
                    index = html.indexOf("--", 4);
                    if (index >= 0 && html.lastIndexOf("-->", index) === index) {
                        if (handler.comment) handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (DOCTYPE_REGEXP.test(html)) {
                    match = html.match(DOCTYPE_REGEXP);
                    if (match) {
                        html = html.replace(match[0], '');
                        chars = false;
                    }
                } else if (BEGING_END_TAGE_REGEXP.test(html)) {
                    match = html.match(END_TAG_REGEXP);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(END_TAG_REGEXP, parseEndTag);
                        chars = false;
                    }
                } else if (BEGIN_TAG_REGEXP.test(html)) {
                    match = html.match(START_TAG_REGEXP);
                    if (match) {
                        if (match[4]) {
                            html = html.substring(match[0].length);
                            match[0].replace(START_TAG_REGEXP, parseStartTag);
                        }
                        chars = false;
                    } else {
                        text += '<';
                        html = html.substring(1);
                    }
                }
                if (chars) {
                    index = html.indexOf("<");
                    text += index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? "" : html.substring(index);
                    if (handler.chars) handler.chars(decodeEntities(text));
                }
            } else {
                html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
                    text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
                    if (handler.chars) handler.chars(decodeEntities(text));
                    return "";
                });
                parseEndTag("", stack.last());
            }
            if (html == last) {
                throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
            }
            last = html;
        }
        parseEndTag();

        function parseStartTag(tag, tagName, rest, unary) {
            tagName = angular.lowercase(tagName);
            if (blockElements[tagName]) {
                while (stack.last() && inlineElements[stack.last()]) {
                    parseEndTag("", stack.last());
                }
            }
            if (optionalEndTagElements[tagName] && stack.last() == tagName) {
                parseEndTag("", tagName);
            }
            unary = voidElements[tagName] || !!unary;
            if (!unary) {
                stack.push(tagName);
            }
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start(tagName, attrs, unary);
        }

        function parseEndTag(tag, tagName) {
            var pos = 0,
                i;
            tagName = angular.lowercase(tagName);
            if (tagName) {
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] == tagName) break;
                }
            }
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--)
                    if (handler.end) handler.end(stack[i]);
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement("pre");

    function decodeEntities(value) {
        if (!value) {
            return '';
        }
        hiddenPre.innerHTML = value.replace(/</g, "&lt;");
        return hiddenPre.textContent;
    }

    function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0);
            var low = value.charCodeAt(1);
            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = false;
        var out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] === true) {
                    out('<');
                    out(tag);
                    angular.forEach(attrs, function(value, key) {
                        var lkey = angular.lowercase(key);
                        var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                        if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                            out(' ');
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? '/>' : '>');
                }
            },
            end: function(tag) {
                tag = angular.lowercase(tag);
                if (!ignore && validElements[tag] === true) {
                    out('</');
                    out(tag);
                    out('>');
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars) {
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }
    angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
    angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"��]/,
            MAILTO_REGEXP = /^mailto:/;
        return function(text, target) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while ((match = raw.match(LINKY_URL_REGEXP))) {
                url = match[0];
                if (!match[2] && !match[4]) {
                    url = (match[3] ? 'http://' : 'mailto:') + url;
                }
                i = match.index;
                addText(raw.substr(0, i));
                addLink(url, match[0].replace(MAILTO_REGEXP, ''));
                raw = raw.substring(i + match[0].length);
            }
            addText(raw);
            return $sanitize(html.join(''));

            function addText(text) {
                if (!text) {
                    return;
                }
                html.push(sanitizeText(text));
            }

            function addLink(url, text) {
                html.push('<a ');
                if (angular.isDefined(target)) {
                    html.push('target="', target, '" ');
                }
                html.push('href="', url.replace(/"/g, '&quot;'), '">');
                addText(text);
                html.push('</a>');
            }
        };
    }]);
})(window, window.angular);
angular.module('pascalprecht.translate', ['ng']).run(['$translate', function($translate) {
    var key = $translate.storageKey(),
        storage = $translate.storage();
    var fallbackFromIncorrectStorageValue = function() {
        var preferred = $translate.preferredLanguage();
        if (angular.isString(preferred)) {
            $translate.use(preferred);
        } else {
            storage.put(key, $translate.use());
        }
    };
    if (storage) {
        if (!storage.get(key)) {
            fallbackFromIncorrectStorageValue();
        } else {
            $translate.use(storage.get(key))['catch'](fallbackFromIncorrectStorageValue);
        }
    } else if (angular.isString($translate.preferredLanguage())) {
        $translate.use($translate.preferredLanguage());
    }
}]);
angular.module('pascalprecht.translate').provider('$translate', ['$STORAGE_KEY', '$windowProvider', function($STORAGE_KEY, $windowProvider) {
    var $translationTable = {},
        $preferredLanguage, $availableLanguageKeys = [],
        $languageKeyAliases, $fallbackLanguage, $fallbackWasString, $uses, $nextLang, $storageFactory, $storageKey = $STORAGE_KEY,
        $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $interpolatorFactories = [],
        $interpolationSanitizationStrategy = false,
        $loaderFactory, $cloakClassName = 'translate-cloak',
        $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, $postCompilingEnabled = false,
        NESTED_OBJECT_DELIMITER = '.',
        loaderCache, directivePriority = 0;
    var version = '2.6.0';
    var getFirstBrowserLanguage = function() {
        var nav = $windowProvider.$get().navigator,
            browserLanguagePropertyKeys = ['language', 'browserLanguage', 'systemLanguage', 'userLanguage'],
            i, language;
        if (angular.isArray(nav.languages)) {
            for (i = 0; i < nav.languages.length; i++) {
                language = nav.languages[i];
                if (language && language.length) {
                    return language;
                }
            }
        }
        for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
            language = nav[browserLanguagePropertyKeys[i]];
            if (language && language.length) {
                return language;
            }
        }
        return null;
    };
    getFirstBrowserLanguage.displayName = 'angular-translate/service: getFirstBrowserLanguage';
    var getLocale = function() {
        return (getFirstBrowserLanguage() || '').split('-').join('_');
    };
    getLocale.displayName = 'angular-translate/service: getLocale';
    var indexOf = function(array, searchElement) {
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === searchElement) {
                return i;
            }
        }
        return -1;
    };
    var trim = function() {
        return this.replace(/^\s+|\s+$/g, '');
    };
    var negotiateLocale = function(preferred) {
        var avail = [],
            locale = angular.lowercase(preferred),
            i = 0,
            n = $availableLanguageKeys.length;
        for (; i < n; i++) {
            avail.push(angular.lowercase($availableLanguageKeys[i]));
        }
        if (indexOf(avail, locale) > -1) {
            return preferred;
        }
        if ($languageKeyAliases) {
            var alias;
            for (var langKeyAlias in $languageKeyAliases) {
                var hasWildcardKey = false;
                var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && angular.lowercase(langKeyAlias) === angular.lowercase(preferred);
                if (langKeyAlias.slice(-1) === '*') {
                    hasWildcardKey = langKeyAlias.slice(0, -1) === preferred.slice(0, langKeyAlias.length - 1);
                }
                if (hasExactKey || hasWildcardKey) {
                    alias = $languageKeyAliases[langKeyAlias];
                    if (indexOf(avail, angular.lowercase(alias)) > -1) {
                        return alias;
                    }
                }
            }
        }
        var parts = preferred.split('_');
        if (parts.length > 1 && indexOf(avail, angular.lowercase(parts[0])) > -1) {
            return parts[0];
        }
        return preferred;
    };
    var translations = function(langKey, translationTable) {
        if (!langKey && !translationTable) {
            return $translationTable;
        }
        if (langKey && !translationTable) {
            if (angular.isString(langKey)) {
                return $translationTable[langKey];
            }
        } else {
            if (!angular.isObject($translationTable[langKey])) {
                $translationTable[langKey] = {};
            }
            angular.extend($translationTable[langKey], flatObject(translationTable));
        }
        return this;
    };
    this.translations = translations;
    this.cloakClassName = function(name) {
        if (!name) {
            return $cloakClassName;
        }
        $cloakClassName = name;
        return this;
    };
    var flatObject = function(data, path, result, prevKey) {
        var key, keyWithPath, keyWithShortPath, val;
        if (!path) {
            path = [];
        }
        if (!result) {
            result = {};
        }
        for (key in data) {
            if (!Object.prototype.hasOwnProperty.call(data, key)) {
                continue;
            }
            val = data[key];
            if (angular.isObject(val)) {
                flatObject(val, path.concat(key), result, key);
            } else {
                keyWithPath = path.length ? ('' + path.join(NESTED_OBJECT_DELIMITER) + NESTED_OBJECT_DELIMITER + key) : key;
                if (path.length && key === prevKey) {
                    keyWithShortPath = '' + path.join(NESTED_OBJECT_DELIMITER);
                    result[keyWithShortPath] = '@:' + keyWithPath;
                }
                result[keyWithPath] = val;
            }
        }
        return result;
    };
    this.addInterpolation = function(factory) {
        $interpolatorFactories.push(factory);
        return this;
    };
    this.useMessageFormatInterpolation = function() {
        return this.useInterpolation('$translateMessageFormatInterpolation');
    };
    this.useInterpolation = function(factory) {
        $interpolationFactory = factory;
        return this;
    };
    this.useSanitizeValueStrategy = function(value) {
        $interpolationSanitizationStrategy = value;
        return this;
    };
    this.preferredLanguage = function(langKey) {
        setupPreferredLanguage(langKey);
        return this;
    };
    var setupPreferredLanguage = function(langKey) {
        if (langKey) {
            $preferredLanguage = langKey;
        }
        return $preferredLanguage;
    };
    this.translationNotFoundIndicator = function(indicator) {
        this.translationNotFoundIndicatorLeft(indicator);
        this.translationNotFoundIndicatorRight(indicator);
        return this;
    };
    this.translationNotFoundIndicatorLeft = function(indicator) {
        if (!indicator) {
            return $notFoundIndicatorLeft;
        }
        $notFoundIndicatorLeft = indicator;
        return this;
    };
    this.translationNotFoundIndicatorRight = function(indicator) {
        if (!indicator) {
            return $notFoundIndicatorRight;
        }
        $notFoundIndicatorRight = indicator;
        return this;
    };
    this.fallbackLanguage = function(langKey) {
        fallbackStack(langKey);
        return this;
    };
    var fallbackStack = function(langKey) {
        if (langKey) {
            if (angular.isString(langKey)) {
                $fallbackWasString = true;
                $fallbackLanguage = [langKey];
            } else if (angular.isArray(langKey)) {
                $fallbackWasString = false;
                $fallbackLanguage = langKey;
            }
            if (angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                $fallbackLanguage.push($preferredLanguage);
            }
            return this;
        } else {
            if ($fallbackWasString) {
                return $fallbackLanguage[0];
            } else {
                return $fallbackLanguage;
            }
        }
    };
    this.use = function(langKey) {
        if (langKey) {
            if (!$translationTable[langKey] && (!$loaderFactory)) {
                throw new Error("$translateProvider couldn't find translationTable for langKey: '" + langKey + "'");
            }
            $uses = langKey;
            return this;
        }
        return $uses;
    };
    var storageKey = function(key) {
        if (!key) {
            if ($storagePrefix) {
                return $storagePrefix + $storageKey;
            }
            return $storageKey;
        }
        $storageKey = key;
    };
    this.storageKey = storageKey;
    this.useUrlLoader = function(url, options) {
        return this.useLoader('$translateUrlLoader', angular.extend({
            url: url
        }, options));
    };
    this.useStaticFilesLoader = function(options) {
        return this.useLoader('$translateStaticFilesLoader', options);
    };
    this.useLoader = function(loaderFactory, options) {
        $loaderFactory = loaderFactory;
        $loaderOptions = options || {};
        return this;
    };
    this.useLocalStorage = function() {
        return this.useStorage('$translateLocalStorage');
    };
    this.useCookieStorage = function() {
        return this.useStorage('$translateCookieStorage');
    };
    this.useStorage = function(storageFactory) {
        $storageFactory = storageFactory;
        return this;
    };
    this.storagePrefix = function(prefix) {
        if (!prefix) {
            return prefix;
        }
        $storagePrefix = prefix;
        return this;
    };
    this.useMissingTranslationHandlerLog = function() {
        return this.useMissingTranslationHandler('$translateMissingTranslationHandlerLog');
    };
    this.useMissingTranslationHandler = function(factory) {
        $missingTranslationHandlerFactory = factory;
        return this;
    };
    this.usePostCompiling = function(value) {
        $postCompilingEnabled = !(!value);
        return this;
    };
    this.determinePreferredLanguage = function(fn) {
        var locale = (fn && angular.isFunction(fn)) ? fn() : getLocale();
        if (!$availableLanguageKeys.length) {
            $preferredLanguage = locale;
        } else {
            $preferredLanguage = negotiateLocale(locale);
        }
        return this;
    };
    this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
        if (languageKeys) {
            $availableLanguageKeys = languageKeys;
            if (aliases) {
                $languageKeyAliases = aliases;
            }
            return this;
        }
        return $availableLanguageKeys;
    };
    this.useLoaderCache = function(cache) {
        if (cache === false) {
            loaderCache = undefined;
        } else if (cache === true) {
            loaderCache = true;
        } else if (typeof(cache) === 'undefined') {
            loaderCache = '$translationCache';
        } else if (cache) {
            loaderCache = cache;
        }
        return this;
    };
    this.directivePriority = function(priority) {
        if (priority === undefined) {
            return directivePriority;
        } else {
            directivePriority = priority;
            return this;
        }
    };
    this.$get = ['$log', '$injector', '$rootScope', '$q', function($log, $injector, $rootScope, $q) {
        var Storage, defaultInterpolator = $injector.get($interpolationFactory || '$translateDefaultInterpolation'),
            pendingLoader = false,
            interpolatorHashMap = {},
            langPromises = {},
            fallbackIndex, startFallbackIteration;
        var $translate = function(translationId, interpolateParams, interpolationId, defaultTranslationText) {
            if (angular.isArray(translationId)) {
                var translateAll = function(translationIds) {
                    var results = {};
                    var promises = [];
                    var translate = function(translationId) {
                        var deferred = $q.defer();
                        var regardless = function(value) {
                            results[translationId] = value;
                            deferred.resolve([translationId, value]);
                        };
                        $translate(translationId, interpolateParams, interpolationId, defaultTranslationText).then(regardless, regardless);
                        return deferred.promise;
                    };
                    for (var i = 0, c = translationIds.length; i < c; i++) {
                        promises.push(translate(translationIds[i]));
                    }
                    return $q.all(promises).then(function() {
                        return results;
                    });
                };
                return translateAll(translationId);
            }
            var deferred = $q.defer();
            if (translationId) {
                translationId = trim.apply(translationId);
            }
            var promiseToWaitFor = (function() {
                var promise = $preferredLanguage ? langPromises[$preferredLanguage] : langPromises[$uses];
                fallbackIndex = 0;
                if ($storageFactory && !promise) {
                    var langKey = Storage.get($storageKey);
                    promise = langPromises[langKey];
                    if ($fallbackLanguage && $fallbackLanguage.length) {
                        var index = indexOf($fallbackLanguage, langKey);
                        fallbackIndex = (index === 0) ? 1 : 0;
                        if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                            $fallbackLanguage.push($preferredLanguage);
                        }
                    }
                }
                return promise;
            }());
            if (!promiseToWaitFor) {
                determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
            } else {
                promiseToWaitFor.then(function() {
                    determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
                }, deferred.reject);
            }
            return deferred.promise;
        };
        var applyNotFoundIndicators = function(translationId) {
            if ($notFoundIndicatorLeft) {
                translationId = [$notFoundIndicatorLeft, translationId].join(' ');
            }
            if ($notFoundIndicatorRight) {
                translationId = [translationId, $notFoundIndicatorRight].join(' ');
            }
            return translationId;
        };
        var useLanguage = function(key) {
            $uses = key;
            $rootScope.$emit('$translateChangeSuccess', {
                language: key
            });
            if ($storageFactory) {
                Storage.put($translate.storageKey(), $uses);
            }
            defaultInterpolator.setLocale($uses);
            angular.forEach(interpolatorHashMap, function(interpolator, id) {
                interpolatorHashMap[id].setLocale($uses);
            });
            $rootScope.$emit('$translateChangeEnd', {
                language: key
            });
        };
        var loadAsync = function(key) {
            if (!key) {
                throw 'No language key specified for loading.';
            }
            var deferred = $q.defer();
            $rootScope.$emit('$translateLoadingStart', {
                language: key
            });
            pendingLoader = true;
            var cache = loaderCache;
            if (typeof(cache) === 'string') {
                cache = $injector.get(cache);
            }
            var loaderOptions = angular.extend({}, $loaderOptions, {
                key: key,
                $http: angular.extend({}, {
                    cache: cache
                }, $loaderOptions.$http)
            });
            $injector.get($loaderFactory)(loaderOptions).then(function(data) {
                var translationTable = {};
                $rootScope.$emit('$translateLoadingSuccess', {
                    language: key
                });
                if (angular.isArray(data)) {
                    angular.forEach(data, function(table) {
                        angular.extend(translationTable, flatObject(table));
                    });
                } else {
                    angular.extend(translationTable, flatObject(data));
                }
                pendingLoader = false;
                deferred.resolve({
                    key: key,
                    table: translationTable
                });
                $rootScope.$emit('$translateLoadingEnd', {
                    language: key
                });
            }, function(key) {
                $rootScope.$emit('$translateLoadingError', {
                    language: key
                });
                deferred.reject(key);
                $rootScope.$emit('$translateLoadingEnd', {
                    language: key
                });
            });
            return deferred.promise;
        };
        if ($storageFactory) {
            Storage = $injector.get($storageFactory);
            if (!Storage.get || !Storage.put) {
                throw new Error('Couldn\'t use storage \'' + $storageFactory + '\', missing get() or put() method!');
            }
        }
        if (angular.isFunction(defaultInterpolator.useSanitizeValueStrategy)) {
            defaultInterpolator.useSanitizeValueStrategy($interpolationSanitizationStrategy);
        }
        if ($interpolatorFactories.length) {
            angular.forEach($interpolatorFactories, function(interpolatorFactory) {
                var interpolator = $injector.get(interpolatorFactory);
                interpolator.setLocale($preferredLanguage || $uses);
                if (angular.isFunction(interpolator.useSanitizeValueStrategy)) {
                    interpolator.useSanitizeValueStrategy($interpolationSanitizationStrategy);
                }
                interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
            });
        }
        var getTranslationTable = function(langKey) {
            var deferred = $q.defer();
            if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
                deferred.resolve($translationTable[langKey]);
            } else if (langPromises[langKey]) {
                langPromises[langKey].then(function(data) {
                    translations(data.key, data.table);
                    deferred.resolve(data.table);
                }, deferred.reject);
            } else {
                deferred.reject();
            }
            return deferred.promise;
        };
        var getFallbackTranslation = function(langKey, translationId, interpolateParams, Interpolator) {
            var deferred = $q.defer();
            getTranslationTable(langKey).then(function(translationTable) {
                if (Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
                    Interpolator.setLocale(langKey);
                    var translation = translationTable[translationId];
                    if (translation.substr(0, 2) === '@:') {
                        getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator).then(deferred.resolve, deferred.reject);
                    } else {
                        deferred.resolve(Interpolator.interpolate(translationTable[translationId], interpolateParams));
                    }
                    Interpolator.setLocale($uses);
                } else {
                    deferred.reject();
                }
            }, deferred.reject);
            return deferred.promise;
        };
        var getFallbackTranslationInstant = function(langKey, translationId, interpolateParams, Interpolator) {
            var result, translationTable = $translationTable[langKey];
            if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId)) {
                Interpolator.setLocale(langKey);
                result = Interpolator.interpolate(translationTable[translationId], interpolateParams);
                if (result.substr(0, 2) === '@:') {
                    return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator);
                }
                Interpolator.setLocale($uses);
            }
            return result;
        };
        var translateByHandler = function(translationId) {
            if ($missingTranslationHandlerFactory) {
                var resultString = $injector.get($missingTranslationHandlerFactory)(translationId, $uses);
                if (resultString !== undefined) {
                    return resultString;
                } else {
                    return translationId;
                }
            } else {
                return translationId;
            }
        };
        var resolveForFallbackLanguage = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText) {
            var deferred = $q.defer();
            if (fallbackLanguageIndex < $fallbackLanguage.length) {
                var langKey = $fallbackLanguage[fallbackLanguageIndex];
                getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator).then(deferred.resolve, function() {
                    resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText).then(deferred.resolve);
                });
            } else {
                if (defaultTranslationText) {
                    deferred.resolve(defaultTranslationText);
                } else {
                    deferred.resolve(translateByHandler(translationId));
                }
            }
            return deferred.promise;
        };
        var resolveForFallbackLanguageInstant = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator) {
            var result;
            if (fallbackLanguageIndex < $fallbackLanguage.length) {
                var langKey = $fallbackLanguage[fallbackLanguageIndex];
                result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator);
                if (!result) {
                    result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
                }
            }
            return result;
        };
        var fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText) {
            return resolveForFallbackLanguage((startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator, defaultTranslationText);
        };
        var fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator) {
            return resolveForFallbackLanguageInstant((startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex), translationId, interpolateParams, Interpolator);
        };
        var determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText) {
            var deferred = $q.defer();
            var table = $uses ? $translationTable[$uses] : $translationTable,
                Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;
            if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
                var translation = table[translationId];
                if (translation.substr(0, 2) === '@:') {
                    $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText).then(deferred.resolve, deferred.reject);
                } else {
                    deferred.resolve(Interpolator.interpolate(translation, interpolateParams));
                }
            } else {
                var missingTranslationHandlerTranslation;
                if ($missingTranslationHandlerFactory && !pendingLoader) {
                    missingTranslationHandlerTranslation = translateByHandler(translationId);
                }
                if ($uses && $fallbackLanguage && $fallbackLanguage.length) {
                    fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText).then(function(translation) {
                        deferred.resolve(translation);
                    }, function(_translationId) {
                        deferred.reject(applyNotFoundIndicators(_translationId));
                    });
                } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                    if (defaultTranslationText) {
                        deferred.resolve(defaultTranslationText);
                    } else {
                        deferred.resolve(missingTranslationHandlerTranslation);
                    }
                } else {
                    if (defaultTranslationText) {
                        deferred.resolve(defaultTranslationText);
                    } else {
                        deferred.reject(applyNotFoundIndicators(translationId));
                    }
                }
            }
            return deferred.promise;
        };
        var determineTranslationInstant = function(translationId, interpolateParams, interpolationId) {
            var result, table = $uses ? $translationTable[$uses] : $translationTable,
                Interpolator = (interpolationId) ? interpolatorHashMap[interpolationId] : defaultInterpolator;
            if (table && Object.prototype.hasOwnProperty.call(table, translationId)) {
                var translation = table[translationId];
                if (translation.substr(0, 2) === '@:') {
                    result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId);
                } else {
                    result = Interpolator.interpolate(translation, interpolateParams);
                }
            } else {
                var missingTranslationHandlerTranslation;
                if ($missingTranslationHandlerFactory && !pendingLoader) {
                    missingTranslationHandlerTranslation = translateByHandler(translationId);
                }
                if ($uses && $fallbackLanguage && $fallbackLanguage.length) {
                    fallbackIndex = 0;
                    result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator);
                } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                    result = missingTranslationHandlerTranslation;
                } else {
                    result = applyNotFoundIndicators(translationId);
                }
            }
            return result;
        };
        $translate.preferredLanguage = function(langKey) {
            if (langKey) {
                setupPreferredLanguage(langKey);
            }
            return $preferredLanguage;
        };
        $translate.cloakClassName = function() {
            return $cloakClassName;
        };
        $translate.fallbackLanguage = function(langKey) {
            if (langKey !== undefined && langKey !== null) {
                fallbackStack(langKey);
                if ($loaderFactory) {
                    if ($fallbackLanguage && $fallbackLanguage.length) {
                        for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                            if (!langPromises[$fallbackLanguage[i]]) {
                                langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
                            }
                        }
                    }
                }
                $translate.use($translate.use());
            }
            if ($fallbackWasString) {
                return $fallbackLanguage[0];
            } else {
                return $fallbackLanguage;
            }
        };
        $translate.useFallbackLanguage = function(langKey) {
            if (langKey !== undefined && langKey !== null) {
                if (!langKey) {
                    startFallbackIteration = 0;
                } else {
                    var langKeyPosition = indexOf($fallbackLanguage, langKey);
                    if (langKeyPosition > -1) {
                        startFallbackIteration = langKeyPosition;
                    }
                }
            }
        };
        $translate.proposedLanguage = function() {
            return $nextLang;
        };
        $translate.storage = function() {
            return Storage;
        };
        $translate.use = function(key) {
            if (!key) {
                return $uses;
            }
            var deferred = $q.defer();
            $rootScope.$emit('$translateChangeStart', {
                language: key
            });
            var aliasedKey = negotiateLocale(key);
            if (aliasedKey) {
                key = aliasedKey;
            }
            if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {
                $nextLang = key;
                langPromises[key] = loadAsync(key).then(function(translation) {
                    translations(translation.key, translation.table);
                    deferred.resolve(translation.key);
                    useLanguage(translation.key);
                    if ($nextLang === key) {
                        $nextLang = undefined;
                    }
                    return translation;
                }, function(key) {
                    if ($nextLang === key) {
                        $nextLang = undefined;
                    }
                    $rootScope.$emit('$translateChangeError', {
                        language: key
                    });
                    deferred.reject(key);
                    $rootScope.$emit('$translateChangeEnd', {
                        language: key
                    });
                });
            } else {
                deferred.resolve(key);
                useLanguage(key);
            }
            return deferred.promise;
        };
        $translate.storageKey = function() {
            return storageKey();
        };
        $translate.isPostCompilingEnabled = function() {
            return $postCompilingEnabled;
        };
        $translate.refresh = function(langKey) {
            if (!$loaderFactory) {
                throw new Error('Couldn\'t refresh translation table, no loader registered!');
            }
            var deferred = $q.defer();

            function resolve() {
                deferred.resolve();
                $rootScope.$emit('$translateRefreshEnd', {
                    language: langKey
                });
            }

            function reject() {
                deferred.reject();
                $rootScope.$emit('$translateRefreshEnd', {
                    language: langKey
                });
            }
            $rootScope.$emit('$translateRefreshStart', {
                language: langKey
            });
            if (!langKey) {
                var tables = [],
                    loadingKeys = {};
                if ($fallbackLanguage && $fallbackLanguage.length) {
                    for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                        tables.push(loadAsync($fallbackLanguage[i]));
                        loadingKeys[$fallbackLanguage[i]] = true;
                    }
                }
                if ($uses && !loadingKeys[$uses]) {
                    tables.push(loadAsync($uses));
                }
                $q.all(tables).then(function(tableData) {
                    angular.forEach(tableData, function(data) {
                        if ($translationTable[data.key]) {
                            delete $translationTable[data.key];
                        }
                        translations(data.key, data.table);
                    });
                    if ($uses) {
                        useLanguage($uses);
                    }
                    resolve();
                });
            } else if ($translationTable[langKey]) {
                loadAsync(langKey).then(function(data) {
                    translations(data.key, data.table);
                    if (langKey === $uses) {
                        useLanguage($uses);
                    }
                    resolve();
                }, reject);
            } else {
                reject();
            }
            return deferred.promise;
        };
        $translate.instant = function(translationId, interpolateParams, interpolationId) {
            if (translationId === null || angular.isUndefined(translationId)) {
                return translationId;
            }
            if (angular.isArray(translationId)) {
                var results = {};
                for (var i = 0, c = translationId.length; i < c; i++) {
                    results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId);
                }
                return results;
            }
            if (angular.isString(translationId) && translationId.length < 1) {
                return translationId;
            }
            if (translationId) {
                translationId = trim.apply(translationId);
            }
            var result, possibleLangKeys = [];
            if ($preferredLanguage) {
                possibleLangKeys.push($preferredLanguage);
            }
            if ($uses) {
                possibleLangKeys.push($uses);
            }
            if ($fallbackLanguage && $fallbackLanguage.length) {
                possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
            }
            for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
                var possibleLangKey = possibleLangKeys[j];
                if ($translationTable[possibleLangKey]) {
                    if (typeof $translationTable[possibleLangKey][translationId] !== 'undefined') {
                        result = determineTranslationInstant(translationId, interpolateParams, interpolationId);
                    } else if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
                        result = applyNotFoundIndicators(translationId);
                    }
                }
                if (typeof result !== 'undefined') {
                    break;
                }
            }
            if (!result && result !== '') {
                result = defaultInterpolator.interpolate(translationId, interpolateParams);
                if ($missingTranslationHandlerFactory && !pendingLoader) {
                    result = translateByHandler(translationId);
                }
            }
            return result;
        };
        $translate.versionInfo = function() {
            return version;
        };
        $translate.loaderCache = function() {
            return loaderCache;
        };
        $translate.directivePriority = function() {
            return directivePriority;
        };
        if ($loaderFactory) {
            if (angular.equals($translationTable, {})) {
                $translate.use($translate.use());
            }
            if ($fallbackLanguage && $fallbackLanguage.length) {
                var processAsyncResult = function(translation) {
                    translations(translation.key, translation.table);
                    $rootScope.$emit('$translateChangeEnd', {
                        language: translation.key
                    });
                    return translation;
                };
                for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                    langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]).then(processAsyncResult);
                }
            }
        }
        return $translate;
    }];
}]);
angular.module('pascalprecht.translate').factory('$translateDefaultInterpolation', ['$interpolate', function($interpolate) {
    var $translateInterpolator = {},
        $locale, $identifier = 'default',
        $sanitizeValueStrategy = null,
        sanitizeValueStrategies = {
            escaped: function(params) {
                var result = {};
                for (var key in params) {
                    if (Object.prototype.hasOwnProperty.call(params, key)) {
                        if (angular.isNumber(params[key])) {
                            result[key] = params[key];
                        } else {
                            result[key] = angular.element('<div></div>').text(params[key]).html();
                        }
                    }
                }
                return result;
            }
        };
    var sanitizeParams = function(params) {
        var result;
        if (angular.isFunction(sanitizeValueStrategies[$sanitizeValueStrategy])) {
            result = sanitizeValueStrategies[$sanitizeValueStrategy](params);
        } else {
            result = params;
        }
        return result;
    };
    $translateInterpolator.setLocale = function(locale) {
        $locale = locale;
    };
    $translateInterpolator.getInterpolationIdentifier = function() {
        return $identifier;
    };
    $translateInterpolator.useSanitizeValueStrategy = function(value) {
        $sanitizeValueStrategy = value;
        return this;
    };
    $translateInterpolator.interpolate = function(string, interpolateParams) {
        if ($sanitizeValueStrategy) {
            interpolateParams = sanitizeParams(interpolateParams);
        }
        return $interpolate(string)(interpolateParams || {});
    };
    return $translateInterpolator;
}]);
angular.module('pascalprecht.translate').constant('$STORAGE_KEY', 'NG_TRANSLATE_LANG_KEY');
angular.module('pascalprecht.translate').directive('translate', ['$translate', '$q', '$interpolate', '$compile', '$parse', '$rootScope', function($translate, $q, $interpolate, $compile, $parse, $rootScope) {
    var trim = function() {
        return this.replace(/^\s+|\s+$/g, '');
    };
    return {
        restrict: 'AE',
        scope: true,
        priority: $translate.directivePriority(),
        compile: function(tElement, tAttr) {
            var translateValuesExist = (tAttr.translateValues) ? tAttr.translateValues : undefined;
            var translateInterpolation = (tAttr.translateInterpolation) ? tAttr.translateInterpolation : undefined;
            var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);
            var interpolateRegExp = '^(.*)(' + $interpolate.startSymbol() + '.*' + $interpolate.endSymbol() + ')(.*)',
                watcherRegExp = '^(.*)' + $interpolate.startSymbol() + '(.*)' + $interpolate.endSymbol() + '(.*)';
            return function linkFn(scope, iElement, iAttr) {
                scope.interpolateParams = {};
                scope.preText = '';
                scope.postText = '';
                var translationIds = {};
                var observeElementTranslation = function(translationId) {
                    if (angular.isFunction(observeElementTranslation._unwatchOld)) {
                        observeElementTranslation._unwatchOld();
                        observeElementTranslation._unwatchOld = undefined;
                    }
                    if (angular.equals(translationId, '') || !angular.isDefined(translationId)) {
                        var interpolateMatches = trim.apply(iElement.text()).match(interpolateRegExp);
                        if (angular.isArray(interpolateMatches)) {
                            scope.preText = interpolateMatches[1];
                            scope.postText = interpolateMatches[3];
                            translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                            var watcherMatches = iElement.text().match(watcherRegExp);
                            if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                                observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                                    translationIds.translate = newValue;
                                    updateTranslations();
                                });
                            }
                        } else {
                            translationIds.translate = iElement.text().replace(/^\s+|\s+$/g, '');
                        }
                    } else {
                        translationIds.translate = translationId;
                    }
                    updateTranslations();
                };
                var observeAttributeTranslation = function(translateAttr) {
                    iAttr.$observe(translateAttr, function(translationId) {
                        translationIds[translateAttr] = translationId;
                        updateTranslations();
                    });
                };
                var firstAttributeChangedEvent = true;
                iAttr.$observe('translate', function(translationId) {
                    if (typeof translationId === 'undefined') {
                        observeElementTranslation('');
                    } else {
                        if (translationId !== '' || !firstAttributeChangedEvent) {
                            translationIds.translate = translationId;
                            updateTranslations();
                        }
                    }
                    firstAttributeChangedEvent = false;
                });
                for (var translateAttr in iAttr) {
                    if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === 'translateAttr') {
                        observeAttributeTranslation(translateAttr);
                    }
                }
                iAttr.$observe('translateDefault', function(value) {
                    scope.defaultText = value;
                });
                if (translateValuesExist) {
                    iAttr.$observe('translateValues', function(interpolateParams) {
                        if (interpolateParams) {
                            scope.$parent.$watch(function() {
                                angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                            });
                        }
                    });
                }
                if (translateValueExist) {
                    var observeValueAttribute = function(attrName) {
                        iAttr.$observe(attrName, function(value) {
                            var attributeName = angular.lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                            scope.interpolateParams[attributeName] = value;
                        });
                    };
                    for (var attr in iAttr) {
                        if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === 'translateValue' && attr !== 'translateValues') {
                            observeValueAttribute(attr);
                        }
                    }
                }
                var updateTranslations = function() {
                    for (var key in translationIds) {
                        if (translationIds.hasOwnProperty(key)) {
                            updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText);
                        }
                    }
                };
                var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText) {
                    if (translationId) {
                        $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText).then(function(translation) {
                            applyTranslation(translation, scope, true, translateAttr);
                        }, function(translationId) {
                            applyTranslation(translationId, scope, false, translateAttr);
                        });
                    } else {
                        applyTranslation(translationId, scope, false, translateAttr);
                    }
                };
                var applyTranslation = function(value, scope, successful, translateAttr) {
                    if (translateAttr === 'translate') {
                        if (!successful && typeof scope.defaultText !== 'undefined') {
                            value = scope.defaultText;
                        }
                        iElement.html(scope.preText + value + scope.postText);
                        var globallyEnabled = $translate.isPostCompilingEnabled();
                        var locallyDefined = typeof tAttr.translateCompile !== 'undefined';
                        var locallyEnabled = locallyDefined && tAttr.translateCompile !== 'false';
                        if ((globallyEnabled && !locallyDefined) || locallyEnabled) {
                            $compile(iElement.contents())(scope);
                        }
                    } else {
                        if (!successful && typeof scope.defaultText !== 'undefined') {
                            value = scope.defaultText;
                        }
                        var attributeName = iAttr.$attr[translateAttr].substr(15);
                        iElement.attr(attributeName, value);
                    }
                };
                scope.$watch('interpolateParams', updateTranslations, true);
                var unbind = $rootScope.$on('$translateChangeSuccess', updateTranslations);
                if (iElement.text().length) {
                    observeElementTranslation('');
                }
                updateTranslations();
                scope.$on('$destroy', unbind);
            };
        }
    };
}]);
angular.module('pascalprecht.translate').directive('translateCloak', ['$rootScope', '$translate', function($rootScope, $translate) {
    return {
        compile: function(tElement) {
            var applyCloak = function() {
                    tElement.addClass($translate.cloakClassName());
                },
                removeCloak = function() {
                    tElement.removeClass($translate.cloakClassName());
                },
                removeListener = $rootScope.$on('$translateChangeEnd', function() {
                    removeCloak();
                    removeListener();
                    removeListener = null;
                });
            applyCloak();
            return function linkFn(scope, iElement, iAttr) {
                if (iAttr.translateCloak && iAttr.translateCloak.length) {
                    iAttr.$observe('translateCloak', function(translationId) {
                        $translate(translationId).then(removeCloak, applyCloak);
                    });
                }
            };
        }
    };
}]);
angular.module('pascalprecht.translate').filter('translate', ['$parse', '$translate', function($parse, $translate) {
    var translateFilter = function(translationId, interpolateParams, interpolation) {
        if (!angular.isObject(interpolateParams)) {
            interpolateParams = $parse(interpolateParams)(this);
        }
        return $translate.instant(translationId, interpolateParams, interpolation);
    };
    translateFilter.$stateful = true;
    return translateFilter;
}]);
angular.module('pascalprecht.translate').provider('$translatePartialLoader', function() {
    function Part(name, priority) {
        this.name = name;
        this.isActive = true;
        this.tables = {};
        this.priority = priority || 0;
    }
    Part.prototype.parseUrl = function(urlTemplate, targetLang) {
        return urlTemplate.replace(/\{part\}/g, this.name).replace(/\{lang\}/g, targetLang);
    };
    Part.prototype.getTable = function(lang, $q, $http, $httpOptions, urlTemplate, errorHandler) {
        var deferred = $q.defer();
        if (!this.tables[lang]) {
            var self = this;
            $http(angular.extend({
                method: 'GET',
                url: this.parseUrl(urlTemplate, lang)
            }, $httpOptions)).success(function(data) {
                self.tables[lang] = data;
                deferred.resolve(data);
            }).error(function() {
                if (errorHandler) {
                    errorHandler(self.name, lang).then(function(data) {
                        self.tables[lang] = data;
                        deferred.resolve(data);
                    }, function() {
                        deferred.reject(self.name);
                    });
                } else {
                    deferred.reject(self.name);
                }
            });
        } else {
            deferred.resolve(this.tables[lang]);
        }
        return deferred.promise;
    };
    var parts = {};

    function hasPart(name) {
        return Object.prototype.hasOwnProperty.call(parts, name);
    }

    function isStringValid(str) {
        return angular.isString(str) && str !== '';
    }

    function isPartAvailable(name) {
        if (!isStringValid(name)) {
            throw new TypeError('Invalid type of a first argument, a non-empty string expected.');
        }
        return (hasPart(name) && parts[name].isActive);
    }

    function deepExtend(dst, src) {
        for (var property in src) {
            if (src[property] && src[property].constructor && src[property].constructor === Object) {
                dst[property] = dst[property] || {};
                deepExtend(dst[property], src[property]);
            } else {
                dst[property] = src[property];
            }
        }
        return dst;
    }

    function getPrioritizedParts() {
        var prioritizedParts = [];
        for (var part in parts) {
            if (parts[part].isActive) {
                prioritizedParts.push(parts[part]);
            }
        }
        prioritizedParts.sort(function(a, b) {
            return a.priority - b.priority;
        });
        return prioritizedParts;
    }
    this.addPart = function(name, priority) {
        if (!isStringValid(name)) {
            throw new TypeError('Couldn\'t add part, part name has to be a string!');
        }
        if (!hasPart(name)) {
            parts[name] = new Part(name, priority);
        }
        parts[name].isActive = true;
        return this;
    };
    this.setPart = function(lang, part, table) {
        if (!isStringValid(lang)) {
            throw new TypeError('Couldn\'t set part.`lang` parameter has to be a string!');
        }
        if (!isStringValid(part)) {
            throw new TypeError('Couldn\'t set part.`part` parameter has to be a string!');
        }
        if (typeof table !== 'object' || table === null) {
            throw new TypeError('Couldn\'t set part. `table` parameter has to be an object!');
        }
        if (!hasPart(part)) {
            parts[part] = new Part(part);
            parts[part].isActive = false;
        }
        parts[part].tables[lang] = table;
        return this;
    };
    this.deletePart = function(name) {
        if (!isStringValid(name)) {
            throw new TypeError('Couldn\'t delete part, first arg has to be string.');
        }
        if (hasPart(name)) {
            parts[name].isActive = false;
        }
        return this;
    };
    this.isPartAvailable = isPartAvailable;
    this.$get = ['$rootScope', '$injector', '$q', '$http', function($rootScope, $injector, $q, $http) {
        var service = function(options) {
            if (!isStringValid(options.key)) {
                throw new TypeError('Unable to load data, a key is not a non-empty string.');
            }
            if (!isStringValid(options.urlTemplate)) {
                throw new TypeError('Unable to load data, a urlTemplate is not a non-empty string.');
            }
            var errorHandler = options.loadFailureHandler;
            if (errorHandler !== undefined) {
                if (!angular.isString(errorHandler)) {
                    throw new Error('Unable to load data, a loadFailureHandler is not a string.');
                } else errorHandler = $injector.get(errorHandler);
            }
            var loaders = [],
                deferred = $q.defer(),
                prioritizedParts = getPrioritizedParts();
            angular.forEach(prioritizedParts, function(part, index) {
                loaders.push(part.getTable(options.key, $q, $http, options.$http, options.urlTemplate, errorHandler));
                part.urlTemplate = options.urlTemplate;
            });
            $q.all(loaders).then(function() {
                var table = {};
                angular.forEach(prioritizedParts, function(part) {
                    deepExtend(table, part.tables[options.key]);
                });
                deferred.resolve(table);
            }, function() {
                deferred.reject(options.key);
            });
            return deferred.promise;
        };
        service.addPart = function(name, priority) {
            if (!isStringValid(name)) {
                throw new TypeError('Couldn\'t add part, first arg has to be a string');
            }
            if (!hasPart(name)) {
                parts[name] = new Part(name, priority);
                $rootScope.$emit('$translatePartialLoaderStructureChanged', name);
            } else if (!parts[name].isActive) {
                parts[name].isActive = true;
                $rootScope.$emit('$translatePartialLoaderStructureChanged', name);
            }
            return service;
        };
        service.deletePart = function(name, removeData) {
            if (!isStringValid(name)) {
                throw new TypeError('Couldn\'t delete part, first arg has to be string');
            }
            if (removeData === undefined) {
                removeData = false;
            } else if (typeof removeData !== 'boolean') {
                throw new TypeError('Invalid type of a second argument, a boolean expected.');
            }
            if (hasPart(name)) {
                var wasActive = parts[name].isActive;
                if (removeData) {
                    var $translate = $injector.get('$translate');
                    var cache = $translate.loaderCache();
                    if (typeof(cache) === 'string') {
                        cache = $injector.get(cache);
                    }
                    if (typeof(cache) === 'object') {
                        angular.forEach(parts[name].tables, function(value, key) {
                            cache.remove(parts[name].parseUrl(parts[name].urlTemplate, key));
                        });
                    }
                    delete parts[name];
                } else {
                    parts[name].isActive = false;
                }
                if (wasActive) {
                    $rootScope.$emit('$translatePartialLoaderStructureChanged', name);
                }
            }
            return service;
        };
        service.isPartLoaded = function(name, lang) {
            return angular.isDefined(parts[name]) && angular.isDefined(parts[name].tables[lang]);
        };
        service.getRegisteredParts = function() {
            var registeredParts = [];
            angular.forEach(parts, function(p) {
                if (p.isActive) {
                    registeredParts.push(p.name);
                }
            });
            return registeredParts;
        };
        service.isPartAvailable = isPartAvailable;
        return service;
    }];
});
angular.module('pascalprecht.translate').factory('$translateCookieStorage', ['$cookieStore', function($cookieStore) {
    var $translateCookieStorage = {
        get: function(name) {
            return $cookieStore.get(name);
        },
        set: function(name, value) {
            $cookieStore.put(name, value);
        },
        put: function(name, value) {
            $cookieStore.put(name, value);
        }
    };
    return $translateCookieStorage;
}]);
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = 'ui.router';
}(function(window, angular, undefined) {
    'use strict';
    var isDefined = angular.isDefined,
        isFunction = angular.isFunction,
        isString = angular.isString,
        isObject = angular.isObject,
        isArray = angular.isArray,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy;

    function inherit(parent, extra) {
        return extend(new(extend(function() {}, {
            prototype: parent
        }))(), extra);
    }

    function merge(dst) {
        forEach(arguments, function(obj) {
            if (obj !== dst) {
                forEach(obj, function(value, key) {
                    if (!dst.hasOwnProperty(key)) dst[key] = value;
                });
            }
        });
        return dst;
    }

    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }

    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object);
        }
        var result = [];
        forEach(object, function(val, key) {
            result.push(key);
        });
        return result;
    }

    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0);
        }
        var len = array.length >>> 0,
            from = Number(arguments[2]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) from += len;
        for (; from < len; from++) {
            if (from in array && array[from] === value) return from;
        }
        return -1;
    }

    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to),
            parentParams, inherited = {},
            inheritList = [];
        for (var i in parents) {
            if (!parents[i].params) continue;
            parentParams = objectKeys(parents[i].params);
            if (!parentParams.length) continue;
            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0) continue;
                inheritList.push(parentParams[j]);
                inherited[parentParams[j]] = currentParams[parentParams[j]];
            }
        }
        return extend({}, inherited, newParams);
    }

    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return false;
        }
        return true;
    }

    function filterByKeys(keys, values) {
        var filtered = {};
        forEach(keys, function(name) {
            filtered[name] = values[name];
        });
        return filtered;
    }

    function indexBy(array, propName) {
        var result = {};
        forEach(array, function(item) {
            result[item[propName]] = item;
        });
        return result;
    }

    function pick(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        forEach(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    }

    function omit(obj) {
        var copy = {};
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) {
            if (indexOf(keys, key) == -1) copy[key] = obj[key];
        }
        return copy;
    }

    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = isFunction(key) ? key(val) : val[key];
        });
        return result;
    }

    function filter(collection, callback) {
        var array = isArray(collection);
        var result = array ? [] : {};
        forEach(collection, function(val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val;
            }
        });
        return result;
    }

    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        });
        return result;
    }
    angular.module('ui.router.util', ['ng']);
    angular.module('ui.router.router', ['ui.router.util']);
    angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
    angular.module('ui.router', ['ui.router.state']);
    angular.module('ui.router.compat', ['ui.router']);
    $Resolve.$inject = ['$q', '$injector'];

    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1,
            VISIT_DONE = 2,
            NOTHING = {},
            NO_DEPENDENCIES = [],
            NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {
                $$promises: NOTHING,
                $$values: NOTHING
            });
        this.study = function(invocables) {
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {});
            var plan = [],
                cycle = [],
                visited = {};

            function visit(value, key) {
                if (visited[key] === VISIT_DONE) return;
                cycle.push(key);
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key));
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "));
                }
                visited[key] = VISIT_IN_PROGRESS;
                if (isString(value)) {
                    plan.push(key, [function() {
                        return $injector.get(value);
                    }], NO_DEPENDENCIES);
                } else {
                    var params = $injector.annotate(value);
                    forEach(params, function(param) {
                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
                    });
                    plan.push(key, value, params);
                }
                cycle.pop();
                visited[key] = VISIT_DONE;
            }
            forEach(invocables, visit);
            invocables = cycle = visited = null;

            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            return function(locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent;
                    parent = locals;
                    locals = null;
                }
                if (!locals) locals = NO_LOCALS;
                else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object");
                }
                if (!parent) parent = NO_PARENT;
                else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                }
                var resolution = $q.defer(),
                    result = resolution.promise,
                    promises = result.$$promises = {},
                    values = extend({}, locals),
                    wait = 1 + plan.length / 3,
                    merged = false;

                function done() {
                    if (!--wait) {
                        if (!merged) merge(values, parent.$$values);
                        result.$$values = values;
                        result.$$promises = result.$$promises || true;
                        delete result.$$inheritedValues;
                        resolution.resolve(values);
                    }
                }

                function fail(reason) {
                    result.$$failure = reason;
                    resolution.reject(reason);
                }
                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure);
                    return result;
                }
                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys));
                }
                extend(promises, parent.$$promises);
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys));
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                    done();
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                    }
                    parent.then(done, fail);
                }
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i])) done();
                    else invoke(plan[i], plan[i + 1], plan[i + 2]);
                }

                function invoke(key, invocable, params) {
                    var invocation = $q.defer(),
                        waitParams = 0;

                    function onfailure(reason) {
                        invocation.reject(reason);
                        fail(reason);
                    }
                    forEach(params, function(dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++;
                            promises[dep].then(function(result) {
                                values[dep] = result;
                                if (!(--waitParams)) proceed();
                            }, onfailure);
                        }
                    });
                    if (!waitParams) proceed();

                    function proceed() {
                        if (isDefined(result.$$failure)) return;
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values));
                            invocation.promise.then(function(result) {
                                values[key] = result;
                                done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    promises[key] = invocation.promise;
                }
                return result;
            };
        };
        this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    angular.module('ui.router.util').service('$resolve', $Resolve);
    $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];

    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
        };
        this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        };
        this.fromUrl = function(url, params) {
            if (isFunction(url)) url = url(params);
            if (url == null) return null;
            else return $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: 'text/html'
                }
            }).then(function(response) {
                return response.data;
            });
        };
        this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
    var $$UMFP;

    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = '^',
            last = 0,
            m, segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
            paramNames = [];

        function addParameter(id, type, config, location) {
            paramNames.push(id);
            if (parentParams[id]) return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            params[id] = new $$UMFP.Param(id, type, config, location);
            return params[id];
        }

        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = ['', ''],
                result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
                case false:
                    surroundPattern = ['(', ')' + (optional ? "?" : "")];
                    break;
                case true:
                    surroundPattern = ['?(', ')?'];
                    break;
                default:
                    surroundPattern = ['(' + squash + "|", ')?'];
                    break;
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        this.source = pattern;

        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode;
            id = m[2] || m[3];
            cfg = config.params[id];
            segment = pattern.substring(last, m.index);
            regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
            type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)
            });
            return {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        var p, param, segment;
        while ((m = placeholder.exec(pattern))) {
            p = matchDetails(m, false);
            if (p.segment.indexOf('?') >= 0) break;
            param = addParameter(p.id, p.type, p.cfg, "path");
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
            segments.push(p.segment);
            last = placeholder.lastIndex;
        }
        segment = pattern.substring(last);
        var i = segment.indexOf('?');
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            segment = segment.substring(0, i);
            this.sourcePath = pattern.substring(0, last + i);
            if (search.length > 0) {
                last = 0;
                while ((m = searchPlaceholder.exec(search))) {
                    p = matchDetails(m, true);
                    param = addParameter(p.id, p.type, p.cfg, "search");
                    last = placeholder.lastIndex;
                }
            }
        } else {
            this.sourcePath = pattern;
            this.sourceSearch = '';
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
        segments.push(segment);
        this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
        this.prefix = segments[0];
        this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
        return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var paramNames = this.parameters(),
            nTotal = paramNames.length,
            nPath = this.segments.length - 1,
            values = {},
            i, j, cfg, paramName;
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }

            function unquoteDashes(str) {
                return str.replace(/\\-/g, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/);
            var allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName];
            var paramVal = m[i + 1];
            for (j = 0; j < param.replace; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
            }
            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
            values[paramName] = param.value(paramVal);
        }
        for (; i < nTotal; i++) {
            paramName = paramNames[i];
            values[paramName] = this.params[paramName].value(searchParams[paramName]);
        }
        return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
        if (!isDefined(param)) return this.$$paramNames;
        return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
        values = values || {};
        var segments = this.segments,
            params = this.parameters(),
            paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = false,
            nPath = segments.length - 1,
            nTotal = params.length,
            result = segments[0];

        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath;
            var name = params[i],
                param = paramset[name],
                value = param.value(values[name]);
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
            var squash = isDefaultValue ? param.squash : false;
            var encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-");
                        } else {
                            result += encodeURIComponent(encoded);
                        }
                    }
                    result += nextSegment;
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else if (isString(squash)) {
                    result += squash + nextSegment;
                }
            } else {
                if (encoded == null || (isDefaultValue && squash !== false)) continue;
                if (!isArray(encoded)) encoded = [encoded];
                encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
                result += (search ? '&' : '?') + (name + '=' + encoded);
                search = true;
            }
        }
        return result;
    };

    function Type(config) {
        extend(this, config);
    }
    Type.prototype.is = function(val, key) {
        return true;
    };
    Type.prototype.encode = function(val, key) {
        return val;
    };
    Type.prototype.decode = function(val, key) {
        return val;
    };
    Type.prototype.equals = function(a, b) {
        return a == b;
    };
    Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    };
    Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
    };
    Type.prototype.$asArray = function(mode, isSearch) {
        if (!mode) return this;
        if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");

        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }

            function arrayWrap(val) {
                return isArray(val) ? val : (isDefined(val) ? [val] : []);
            }

            function arrayUnwrap(val) {
                switch (val.length) {
                    case 0:
                        return undefined;
                    case 1:
                        return mode === "auto" ? val[0] : val;
                    default:
                        return val;
                }
            }

            function falsey(val) {
                return !val;
            }

            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    if (allTruthyMode === true) return filter(result, falsey).length === 0;
                    return arrayUnwrap(result);
                };
            }

            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1),
                        right = arrayWrap(val2);
                    if (left.length !== right.length) return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i])) return false;
                    }
                    return true;
                };
            }
            this.encode = arrayHandler(bindTo(type, 'encode'));
            this.decode = arrayHandler(bindTo(type, 'decode'));
            this.is = arrayHandler(bindTo(type, 'is'), true);
            this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
            this.pattern = type.pattern;
            this.$normalize = arrayHandler(bindTo(type, '$normalize'));
            this.name = type.name;
            this.$arrayMode = mode;
        }
        return new ArrayType(this, mode);
    };

    function $UrlMatcherFactory() {
        $$UMFP = this;
        var isCaseInsensitive = false,
            isStrictMode = true,
            defaultSquashPolicy = false;

        function valToString(val) {
            return val != null ? val.toString().replace(/\//g, "%2F") : val;
        }

        function valFromString(val) {
            return val != null ? val.toString().replace(/%2F/g, "/") : val;
        }
        var $types = {},
            enqueue = true,
            typeQueue = [],
            injector, defaultTypes = {
                string: {
                    encode: valToString,
                    decode: valFromString,
                    is: function(val) {
                        return val == null || !isDefined(val) || typeof val === "string";
                    },
                    pattern: /[^/]*/
                },
                int: {
                    encode: valToString,
                    decode: function(val) {
                        return parseInt(val, 10);
                    },
                    is: function(val) {
                        return isDefined(val) && this.decode(val.toString()) === val;
                    },
                    pattern: /\d+/
                },
                bool: {
                    encode: function(val) {
                        return val ? 1 : 0;
                    },
                    decode: function(val) {
                        return parseInt(val, 10) !== 0;
                    },
                    is: function(val) {
                        return val === true || val === false;
                    },
                    pattern: /0|1/
                },
                date: {
                    encode: function(val) {
                        if (!this.is(val)) return undefined;
                        return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
                    },
                    decode: function(val) {
                        if (this.is(val)) return val;
                        var match = this.capture.exec(val);
                        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                    },
                    is: function(val) {
                        return val instanceof Date && !isNaN(val.valueOf());
                    },
                    equals: function(a, b) {
                        return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                    },
                    pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                    capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
                },
                json: {
                    encode: angular.toJson,
                    decode: angular.fromJson,
                    is: angular.isObject,
                    equals: angular.equals,
                    pattern: /[^/]*/
                },
                any: {
                    encode: angular.identity,
                    decode: angular.identity,
                    equals: angular.equals,
                    pattern: /.*/
                }
            };

        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }

        function isInjectable(value) {
            return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
        }
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        };
        this.caseInsensitive = function(value) {
            if (isDefined(value)) isCaseInsensitive = value;
            return isCaseInsensitive;
        };
        this.strictMode = function(value) {
            if (isDefined(value)) isStrictMode = value;
            return isStrictMode;
        };
        this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== true && value !== false && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            defaultSquashPolicy = value;
            return value;
        };
        this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        };
        this.isMatcher = function(o) {
            if (!isObject(o)) return false;
            var result = true;
            forEach(UrlMatcher.prototype, function(val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]));
                }
            });
            return result;
        };
        this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            $types[name] = new Type(extend({
                name: name
            }, definition));
            if (definitionFn) {
                typeQueue.push({
                    name: name,
                    def: definitionFn
                });
                if (!enqueue) flushTypeQueue();
            }
            return this;
        };

        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        });
        $types = inherit($types, {});
        this.$get = ['$injector', function($injector) {
            injector = $injector;
            enqueue = false;
            flushTypeQueue();
            forEach(defaultTypes, function(type, name) {
                if (!$types[name]) $types[name] = new Type(type);
            });
            return this;
        }];
        this.Param = function Param(id, type, config, location) {
            var self = this;
            config = unwrapShorthand(config);
            type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = "";
            var isOptional = config.value !== undefined;
            var squash = getSquashPolicy(config, isOptional);
            var replace = getReplace(config, arrayMode, isOptional, squash);

            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [];
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                if (isShorthand) config = {
                    value: config
                };
                config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                };
                return config;
            }

            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                if (urlType) return urlType;
                if (!config.type) return (location === "config" ? $types.any : $types.string);
                return config.type instanceof Type ? config.type : new Type(config.type);
            }

            function getArrayMode() {
                var arrayDefaults = {
                    array: (location === "search" ? "auto" : false)
                };
                var arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: true
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }

            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === false) return false;
                if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
                if (squash === true || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }

            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [{
                    from: "",
                    to: (isOptional || arrayMode ? undefined : "")
                }, {
                    from: null,
                    to: (isOptional || arrayMode ? undefined : "")
                }];
                replace = isArray(config.replace) ? config.replace : [];
                if (isString(squash)) replace.push({
                    from: squash,
                    to: undefined
                });
                configuredKeys = map(replace, function(item) {
                    return item.from;
                });
                return filter(defaultPolicy, function(item) {
                    return indexOf(configuredKeys, item.from) === -1;
                }).concat(replace);
            }

            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = injector.invoke(config.$$fn);
                if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                return defaultValue;
            }

            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }

                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                value = $replace(value);
                return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
            }

            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        };

        function ParamSet(params) {
            extend(this, params || {});
        }
        ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                var keys = [],
                    chain = [],
                    parent = this,
                    ignore = objectKeys(ParamSet.prototype);
                while (parent) {
                    chain.push(parent);
                    parent = parent.$$parent;
                }
                chain.reverse();
                forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
                    });
                });
                return keys;
            },
            $$values: function(paramValues) {
                var values = {},
                    self = this;
                forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                });
                return values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = true,
                    self = this;
                forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key],
                        right = paramValues2 && paramValues2[key];
                    if (!self[key].type.equals(left, right)) equal = false;
                });
                return equal;
            },
            $$validates: function $$validate(paramValues) {
                var keys = this.$$keys(),
                    i, param, rawVal, normalized, encoded;
                for (i = 0; i < keys.length; i++) {
                    param = this[keys[i]];
                    rawVal = paramValues[keys[i]];
                    if ((rawVal === undefined || rawVal === null) && param.isOptional) break;
                    normalized = param.type.$normalize(rawVal);
                    if (!param.type.is(normalized)) return false;
                    encoded = param.type.encode(normalized);
                    if (angular.isString(encoded) && !param.type.pattern.exec(encoded)) return false;
                }
                return true;
            },
            $$parent: undefined
        };
        this.ParamSet = ParamSet;
    }
    angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
    angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
    $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];

    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [],
            otherwise = null,
            interceptDeferred = false,
            listener;

        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
        }

        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match[what === '$' ? 0 : Number(what)];
            });
        }
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            rules.push(rule);
            return this;
        };
        this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            otherwise = rule;
            return this;
        };

        function handleIfMatch($injector, handler, match) {
            if (!match) return false;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : true;
        }
        this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what)) what = $urlMatcherFactory.compile(what);
            if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler);
                        handler = ['$match', function($match) {
                            return redirect.format($match);
                        }];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ''
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    if (handlerIsString) {
                        redirect = handler;
                        handler = ['$match', function($match) {
                            return interpolate(redirect, $match);
                        }];
                    }
                    return extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            };
            var check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) {
                if (check[n]) return this.rule(strategies[n](what, handler));
            }
            throw new Error("invalid 'what' in when()");
        };
        this.deferIntercept = function(defer) {
            if (defer === undefined) defer = true;
            interceptDeferred = defer;
        };
        this.$get = $get;
        $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];

        function $get($location, $rootScope, $injector, $browser) {
            var baseHref = $browser.baseHref(),
                location = $location.url(),
                lastPushedUrl;

            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === '/') return url;
                if (isHtml5) return baseHref.slice(0, -1) + url;
                if (absolute) return baseHref.slice(1) + url;
                return url;
            }

            function update(evt) {
                if (evt && evt.defaultPrevented) return;
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                lastPushedUrl = undefined;

                function check(rule) {
                    var handled = rule($injector, $location);
                    if (!handled) return false;
                    if (isString(handled)) $location.replace().url(handled);
                    return true;
                }
                var n = rules.length,
                    i;
                for (i = 0; i < n; i++) {
                    if (check(rules[i])) return;
                }
                if (otherwise) check(otherwise);
            }

            function listen() {
                listener = listener || $rootScope.$on('$locationChangeSuccess', update);
                return listener;
            }
            if (!interceptDeferred) listen();
            return {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    if (read) {
                        location = $location.url();
                        return;
                    }
                    if ($location.url() === location) return;
                    $location.url(location);
                    $location.replace();
                },
                push: function(urlMatcher, params, options) {
                    var url = urlMatcher.format(params || {});
                    if (url !== null && params && params['#']) {
                        url += '#' + params['#'];
                    }
                    $location.url(url);
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                    if (options && options.replace) $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled;
                    }
                    var url = urlMatcher.format(params);
                    options = options || {};
                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url;
                    }
                    if (url !== null && params && params['#']) {
                        url += '#' + params['#'];
                    }
                    url = appendBasePath(url, isHtml5, options.absolute);
                    if (!options.absolute || !url) {
                        return url;
                    }
                    var slash = (!isHtml5 && url ? '/' : ''),
                        port = $location.port();
                    port = (port === 80 || port === 443 ? '' : ':' + port);
                    return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
                }
            };
        }
    }
    angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
    $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];

    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, states = {},
            $state, queue = {},
            abstractKey = 'abstract';
        var stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = extend({}, state.parent.data, state.data);
                }
                return state.data;
            },
            url: function(state) {
                var url = state.url,
                    config = {
                        params: state.params || {}
                    };
                if (isString(url)) {
                    if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
                    return (state.parent.navigable || root).url.concat(url, config);
                }
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : (state.parent ? state.parent.navigable : null);
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                forEach(state.params || {}, function(config, id) {
                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
                });
                return params;
            },
            params: function(state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                forEach(isDefined(state.views) ? state.views : {
                    '': state
                }, function(view, name) {
                    if (name.indexOf('@') < 0) name += '@' + state.parent.name;
                    views[name] = view;
                });
                return views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                includes[state.name] = true;
                return includes;
            },
            $delegates: {}
        };

        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
        }

        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName),
                name = isStr ? stateOrName : stateOrName.name,
                path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                var rel = name.split("."),
                    i = 0,
                    pathLength = rel.length,
                    current = base;
                for (; i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base;
                        continue;
                    }
                    if (rel[i] === "^") {
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                rel = rel.slice(i).join(".");
                name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
                return state;
            }
            return undefined;
        }

        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = [];
            }
            queue[parentName].push(state);
        }

        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || [];
            while (queued.length) {
                registerState(queued.shift());
            }
        }

        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self);
            }
            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
            }
            states[name] = state;
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                        $state.transitionTo(state, $match, {
                            inherit: true,
                            location: false
                        });
                    }
                }]);
            }
            flushQueuedChildren(name);
            return state;
        }

        function isGlob(text) {
            return text.indexOf('*') > -1;
        }

        function doesStateMatchGlob(glob) {
            var globSegments = glob.split('.'),
                segments = $state.$current.name.split('.');
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === '*') {
                    segments[i] = '*';
                }
            }
            if (globSegments[0] === '**') {
                segments = segments.slice(indexOf(segments, globSegments[1]));
                segments.unshift('**');
            }
            if (globSegments[globSegments.length - 1] === '**') {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                segments.push('**');
            }
            if (globSegments.length != segments.length) {
                return false;
            }
            return segments.join('') === globSegments.join('');
        }
        root = registerState({
            name: '',
            url: '^',
            views: null,
            'abstract': true
        });
        root.navigable = null;
        this.decorator = decorator;

        function decorator(name, func) {
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name];
            }
            if (!isFunction(func) || !isString(name)) {
                return this;
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name];
            }
            stateBuilder[name] = func;
            return this;
        }
        this.state = state;

        function state(name, definition) {
            if (isObject(name)) definition = name;
            else definition.name = name;
            registerState(definition);
            return this;
        }
        this.$get = $get;
        $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];

        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSuperseded = $q.reject(new Error('transition superseded'));
            var TransitionPrevented = $q.reject(new Error('transition prevented'));
            var TransitionAborted = $q.reject(new Error('transition aborted'));
            var TransitionFailed = $q.reject(new Error('transition failed'));

            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
                if (evt.defaultPrevented) {
                    $urlRouter.update();
                    return TransitionAborted;
                }
                if (!evt.retry) {
                    return null;
                }
                if (options.$retry) {
                    $urlRouter.update();
                    return TransitionFailed;
                }
                var retryTransition = $state.transition = $q.when(evt.retry);
                retryTransition.then(function() {
                    if (retryTransition !== $state.transition) return TransitionSuperseded;
                    redirect.options.$retry = true;
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                }, function() {
                    return TransitionAborted;
                });
                $urlRouter.update();
                return retryTransition;
            }
            root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            };
            $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            };
            $state.reload = function reload(state) {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: state || true,
                    inherit: false,
                    notify: true
                });
            };
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: true,
                    relative: $state.$current
                }, options));
            };
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {};
                options = extend({
                    location: true,
                    inherit: false,
                    relative: null,
                    notify: true,
                    reload: false,
                    $retry: false
                }, options || {});
                var from = $state.$current,
                    fromParams = $state.params,
                    fromPath = from.path;
                var evt, toState = findState(to, options.relative);
                var hash = toParams['#'];
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    };
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) {
                        return redirectResult;
                    }
                    to = redirect.to;
                    toParams = redirect.toParams;
                    options = redirect.options;
                    toState = findState(to, options.relative);
                    if (!isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                if (!toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams);
                to = toState;
                var toPath = to.path;
                var keep = 0,
                    state = toPath[keep],
                    locals = root.locals,
                    toLocals = [];
                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                } else if (isString(options.reload) || isObject(options.reload)) {
                    if (isObject(options.reload) && !options.reload.name) {
                        throw new Error('Invalid reload state object');
                    }
                    var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                    if (options.reload && !reloadState) {
                        throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                    }
                    while (state && state === fromPath[keep] && state !== reloadState) {
                        locals = toLocals[keep] = state.locals;
                        keep++;
                        state = toPath[keep];
                    }
                }
                if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
                    if (hash) toParams['#'] = hash;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    if (options.location && to.navigable && to.navigable.url) {
                        $urlRouter.push(to.navigable.url, toParams, {
                            $$avoidResync: true,
                            replace: options.location === 'replace'
                        });
                        $urlRouter.update(true);
                    }
                    $state.transition = null;
                    return $q.when($state.current);
                }
                toParams = filterByKeys(to.params.$$keys(), toParams || {});
                if (options.notify) {
                    if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
                        $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                        $urlRouter.update();
                        return TransitionPrevented;
                    }
                }
                var resolved = $q.when(locals);
                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals);
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                }
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l];
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                        }
                        exiting.locals = null;
                    }
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l];
                        entering.locals = toLocals[l];
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        }
                    }
                    if (hash) toParams['#'] = hash;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.$current = to;
                    $state.current = to.self;
                    $state.params = toParams;
                    copy($state.params, $stateParams);
                    $state.transition = null;
                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true,
                            replace: options.location === 'replace'
                        });
                    }
                    if (options.notify) {
                        $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
                    }
                    $urlRouter.update(true);
                    return $state.current;
                }, function(error) {
                    if ($state.transition !== transition) return TransitionSuperseded;
                    $state.transition = null;
                    evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
                    if (!evt.defaultPrevented) {
                        $urlRouter.update();
                    }
                    return $q.reject(error);
                });
                return transition;
            };
            $state.is = function is(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if ($state.$current !== state) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
            };
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false;
                    }
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) {
                    return undefined;
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false;
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
            };
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
                var nav = (state && options.lossy) ? state.navigable : state;
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
                    absolute: options.absolute
                });
            };
            $state.get = function(stateOrName, context) {
                if (arguments.length === 0) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return (state && state.self) ? state.self : null;
            };

            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
                var locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [dst.resolve.then(function(globals) {
                    dst.globals = globals;
                })];
                if (inherited) promises.push(inherited);

                function resolveViews() {
                    var viewsPromises = [];
                    forEach(state.views, function(view, name) {
                        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
                        injectables.$template = [function() {
                            return $view.load(name, {
                                view: view,
                                locals: dst.globals,
                                params: $stateParams,
                                notify: options.notify
                            }) || '';
                        }];
                        viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                var injectLocals = angular.extend({}, injectables, dst.globals);
                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                            } else {
                                result.$$controller = view.controller;
                            }
                            result.$$state = state;
                            result.$$controllerAs = view.controllerAs;
                            dst[name] = result;
                        }));
                    });
                    return $q.all(viewsPromises).then(function() {
                        return dst.globals;
                    });
                }
                return $q.all(promises).then(resolveViews).then(function(values) {
                    return dst;
                });
            }
            return $state;
        }

        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
            function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                function notSearchParam(key) {
                    return fromAndToState.params[key].location != "search";
                }
                var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
                var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
                var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                return nonQueryParamSet.$$equals(fromParams, toParams);
            }
            if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
                return true;
            }
        }
    }
    angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
    $ViewProvider.$inject = [];

    function $ViewProvider() {
        this.$get = $get;
        $get.$inject = ['$rootScope', '$templateFactory'];

        function $get($rootScope, $templateFactory) {
            return {
                load: function load(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: true,
                        async: true,
                        params: {}
                    };
                    options = extend(defaults, options);
                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                    }
                    if (result && options.notify) {
                        $rootScope.$broadcast('$viewContentLoading', options);
                    }
                    return result;
                }
            };
        }
    }
    angular.module('ui.router.state').provider('$view', $ViewProvider);

    function $ViewScrollProvider() {
        var useAnchorScroll = false;
        this.useAnchorScroll = function() {
            useAnchorScroll = true;
        };
        this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll;
            }
            return function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, false);
            };
        }];
    }
    angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
    $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];

    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return ($injector.has) ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        var service = getService(),
            $animator = service('$animator'),
            $animate = service('$animate');

        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element);
                        cb();
                    },
                    leave: function(element, cb) {
                        element.remove();
                        cb();
                    }
                };
            };
            if ($animate) {
                return {
                    enter: function(element, target, cb) {
                        var promise = $animate.enter(element, null, target, cb);
                        if (promise && promise.then) promise.then(cb);
                    },
                    leave: function(element, cb) {
                        var promise = $animate.leave(element, cb);
                        if (promise && promise.then) promise.then(cb);
                    }
                };
            }
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target);
                        cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element);
                        cb();
                    }
                };
            }
            return statics();
        }
        var directive = {
            restrict: 'ECA',
            terminal: true,
            priority: 400,
            transclude: 'element',
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || '',
                        autoScrollExp = attrs.autoscroll,
                        renderer = getRenderer(attrs, scope);
                    scope.$on('$stateChangeSuccess', function() {
                        updateView(false);
                    });
                    scope.$on('$viewContentLoading', function() {
                        updateView(false);
                    });
                    updateView(true);

                    function cleanupLastView() {
                        if (previousEl) {
                            previousEl.remove();
                            previousEl = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentEl) {
                            renderer.leave(currentEl, function() {
                                previousEl = null;
                            });
                            previousEl = currentEl;
                            currentEl = null;
                        }
                    }

                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate),
                            previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (!firstTime && previousLocals === latestLocals) return;
                        newScope = scope.$new();
                        latestLocals = $state.$current.locals[name];
                        var clone = $transclude(newScope, function(clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit('$viewContentAnimationEnded');
                                }
                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone);
                                }
                            });
                            cleanupLastView();
                        });
                        currentEl = clone;
                        currentScope = newScope;
                        currentScope.$emit('$viewContentLoaded');
                        currentScope.$eval(onloadExp);
                    }
                };
            }
        };
        return directive;
    }
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];

    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: 'ECA',
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current,
                        name = getUiViewName(scope, attrs, $element, $interpolate),
                        locals = current && current.locals[name];
                    if (!locals) {
                        return;
                    }
                    $element.data('$uiView', {
                        name: name,
                        state: locals.$$state
                    });
                    $element.html(locals.$template ? locals.$template : initial);
                    var link = $compile($element.contents());
                    if (locals.$$controller) {
                        locals.$scope = scope;
                        locals.$element = $element;
                        var controller = $controller(locals.$$controller, locals);
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller;
                        }
                        $element.data('$ngControllerController', controller);
                        $element.children().data('$ngControllerController', controller);
                    }
                    link(scope);
                };
            }
        };
    }

    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
        var inherited = element.inheritedData('$uiView');
        return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
    }
    angular.module('ui.router.state').directive('uiView', $ViewDirective);
    angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
            parsed;
        if (preparsed) ref = current + '(' + preparsed[1] + ')';
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
        if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }

    function stateContext(el) {
        var stateData = el.parent().inheritedData('$uiView');
        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state;
        }
    }
    $StateRefDirective.$inject = ['$state', '$timeout'];

    function $StateRefDirective($state, $timeout) {
        var allowedOptions = ['location', 'inherit', 'reload', 'absolute'];
        return {
            restrict: 'A',
            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name);
                var params = null,
                    url = null,
                    base = stateContext(element) || $state.$current;
                var hrefKind = Object.prototype.toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
                var newHref = null,
                    isAnchor = element.prop("tagName").toUpperCase() === "A";
                var isForm = element[0].nodeName === "FORM";
                var attr = isForm ? "action" : hrefKind,
                    nav = true;
                var options = {
                    relative: base,
                    inherit: true
                };
                var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    if (option in optionsOverride) {
                        options[option] = optionsOverride[option];
                    }
                });
                var update = function(newVal) {
                    if (newVal) params = angular.copy(newVal);
                    if (!nav) return;
                    newHref = $state.href(ref.state, params, options);
                    var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                    if (activeDirective) {
                        activeDirective.$$addStateInfo(ref.state, params);
                    }
                    if (newHref === null) {
                        nav = false;
                        return false;
                    }
                    attrs.$set(attr, newHref);
                };
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function(newVal, oldVal) {
                        if (newVal !== params) update(newVal);
                    }, true);
                    params = angular.copy(scope.$eval(ref.paramExpr));
                }
                update();
                if (isForm) return;
                element.bind("click", function(e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
                        var transition = $timeout(function() {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function() {
                            if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }
    $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];

    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
                var states = [],
                    activeClass;
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
                this.$$addStateInfo = function(newState, newParams) {
                    var state = $state.get(newState, stateContext($element));
                    states.push({
                        state: state || {
                            name: newState
                        },
                        params: newParams
                    });
                    update();
                };
                $scope.$on('$stateChangeSuccess', update);

                function update() {
                    if (anyMatch()) {
                        $element.addClass(activeClass);
                    } else {
                        $element.removeClass(activeClass);
                    }
                }

                function anyMatch() {
                    for (var i = 0; i < states.length; i++) {
                        if (isMatch(states[i].state, states[i].params)) {
                            return true;
                        }
                    }
                    return false;
                }

                function isMatch(state, params) {
                    if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
                        return $state.is(state.name, params);
                    } else {
                        return $state.includes(state.name, params);
                    }
                }
            }]
        };
    }
    angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
    $IsStateFilter.$inject = ['$state'];

    function $IsStateFilter($state) {
        var isFilter = function(state) {
            return $state.is(state);
        };
        isFilter.$stateful = true;
        return isFilter;
    }
    $IncludedByStateFilter.$inject = ['$state'];

    function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
            return $state.includes(state);
        };
        includesFilter.$stateful = true;
        return includesFilter;
    }
    angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
})(window, window.angular);
if (typeof jQuery === 'undefined') {
    throw new Error('Bootstrap\'s JavaScript requires jQuery')
} + function($) {
    'use strict';
    var version = $.fn.jquery.split(' ')[0].split('.')
    if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3')
    }
}(jQuery);
(function(root, factory) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(['moment'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('moment'));
    } else {
        factory(root.moment);
    }
}(this, function(moment) {
    "use strict";
    if (moment.tz !== undefined) {
        logError('Moment Timezone ' + moment.tz.version + ' was already loaded ' + (moment.tz.dataVersion ? 'with data from ' : 'without any data') + moment.tz.dataVersion);
        return moment;
    }
    var VERSION = "0.4.1",
        zones = {},
        links = {},
        names = {},
        momentVersion = moment.version.split('.'),
        major = +momentVersion[0],
        minor = +momentVersion[1];
    if (major < 2 || (major === 2 && minor < 6)) {
        logError('Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js ' + moment.version + '. See momentjs.com');
    }

    function charCodeToInt(charCode) {
        if (charCode > 96) {
            return charCode - 87;
        } else if (charCode > 64) {
            return charCode - 29;
        }
        return charCode - 48;
    }

    function unpackBase60(string) {
        var i = 0,
            parts = string.split('.'),
            whole = parts[0],
            fractional = parts[1] || '',
            multiplier = 1,
            num, out = 0,
            sign = 1;
        if (string.charCodeAt(0) === 45) {
            i = 1;
            sign = -1;
        }
        for (i; i < whole.length; i++) {
            num = charCodeToInt(whole.charCodeAt(i));
            out = 60 * out + num;
        }
        for (i = 0; i < fractional.length; i++) {
            multiplier = multiplier / 60;
            num = charCodeToInt(fractional.charCodeAt(i));
            out += num * multiplier;
        }
        return out * sign;
    }

    function arrayToInt(array) {
        for (var i = 0; i < array.length; i++) {
            array[i] = unpackBase60(array[i]);
        }
    }

    function intToUntil(array, length) {
        for (var i = 0; i < length; i++) {
            array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000));
        }
        array[length - 1] = Infinity;
    }

    function mapIndices(source, indices) {
        var out = [],
            i;
        for (i = 0; i < indices.length; i++) {
            out[i] = source[indices[i]];
        }
        return out;
    }

    function unpack(string) {
        var data = string.split('|'),
            offsets = data[2].split(' '),
            indices = data[3].split(''),
            untils = data[4].split(' ');
        arrayToInt(offsets);
        arrayToInt(indices);
        arrayToInt(untils);
        intToUntil(untils, indices.length);
        return {
            name: data[0],
            abbrs: mapIndices(data[1].split(' '), indices),
            offsets: mapIndices(offsets, indices),
            untils: untils
        };
    }

    function Zone(packedString) {
        if (packedString) {
            this._set(unpack(packedString));
        }
    }
    Zone.prototype = {
        _set: function(unpacked) {
            this.name = unpacked.name;
            this.abbrs = unpacked.abbrs;
            this.untils = unpacked.untils;
            this.offsets = unpacked.offsets;
        },
        _index: function(timestamp) {
            var target = +timestamp,
                untils = this.untils,
                i;
            for (i = 0; i < untils.length; i++) {
                if (target < untils[i]) {
                    return i;
                }
            }
        },
        parse: function(timestamp) {
            var target = +timestamp,
                offsets = this.offsets,
                untils = this.untils,
                max = untils.length - 1,
                offset, offsetNext, offsetPrev, i;
            for (i = 0; i < max; i++) {
                offset = offsets[i];
                offsetNext = offsets[i + 1];
                offsetPrev = offsets[i ? i - 1 : i];
                if (offset < offsetNext && tz.moveAmbiguousForward) {
                    offset = offsetNext;
                } else if (offset > offsetPrev && tz.moveInvalidForward) {
                    offset = offsetPrev;
                }
                if (target < untils[i] - (offset * 60000)) {
                    return offsets[i];
                }
            }
            return offsets[max];
        },
        abbr: function(mom) {
            return this.abbrs[this._index(mom)];
        },
        offset: function(mom) {
            return this.offsets[this._index(mom)];
        }
    };

    function normalizeName(name) {
        return (name || '').toLowerCase().replace(/\//g, '_');
    }

    function addZone(packed) {
        var i, name, normalized;
        if (typeof packed === "string") {
            packed = [packed];
        }
        for (i = 0; i < packed.length; i++) {
            name = packed[i].split('|')[0];
            normalized = normalizeName(name);
            zones[normalized] = packed[i];
            names[normalized] = name;
        }
    }

    function getZone(name, caller) {
        name = normalizeName(name);
        var zone = zones[name];
        var link;
        if (zone instanceof Zone) {
            return zone;
        }
        if (typeof zone === 'string') {
            zone = new Zone(zone);
            zones[name] = zone;
            return zone;
        }
        if (links[name] && caller !== getZone && (link = getZone(links[name], getZone))) {
            zone = zones[name] = new Zone();
            zone._set(link);
            zone.name = names[name];
            return zone;
        }
        return null;
    }

    function getNames() {
        var i, out = [];
        for (i in names) {
            if (names.hasOwnProperty(i) && (zones[i] || zones[links[i]]) && names[i]) {
                out.push(names[i]);
            }
        }
        return out.sort();
    }

    function addLink(aliases) {
        var i, alias, normal0, normal1;
        if (typeof aliases === "string") {
            aliases = [aliases];
        }
        for (i = 0; i < aliases.length; i++) {
            alias = aliases[i].split('|');
            normal0 = normalizeName(alias[0]);
            normal1 = normalizeName(alias[1]);
            links[normal0] = normal1;
            names[normal0] = alias[0];
            links[normal1] = normal0;
            names[normal1] = alias[1];
        }
    }

    function loadData(data) {
        addZone(data.zones);
        addLink(data.links);
        tz.dataVersion = data.version;
    }

    function zoneExists(name) {
        if (!zoneExists.didShowError) {
            zoneExists.didShowError = true;
            logError("moment.tz.zoneExists('" + name + "') has been deprecated in favor of !moment.tz.zone('" + name + "')");
        }
        return !!getZone(name);
    }

    function needsOffset(m) {
        return !!(m._a && (m._tzm === undefined));
    }

    function logError(message) {
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
            console.error(message);
        }
    }

    function tz(input) {
        var args = Array.prototype.slice.call(arguments, 0, -1),
            name = arguments[arguments.length - 1],
            zone = getZone(name),
            out = moment.utc.apply(null, args);
        if (zone && !moment.isMoment(input) && needsOffset(out)) {
            out.add(zone.parse(out), 'minutes');
        }
        out.tz(name);
        return out;
    }
    tz.version = VERSION;
    tz.dataVersion = '';
    tz._zones = zones;
    tz._links = links;
    tz._names = names;
    tz.add = addZone;
    tz.link = addLink;
    tz.load = loadData;
    tz.zone = getZone;
    tz.zoneExists = zoneExists;
    tz.names = getNames;
    tz.Zone = Zone;
    tz.unpack = unpack;
    tz.unpackBase60 = unpackBase60;
    tz.needsOffset = needsOffset;
    tz.moveInvalidForward = true;
    tz.moveAmbiguousForward = false;
    var fn = moment.fn;
    moment.tz = tz;
    moment.defaultZone = null;
    moment.updateOffset = function(mom, keepTime) {
        var zone = moment.defaultZone,
            offset;
        if (mom._z === undefined) {
            if (zone && needsOffset(mom) && !mom._isUTC) {
                mom._d = moment.utc(mom._a)._d;
                mom.utc().add(zone.parse(mom), 'minutes');
            }
            mom._z = zone;
        }
        if (mom._z) {
            offset = mom._z.offset(mom);
            if (Math.abs(offset) < 16) {
                offset = offset / 60;
            }
            if (mom.utcOffset !== undefined) {
                mom.utcOffset(-offset, keepTime);
            } else {
                mom.zone(offset, keepTime);
            }
        }
    };
    fn.tz = function(name) {
        if (name) {
            this._z = getZone(name);
            if (this._z) {
                moment.updateOffset(this);
            } else {
                logError("Moment Timezone has no data for " + name + ". See http://momentjs.com/timezone/docs/#/data-loading/.");
            }
            return this;
        }
        if (this._z) {
            return this._z.name;
        }
    };

    function abbrWrap(old) {
        return function() {
            if (this._z) {
                return this._z.abbr(this);
            }
            return old.call(this);
        };
    }

    function resetZoneWrap(old) {
        return function() {
            this._z = null;
            return old.apply(this, arguments);
        };
    }
    fn.zoneName = abbrWrap(fn.zoneName);
    fn.zoneAbbr = abbrWrap(fn.zoneAbbr);
    fn.utc = resetZoneWrap(fn.utc);
    moment.tz.setDefault = function(name) {
        if (major < 2 || (major === 2 && minor < 9)) {
            logError('Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js ' + moment.version + '.');
        }
        moment.defaultZone = name ? getZone(name) : null;
        return moment;
    };
    var momentProperties = moment.momentProperties;
    if (Object.prototype.toString.call(momentProperties) === '[object Array]') {
        momentProperties.push('_z');
        momentProperties.push('_a');
    } else if (momentProperties) {
        momentProperties._z = null;
    }
    loadData({
        "version": "2015g",
        "zones": ["Africa/Abidjan|GMT|0|0|", "Africa/Addis_Ababa|EAT|-30|0|", "Africa/Algiers|CET|-10|0|", "Africa/Bangui|WAT|-10|0|", "Africa/Blantyre|CAT|-20|0|", "Africa/Cairo|EET EEST|-20 -30|010101010|1Cby0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0", "Africa/Casablanca|WET WEST|0 -10|01010101010101010101010101010101010101010|1Cco0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0", "Africa/Ceuta|CET CEST|-10 -20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Africa/Johannesburg|SAST|-20|0|", "Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00", "Africa/Windhoek|WAST WAT|-20 -10|01010101010101010101010|1C1c0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0", "America/Adak|HST HDT|a0 90|01010101010101010101010|1BR00 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1BQX0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Anguilla|AST|40|0|", "America/Araguaina|BRT BRST|30 20|010|1IdD0 Lz0", "America/Argentina/Buenos_Aires|ART|30|0|", "America/Asuncion|PYST PYT|30 40|01010101010101010101010|1C430 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0", "America/Atikokan|EST|50|0|", "America/Bahia|BRT BRST|30 20|010|1FJf0 Rb0", "America/Bahia_Banderas|MST CDT CST|70 50 60|01212121212121212121212|1C1l0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0", "America/Belem|BRT|30|0|", "America/Belize|CST|60|0|", "America/Boa_Vista|AMT|40|0|", "America/Bogota|COT|50|0|", "America/Boise|MST MDT|70 60|01010101010101010101010|1BQV0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Campo_Grande|AMST AMT|30 40|01010101010101010101010|1BIr0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10", "America/Cancun|CST CDT EST|60 50 50|010101010102|1C1k0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0", "America/Caracas|VET|4u|0|", "America/Cayenne|GFT|30|0|", "America/Cayman|EST EDT|50 40|01010101010|1Qtj0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Chicago|CST CDT|60 50|01010101010101010101010|1BQU0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Chihuahua|MST MDT|70 60|01010101010101010101010|1C1l0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0", "America/Creston|MST|70|0|", "America/Dawson|PST PDT|80 70|01010101010101010101010|1BQW0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Detroit|EST EDT|50 40|01010101010101010101010|1BQT0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Eirunepe|AMT ACT|40 50|01|1KLE0", "America/Fort_Nelson|PST PDT MST|80 70 70|010101010102|1BQW0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0", "America/Glace_Bay|AST ADT|40 30|01010101010101010101010|1BQS0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Godthab|WGT WGST|30 20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "America/Goose_Bay|AST ADT|40 30|01010101010101010101010|1BQQ1 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Grand_Turk|EST EDT AST|50 40 40|0101010101012|1BQT0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Guayaquil|ECT|50|0|", "America/Guyana|GYT|40|0|", "America/Havana|CST CDT|50 40|01010101010101010101010|1BQR0 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0", "America/La_Paz|BOT|40|0|", "America/Lima|PET|50|0|", "America/Merida|CST CDT|60 50|01010101010101010101010|1C1k0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0", "America/Metlakatla|PST|80|0|", "America/Miquelon|PMST PMDT|30 20|01010101010101010101010|1BQR0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Montevideo|UYST UYT|20 30|010101010101|1BQQ0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0", "America/Noronha|FNT|20|0|", "America/North_Dakota/Beulah|MST MDT CST CDT|70 60 60 50|01232323232323232323232|1BQV0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Paramaribo|SRT|30|0|", "America/Port-au-Prince|EST EDT|50 40|0101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Santa_Isabel|PST PDT|80 70|01010101010101010101010|1C1m0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0", "America/Santiago|CLST CLT CLT|30 40 30|010101010102|1C1f0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 1wn0", "America/Sao_Paulo|BRST BRT|20 30|01010101010101010101010|1BIq0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10", "America/Scoresbysund|EGT EGST|10 0|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1BQPv 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "Antarctica/Casey|CAST AWST|-b0 -80|0101|1BN30 40P0 KL0", "Antarctica/Davis|DAVT DAVT|-50 -70|0101|1BPw0 3Wn0 KN0", "Antarctica/DumontDUrville|DDUT|-a0|0|", "Antarctica/Macquarie|AEDT MIST|-b0 -b0|01|1C140", "Antarctica/Mawson|MAWT|-50|0|", "Antarctica/McMurdo|NZDT NZST|-d0 -c0|01010101010101010101010|1C120 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00", "Antarctica/Rothera|ROTT|30|0|", "Antarctica/Syowa|SYOT|-30|0|", "Antarctica/Troll|UTC CEST|0 -20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Antarctica/Vostok|VOST|-60|0|", "Asia/Aden|AST|-30|0|", "Asia/Almaty|ALMT|-60|0|", "Asia/Amman|EET EEST|-20 -30|010101010101010101010|1BVy0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0", "Asia/Anadyr|ANAT ANAST ANAT|-c0 -c0 -b0|0120|1BWe0 1qN0 WM0", "Asia/Aqtau|AQTT|-50|0|", "Asia/Ashgabat|TMT|-50|0|", "Asia/Baku|AZT AZST|-40 -50|01010101010101010101010|1BWo0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Asia/Bangkok|ICT|-70|0|", "Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1BWm0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0", "Asia/Bishkek|KGT|-60|0|", "Asia/Brunei|BNT|-80|0|", "Asia/Calcutta|IST|-5u|0|", "Asia/Chita|YAKT YAKST YAKT IRKT|-90 -a0 -a0 -80|01023|1BWh0 1qM0 WM0 8Hz0", "Asia/Choibalsan|CHOT CHOST|-80 -90|0101010101010|1O8G0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0", "Asia/Chongqing|CST|-80|0|", "Asia/Dacca|BDT|-60|0|", "Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1C0m0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0", "Asia/Dili|TLT|-90|0|", "Asia/Dubai|GST|-40|0|", "Asia/Dushanbe|TJT|-50|0|", "Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1BVW1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0", "Asia/Hebron|EET EEST|-20 -30|0101010101010101010101010|1BVy0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1210 1nz0 14N0 1nz0 1210 1nz0 1210 1nz0 1210 1nz0", "Asia/Hong_Kong|HKT|-80|0|", "Asia/Hovd|HOVT HOVST|-70 -80|0101010101010|1O8H0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0", "Asia/Irkutsk|IRKT IRKST IRKT|-80 -90 -90|01020|1BWi0 1qM0 WM0 8Hz0", "Asia/Istanbul|EET EEST|-20 -30|01010101010101010101010|1BWp0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Asia/Jakarta|WIB|-70|0|", "Asia/Jayapura|WIT|-90|0|", "Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1BVA0 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0", "Asia/Kabul|AFT|-4u|0|", "Asia/Kamchatka|PETT PETST PETT|-c0 -c0 -b0|0120|1BWe0 1qN0 WM0", "Asia/Karachi|PKT|-50|0|", "Asia/Kashgar|XJT|-60|0|", "Asia/Kathmandu|NPT|-5J|0|", "Asia/Khandyga|VLAT VLAST VLAT YAKT YAKT|-a0 -b0 -b0 -a0 -90|010234|1BWg0 1qM0 WM0 17V0 7zD0", "Asia/Krasnoyarsk|KRAT KRAST KRAT|-70 -80 -80|01020|1BWj0 1qM0 WM0 8Hz0", "Asia/Kuala_Lumpur|MYT|-80|0|", "Asia/Magadan|MAGT MAGST MAGT MAGT|-b0 -c0 -c0 -a0|01023|1BWf0 1qM0 WM0 8Hz0", "Asia/Makassar|WITA|-80|0|", "Asia/Manila|PHT|-80|0|", "Asia/Nicosia|EET EEST|-20 -30|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Asia/Novokuznetsk|KRAT NOVST NOVT NOVT|-70 -70 -60 -70|01230|1BWj0 1qN0 WM0 8Hz0", "Asia/Novosibirsk|NOVT NOVST NOVT|-60 -70 -70|01020|1BWk0 1qM0 WM0 8Hz0", "Asia/Omsk|OMST OMSST OMST|-60 -70 -70|01020|1BWk0 1qM0 WM0 8Hz0", "Asia/Oral|ORAT|-50|0|", "Asia/Pyongyang|KST KST|-90 -8u|01|1P4D0", "Asia/Qyzylorda|QYZT|-60|0|", "Asia/Rangoon|MMT|-6u|0|", "Asia/Sakhalin|SAKT SAKST SAKT|-a0 -b0 -b0|01020|1BWg0 1qM0 WM0 8Hz0", "Asia/Samarkand|UZT|-50|0|", "Asia/Seoul|KST|-90|0|", "Asia/Singapore|SGT|-80|0|", "Asia/Srednekolymsk|MAGT MAGST MAGT SRET|-b0 -c0 -c0 -b0|01023|1BWf0 1qM0 WM0 8Hz0", "Asia/Tbilisi|GET|-40|0|", "Asia/Tehran|IRST IRDT|-3u -4u|01010101010101010101010|1BTUu 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0", "Asia/Thimbu|BTT|-60|0|", "Asia/Tokyo|JST|-90|0|", "Asia/Ulaanbaatar|ULAT ULAST|-80 -90|0101010101010|1O8G0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0", "Asia/Ust-Nera|MAGT MAGST MAGT VLAT VLAT|-b0 -c0 -c0 -b0 -a0|010234|1BWf0 1qM0 WM0 17V0 7zD0", "Asia/Vladivostok|VLAT VLAST VLAT|-a0 -b0 -b0|01020|1BWg0 1qM0 WM0 8Hz0", "Asia/Yakutsk|YAKT YAKST YAKT|-90 -a0 -a0|01020|1BWh0 1qM0 WM0 8Hz0", "Asia/Yekaterinburg|YEKT YEKST YEKT|-50 -60 -60|01020|1BWl0 1qM0 WM0 8Hz0", "Asia/Yerevan|AMT AMST|-40 -50|01010|1BWm0 1qM0 WM0 1qM0", "Atlantic/Azores|AZOT AZOST|10 0|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Atlantic/Canary|WET WEST|0 -10|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Atlantic/Cape_Verde|CVT|10|0|", "Atlantic/South_Georgia|GST|20|0|", "Atlantic/Stanley|FKST FKT|30 40|010|1C6R0 U10", "Australia/ACT|AEDT AEST|-b0 -a0|01010101010101010101010|1C140 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0", "Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1C14u 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0", "Australia/Brisbane|AEST|-a0|0|", "Australia/Darwin|ACST|-9u|0|", "Australia/Eucla|ACWST|-8J|0|", "Australia/LHI|LHDT LHST|-b0 -au|01010101010101010101010|1C130 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu", "Australia/Perth|AWST|-80|0|", "Chile/EasterIsland|EASST EAST EAST|50 60 50|010101010102|1C1f0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 1wn0", "Eire|GMT IST|0 -10|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Etc/GMT+1|GMT+1|10|0|", "Etc/GMT+10|GMT+10|a0|0|", "Etc/GMT+11|GMT+11|b0|0|", "Etc/GMT+12|GMT+12|c0|0|", "Etc/GMT+2|GMT+2|20|0|", "Etc/GMT+3|GMT+3|30|0|", "Etc/GMT+4|GMT+4|40|0|", "Etc/GMT+5|GMT+5|50|0|", "Etc/GMT+6|GMT+6|60|0|", "Etc/GMT+7|GMT+7|70|0|", "Etc/GMT+8|GMT+8|80|0|", "Etc/GMT+9|GMT+9|90|0|", "Etc/GMT-1|GMT-1|-10|0|", "Etc/GMT-10|GMT-10|-a0|0|", "Etc/GMT-11|GMT-11|-b0|0|", "Etc/GMT-12|GMT-12|-c0|0|", "Etc/GMT-13|GMT-13|-d0|0|", "Etc/GMT-14|GMT-14|-e0|0|", "Etc/GMT-2|GMT-2|-20|0|", "Etc/GMT-3|GMT-3|-30|0|", "Etc/GMT-4|GMT-4|-40|0|", "Etc/GMT-5|GMT-5|-50|0|", "Etc/GMT-6|GMT-6|-60|0|", "Etc/GMT-7|GMT-7|-70|0|", "Etc/GMT-8|GMT-8|-80|0|", "Etc/GMT-9|GMT-9|-90|0|", "Etc/UCT|UCT|0|0|", "Etc/UTC|UTC|0|0|", "Europe/Belfast|GMT BST|0 -10|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1BWo0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Europe/Kaliningrad|EET EEST FET|-20 -30 -30|01020|1BWo0 1qM0 WM0 8Hz0", "Europe/Minsk|EET EEST FET MSK|-20 -30 -30 -30|01023|1BWo0 1qM0 WM0 8Hy0", "Europe/Moscow|MSK MSD MSK|-30 -40 -40|01020|1BWn0 1qM0 WM0 8Hz0", "Europe/Samara|SAMT SAMST SAMT|-40 -40 -30|0120|1BWm0 1qN0 WM0", "Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|01010101023|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0", "HST|HST|a0|0|", "Indian/Chagos|IOT|-60|0|", "Indian/Christmas|CXT|-70|0|", "Indian/Cocos|CCT|-6u|0|", "Indian/Kerguelen|TFT|-50|0|", "Indian/Mahe|SCT|-40|0|", "Indian/Maldives|MVT|-50|0|", "Indian/Mauritius|MUT|-40|0|", "Indian/Reunion|RET|-40|0|", "Kwajalein|MHT|-c0|0|", "MET|MET MEST|-10 -20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "NZ-CHAT|CHADT CHAST|-dJ -cJ|01010101010101010101010|1C120 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00", "Pacific/Apia|SST SDT WSDT WSST|b0 a0 -e0 -d0|01012323232323232323232|1Dbn0 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00", "Pacific/Bougainville|PGT BST|-a0 -b0|01|1NwE0", "Pacific/Chuuk|CHUT|-a0|0|", "Pacific/Efate|VUT|-b0|0|", "Pacific/Enderbury|PHOT|-d0|0|", "Pacific/Fakaofo|TKT TKT|b0 -d0|01|1Gfn0", "Pacific/Fiji|FJST FJT|-d0 -c0|01010101010101010101010|1BWe0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0", "Pacific/Funafuti|TVT|-c0|0|", "Pacific/Galapagos|GALT|60|0|", "Pacific/Gambier|GAMT|90|0|", "Pacific/Guadalcanal|SBT|-b0|0|", "Pacific/Guam|ChST|-a0|0|", "Pacific/Kiritimati|LINT|-e0|0|", "Pacific/Kosrae|KOST|-b0|0|", "Pacific/Marquesas|MART|9u|0|", "Pacific/Midway|SST|b0|0|", "Pacific/Nauru|NRT|-c0|0|", "Pacific/Niue|NUT|b0|0|", "Pacific/Norfolk|NFT NFT|-bu -b0|01|1PoCu", "Pacific/Noumea|NCT|-b0|0|", "Pacific/Palau|PWT|-90|0|", "Pacific/Pohnpei|PONT|-b0|0|", "Pacific/Port_Moresby|PGT|-a0|0|", "Pacific/Rarotonga|CKT|a0|0|", "Pacific/Tahiti|TAHT|a0|0|", "Pacific/Tarawa|GILT|-c0|0|", "Pacific/Tongatapu|TOT|-d0|0|", "Pacific/Wake|WAKT|-c0|0|", "Pacific/Wallis|WFT|-c0|0|"],
        "links": ["Africa/Abidjan|Africa/Accra", "Africa/Abidjan|Africa/Bamako", "Africa/Abidjan|Africa/Banjul", "Africa/Abidjan|Africa/Bissau", "Africa/Abidjan|Africa/Conakry", "Africa/Abidjan|Africa/Dakar", "Africa/Abidjan|Africa/Freetown", "Africa/Abidjan|Africa/Lome", "Africa/Abidjan|Africa/Monrovia", "Africa/Abidjan|Africa/Nouakchott", "Africa/Abidjan|Africa/Ouagadougou", "Africa/Abidjan|Africa/Sao_Tome", "Africa/Abidjan|Africa/Timbuktu", "Africa/Abidjan|America/Danmarkshavn", "Africa/Abidjan|Atlantic/Reykjavik", "Africa/Abidjan|Atlantic/St_Helena", "Africa/Abidjan|Etc/GMT", "Africa/Abidjan|Etc/GMT+0", "Africa/Abidjan|Etc/GMT-0", "Africa/Abidjan|Etc/GMT0", "Africa/Abidjan|Etc/Greenwich", "Africa/Abidjan|GMT", "Africa/Abidjan|GMT+0", "Africa/Abidjan|GMT-0", "Africa/Abidjan|GMT0", "Africa/Abidjan|Greenwich", "Africa/Abidjan|Iceland", "Africa/Addis_Ababa|Africa/Asmara", "Africa/Addis_Ababa|Africa/Asmera", "Africa/Addis_Ababa|Africa/Dar_es_Salaam", "Africa/Addis_Ababa|Africa/Djibouti", "Africa/Addis_Ababa|Africa/Juba", "Africa/Addis_Ababa|Africa/Kampala", "Africa/Addis_Ababa|Africa/Khartoum", "Africa/Addis_Ababa|Africa/Mogadishu", "Africa/Addis_Ababa|Africa/Nairobi", "Africa/Addis_Ababa|Indian/Antananarivo", "Africa/Addis_Ababa|Indian/Comoro", "Africa/Addis_Ababa|Indian/Mayotte", "Africa/Algiers|Africa/Tunis", "Africa/Bangui|Africa/Brazzaville", "Africa/Bangui|Africa/Douala", "Africa/Bangui|Africa/Kinshasa", "Africa/Bangui|Africa/Lagos", "Africa/Bangui|Africa/Libreville", "Africa/Bangui|Africa/Luanda", "Africa/Bangui|Africa/Malabo", "Africa/Bangui|Africa/Ndjamena", "Africa/Bangui|Africa/Niamey", "Africa/Bangui|Africa/Porto-Novo", "Africa/Blantyre|Africa/Bujumbura", "Africa/Blantyre|Africa/Gaborone", "Africa/Blantyre|Africa/Harare", "Africa/Blantyre|Africa/Kigali", "Africa/Blantyre|Africa/Lubumbashi", "Africa/Blantyre|Africa/Lusaka", "Africa/Blantyre|Africa/Maputo", "Africa/Cairo|Egypt", "Africa/Casablanca|Africa/El_Aaiun", "Africa/Ceuta|Arctic/Longyearbyen", "Africa/Ceuta|Atlantic/Jan_Mayen", "Africa/Ceuta|CET", "Africa/Ceuta|Europe/Amsterdam", "Africa/Ceuta|Europe/Andorra", "Africa/Ceuta|Europe/Belgrade", "Africa/Ceuta|Europe/Berlin", "Africa/Ceuta|Europe/Bratislava", "Africa/Ceuta|Europe/Brussels", "Africa/Ceuta|Europe/Budapest", "Africa/Ceuta|Europe/Busingen", "Africa/Ceuta|Europe/Copenhagen", "Africa/Ceuta|Europe/Gibraltar", "Africa/Ceuta|Europe/Ljubljana", "Africa/Ceuta|Europe/Luxembourg", "Africa/Ceuta|Europe/Madrid", "Africa/Ceuta|Europe/Malta", "Africa/Ceuta|Europe/Monaco", "Africa/Ceuta|Europe/Oslo", "Africa/Ceuta|Europe/Paris", "Africa/Ceuta|Europe/Podgorica", "Africa/Ceuta|Europe/Prague", "Africa/Ceuta|Europe/Rome", "Africa/Ceuta|Europe/San_Marino", "Africa/Ceuta|Europe/Sarajevo", "Africa/Ceuta|Europe/Skopje", "Africa/Ceuta|Europe/Stockholm", "Africa/Ceuta|Europe/Tirane", "Africa/Ceuta|Europe/Vaduz", "Africa/Ceuta|Europe/Vatican", "Africa/Ceuta|Europe/Vienna", "Africa/Ceuta|Europe/Warsaw", "Africa/Ceuta|Europe/Zagreb", "Africa/Ceuta|Europe/Zurich", "Africa/Ceuta|Poland", "Africa/Johannesburg|Africa/Maseru", "Africa/Johannesburg|Africa/Mbabane", "Africa/Tripoli|Libya", "America/Adak|America/Atka", "America/Adak|US/Aleutian", "America/Anchorage|America/Juneau", "America/Anchorage|America/Nome", "America/Anchorage|America/Sitka", "America/Anchorage|America/Yakutat", "America/Anchorage|US/Alaska", "America/Anguilla|America/Antigua", "America/Anguilla|America/Aruba", "America/Anguilla|America/Barbados", "America/Anguilla|America/Blanc-Sablon", "America/Anguilla|America/Curacao", "America/Anguilla|America/Dominica", "America/Anguilla|America/Grenada", "America/Anguilla|America/Guadeloupe", "America/Anguilla|America/Kralendijk", "America/Anguilla|America/Lower_Princes", "America/Anguilla|America/Marigot", "America/Anguilla|America/Martinique", "America/Anguilla|America/Montserrat", "America/Anguilla|America/Port_of_Spain", "America/Anguilla|America/Puerto_Rico", "America/Anguilla|America/Santo_Domingo", "America/Anguilla|America/St_Barthelemy", "America/Anguilla|America/St_Kitts", "America/Anguilla|America/St_Lucia", "America/Anguilla|America/St_Thomas", "America/Anguilla|America/St_Vincent", "America/Anguilla|America/Tortola", "America/Anguilla|America/Virgin", "America/Argentina/Buenos_Aires|America/Argentina/Catamarca", "America/Argentina/Buenos_Aires|America/Argentina/ComodRivadavia", "America/Argentina/Buenos_Aires|America/Argentina/Cordoba", "America/Argentina/Buenos_Aires|America/Argentina/Jujuy", "America/Argentina/Buenos_Aires|America/Argentina/La_Rioja", "America/Argentina/Buenos_Aires|America/Argentina/Mendoza", "America/Argentina/Buenos_Aires|America/Argentina/Rio_Gallegos", "America/Argentina/Buenos_Aires|America/Argentina/Salta", "America/Argentina/Buenos_Aires|America/Argentina/San_Juan", "America/Argentina/Buenos_Aires|America/Argentina/San_Luis", "America/Argentina/Buenos_Aires|America/Argentina/Tucuman", "America/Argentina/Buenos_Aires|America/Argentina/Ushuaia", "America/Argentina/Buenos_Aires|America/Buenos_Aires", "America/Argentina/Buenos_Aires|America/Catamarca", "America/Argentina/Buenos_Aires|America/Cordoba", "America/Argentina/Buenos_Aires|America/Jujuy", "America/Argentina/Buenos_Aires|America/Mendoza", "America/Argentina/Buenos_Aires|America/Rosario", "America/Atikokan|America/Coral_Harbour", "America/Atikokan|America/Jamaica", "America/Atikokan|America/Panama", "America/Atikokan|EST", "America/Atikokan|Jamaica", "America/Belem|America/Fortaleza", "America/Belem|America/Maceio", "America/Belem|America/Recife", "America/Belem|America/Santarem", "America/Belize|America/Costa_Rica", "America/Belize|America/El_Salvador", "America/Belize|America/Guatemala", "America/Belize|America/Managua", "America/Belize|America/Regina", "America/Belize|America/Swift_Current", "America/Belize|America/Tegucigalpa", "America/Belize|Canada/East-Saskatchewan", "America/Belize|Canada/Saskatchewan", "America/Boa_Vista|America/Manaus", "America/Boa_Vista|America/Porto_Velho", "America/Boa_Vista|Brazil/West", "America/Boise|America/Cambridge_Bay", "America/Boise|America/Denver", "America/Boise|America/Edmonton", "America/Boise|America/Inuvik", "America/Boise|America/Ojinaga", "America/Boise|America/Shiprock", "America/Boise|America/Yellowknife", "America/Boise|Canada/Mountain", "America/Boise|MST7MDT", "America/Boise|Navajo", "America/Boise|US/Mountain", "America/Campo_Grande|America/Cuiaba", "America/Chicago|America/Indiana/Knox", "America/Chicago|America/Indiana/Tell_City", "America/Chicago|America/Knox_IN", "America/Chicago|America/Matamoros", "America/Chicago|America/Menominee", "America/Chicago|America/North_Dakota/Center", "America/Chicago|America/North_Dakota/New_Salem", "America/Chicago|America/Rainy_River", "America/Chicago|America/Rankin_Inlet", "America/Chicago|America/Resolute", "America/Chicago|America/Winnipeg", "America/Chicago|CST6CDT", "America/Chicago|Canada/Central", "America/Chicago|US/Central", "America/Chicago|US/Indiana-Starke", "America/Chihuahua|America/Mazatlan", "America/Chihuahua|Mexico/BajaSur", "America/Creston|America/Dawson_Creek", "America/Creston|America/Hermosillo", "America/Creston|America/Phoenix", "America/Creston|MST", "America/Creston|US/Arizona", "America/Dawson|America/Ensenada", "America/Dawson|America/Los_Angeles", "America/Dawson|America/Tijuana", "America/Dawson|America/Vancouver", "America/Dawson|America/Whitehorse", "America/Dawson|Canada/Pacific", "America/Dawson|Canada/Yukon", "America/Dawson|Mexico/BajaNorte", "America/Dawson|PST8PDT", "America/Dawson|US/Pacific", "America/Dawson|US/Pacific-New", "America/Detroit|America/Fort_Wayne", "America/Detroit|America/Indiana/Indianapolis", "America/Detroit|America/Indiana/Marengo", "America/Detroit|America/Indiana/Petersburg", "America/Detroit|America/Indiana/Vevay", "America/Detroit|America/Indiana/Vincennes", "America/Detroit|America/Indiana/Winamac", "America/Detroit|America/Indianapolis", "America/Detroit|America/Iqaluit", "America/Detroit|America/Kentucky/Louisville", "America/Detroit|America/Kentucky/Monticello", "America/Detroit|America/Louisville", "America/Detroit|America/Montreal", "America/Detroit|America/Nassau", "America/Detroit|America/New_York", "America/Detroit|America/Nipigon", "America/Detroit|America/Pangnirtung", "America/Detroit|America/Thunder_Bay", "America/Detroit|America/Toronto", "America/Detroit|Canada/Eastern", "America/Detroit|EST5EDT", "America/Detroit|US/East-Indiana", "America/Detroit|US/Eastern", "America/Detroit|US/Michigan", "America/Eirunepe|America/Porto_Acre", "America/Eirunepe|America/Rio_Branco", "America/Eirunepe|Brazil/Acre", "America/Glace_Bay|America/Halifax", "America/Glace_Bay|America/Moncton", "America/Glace_Bay|America/Thule", "America/Glace_Bay|Atlantic/Bermuda", "America/Glace_Bay|Canada/Atlantic", "America/Havana|Cuba", "America/Merida|America/Mexico_City", "America/Merida|America/Monterrey", "America/Merida|Mexico/General", "America/Metlakatla|Pacific/Pitcairn", "America/Noronha|Brazil/DeNoronha", "America/Santiago|Antarctica/Palmer", "America/Santiago|Chile/Continental", "America/Sao_Paulo|Brazil/East", "America/St_Johns|Canada/Newfoundland", "Antarctica/McMurdo|Antarctica/South_Pole", "Antarctica/McMurdo|NZ", "Antarctica/McMurdo|Pacific/Auckland", "Asia/Aden|Asia/Baghdad", "Asia/Aden|Asia/Bahrain", "Asia/Aden|Asia/Kuwait", "Asia/Aden|Asia/Qatar", "Asia/Aden|Asia/Riyadh", "Asia/Aqtau|Asia/Aqtobe", "Asia/Ashgabat|Asia/Ashkhabad", "Asia/Bangkok|Asia/Ho_Chi_Minh", "Asia/Bangkok|Asia/Phnom_Penh", "Asia/Bangkok|Asia/Saigon", "Asia/Bangkok|Asia/Vientiane", "Asia/Calcutta|Asia/Colombo", "Asia/Calcutta|Asia/Kolkata", "Asia/Chongqing|Asia/Chungking", "Asia/Chongqing|Asia/Harbin", "Asia/Chongqing|Asia/Macao", "Asia/Chongqing|Asia/Macau", "Asia/Chongqing|Asia/Shanghai", "Asia/Chongqing|Asia/Taipei", "Asia/Chongqing|PRC", "Asia/Chongqing|ROC", "Asia/Dacca|Asia/Dhaka", "Asia/Dubai|Asia/Muscat", "Asia/Hong_Kong|Hongkong", "Asia/Istanbul|Europe/Istanbul", "Asia/Istanbul|Turkey", "Asia/Jakarta|Asia/Pontianak", "Asia/Jerusalem|Asia/Tel_Aviv", "Asia/Jerusalem|Israel", "Asia/Kashgar|Asia/Urumqi", "Asia/Kathmandu|Asia/Katmandu", "Asia/Kuala_Lumpur|Asia/Kuching", "Asia/Makassar|Asia/Ujung_Pandang", "Asia/Nicosia|EET", "Asia/Nicosia|Europe/Athens", "Asia/Nicosia|Europe/Bucharest", "Asia/Nicosia|Europe/Helsinki", "Asia/Nicosia|Europe/Kiev", "Asia/Nicosia|Europe/Mariehamn", "Asia/Nicosia|Europe/Nicosia", "Asia/Nicosia|Europe/Riga", "Asia/Nicosia|Europe/Sofia", "Asia/Nicosia|Europe/Tallinn", "Asia/Nicosia|Europe/Uzhgorod", "Asia/Nicosia|Europe/Vilnius", "Asia/Nicosia|Europe/Zaporozhye", "Asia/Samarkand|Asia/Tashkent", "Asia/Seoul|ROK", "Asia/Singapore|Singapore", "Asia/Tehran|Iran", "Asia/Thimbu|Asia/Thimphu", "Asia/Tokyo|Japan", "Asia/Ulaanbaatar|Asia/Ulan_Bator", "Atlantic/Canary|Atlantic/Faeroe", "Atlantic/Canary|Atlantic/Faroe", "Atlantic/Canary|Atlantic/Madeira", "Atlantic/Canary|Europe/Lisbon", "Atlantic/Canary|Portugal", "Atlantic/Canary|WET", "Australia/ACT|Australia/Canberra", "Australia/ACT|Australia/Currie", "Australia/ACT|Australia/Hobart", "Australia/ACT|Australia/Melbourne", "Australia/ACT|Australia/NSW", "Australia/ACT|Australia/Sydney", "Australia/ACT|Australia/Tasmania", "Australia/ACT|Australia/Victoria", "Australia/Adelaide|Australia/Broken_Hill", "Australia/Adelaide|Australia/South", "Australia/Adelaide|Australia/Yancowinna", "Australia/Brisbane|Australia/Lindeman", "Australia/Brisbane|Australia/Queensland", "Australia/Darwin|Australia/North", "Australia/LHI|Australia/Lord_Howe", "Australia/Perth|Australia/West", "Chile/EasterIsland|Pacific/Easter", "Eire|Europe/Dublin", "Etc/UCT|UCT", "Etc/UTC|Etc/Universal", "Etc/UTC|Etc/Zulu", "Etc/UTC|UTC", "Etc/UTC|Universal", "Etc/UTC|Zulu", "Europe/Belfast|Europe/Guernsey", "Europe/Belfast|Europe/Isle_of_Man", "Europe/Belfast|Europe/Jersey", "Europe/Belfast|Europe/London", "Europe/Belfast|GB", "Europe/Belfast|GB-Eire", "Europe/Chisinau|Europe/Tiraspol", "Europe/Moscow|Europe/Volgograd", "Europe/Moscow|W-SU", "HST|Pacific/Honolulu", "HST|Pacific/Johnston", "HST|US/Hawaii", "Kwajalein|Pacific/Kwajalein", "Kwajalein|Pacific/Majuro", "NZ-CHAT|Pacific/Chatham", "Pacific/Chuuk|Pacific/Truk", "Pacific/Chuuk|Pacific/Yap", "Pacific/Guam|Pacific/Saipan", "Pacific/Midway|Pacific/Pago_Pago", "Pacific/Midway|Pacific/Samoa", "Pacific/Midway|US/Samoa", "Pacific/Pohnpei|Pacific/Ponape"]
    });
    return moment;
}));
(function(window, document, undefined) {
    'use strict';
    var ie10plus = window.navigator.msPointerEnabled;

    function Flow(opts) {
        this.support = (typeof File !== 'undefined' && typeof Blob !== 'undefined' && typeof FileList !== 'undefined' && (!!Blob.prototype.slice || !!Blob.prototype.webkitSlice || !!Blob.prototype.mozSlice || false));
        if (!this.support) {
            return;
        }
        this.supportDirectory = /WebKit/.test(window.navigator.userAgent);
        this.files = [];
        this.defaults = {
            chunkSize: 1024 * 1024,
            forceChunkSize: false,
            simultaneousUploads: 3,
            singleFile: false,
            fileParameterName: 'file',
            progressCallbacksInterval: 500,
            speedSmoothingFactor: 0.1,
            query: {},
            headers: {},
            withCredentials: false,
            preprocess: null,
            method: 'multipart',
            testMethod: 'GET',
            uploadMethod: 'POST',
            prioritizeFirstAndLastChunk: false,
            target: '/',
            testChunks: true,
            generateUniqueIdentifier: null,
            maxChunkRetries: 0,
            chunkRetryInterval: null,
            permanentErrors: [404, 415, 500, 501],
            successStatuses: [200, 201, 202],
            onDropStopPropagation: false
        };
        this.opts = {};
        this.events = {};
        var $ = this;
        this.onDrop = function(event) {
            if ($.opts.onDropStopPropagation) {
                event.stopPropagation();
            }
            event.preventDefault();
            var dataTransfer = event.dataTransfer;
            if (dataTransfer.items && dataTransfer.items[0] && dataTransfer.items[0].webkitGetAsEntry) {
                $.webkitReadDataTransfer(event);
            } else {
                $.addFiles(dataTransfer.files, event);
            }
        };
        this.preventEvent = function(event) {
            event.preventDefault();
        };
        this.opts = Flow.extend({}, this.defaults, opts || {});
    }
    Flow.prototype = {
        on: function(event, callback) {
            event = event.toLowerCase();
            if (!this.events.hasOwnProperty(event)) {
                this.events[event] = [];
            }
            this.events[event].push(callback);
        },
        off: function(event, fn) {
            if (event !== undefined) {
                event = event.toLowerCase();
                if (fn !== undefined) {
                    if (this.events.hasOwnProperty(event)) {
                        arrayRemove(this.events[event], fn);
                    }
                } else {
                    delete this.events[event];
                }
            } else {
                this.events = {};
            }
        },
        fire: function(event, args) {
            args = Array.prototype.slice.call(arguments);
            event = event.toLowerCase();
            var preventDefault = false;
            if (this.events.hasOwnProperty(event)) {
                each(this.events[event], function(callback) {
                    preventDefault = callback.apply(this, args.slice(1)) === false || preventDefault;
                }, this);
            }
            if (event != 'catchall') {
                args.unshift('catchAll');
                preventDefault = this.fire.apply(this, args) === false || preventDefault;
            }
            return !preventDefault;
        },
        webkitReadDataTransfer: function(event) {
            var $ = this;
            var queue = event.dataTransfer.items.length;
            var files = [];
            each(event.dataTransfer.items, function(item) {
                var entry = item.webkitGetAsEntry();
                if (!entry) {
                    decrement();
                    return;
                }
                if (entry.isFile) {
                    fileReadSuccess(item.getAsFile(), entry.fullPath);
                } else {
                    entry.createReader().readEntries(readSuccess, readError);
                }
            });

            function readSuccess(entries) {
                queue += entries.length;
                each(entries, function(entry) {
                    if (entry.isFile) {
                        var fullPath = entry.fullPath;
                        entry.file(function(file) {
                            fileReadSuccess(file, fullPath);
                        }, readError);
                    } else if (entry.isDirectory) {
                        entry.createReader().readEntries(readSuccess, readError);
                    }
                });
                decrement();
            }

            function fileReadSuccess(file, fullPath) {
                file.relativePath = fullPath.substring(1);
                files.push(file);
                decrement();
            }

            function readError(fileError) {
                throw fileError;
            }

            function decrement() {
                if (--queue == 0) {
                    $.addFiles(files, event);
                }
            }
        },
        generateUniqueIdentifier: function(file) {
            var custom = this.opts.generateUniqueIdentifier;
            if (typeof custom === 'function') {
                return custom(file);
            }
            var relativePath = file.relativePath || file.webkitRelativePath || file.fileName || file.name;
            return file.size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, '');
        },
        uploadNextChunk: function(preventEvents) {
            var found = false;
            if (this.opts.prioritizeFirstAndLastChunk) {
                each(this.files, function(file) {
                    if (!file.paused && file.chunks.length && file.chunks[0].status() === 'pending' && file.chunks[0].preprocessState === 0) {
                        file.chunks[0].send();
                        found = true;
                        return false;
                    }
                    if (!file.paused && file.chunks.length > 1 && file.chunks[file.chunks.length - 1].status() === 'pending' && file.chunks[0].preprocessState === 0) {
                        file.chunks[file.chunks.length - 1].send();
                        found = true;
                        return false;
                    }
                });
                if (found) {
                    return found;
                }
            }
            each(this.files, function(file) {
                if (!file.paused) {
                    each(file.chunks, function(chunk) {
                        if (chunk.status() === 'pending' && chunk.preprocessState === 0) {
                            chunk.send();
                            found = true;
                            return false;
                        }
                    });
                }
                if (found) {
                    return false;
                }
            });
            if (found) {
                return true;
            }
            var outstanding = false;
            each(this.files, function(file) {
                if (!file.isComplete()) {
                    outstanding = true;
                    return false;
                }
            });
            if (!outstanding && !preventEvents) {
                async (function() {
                    this.fire('complete');
                }, this);
            }
            return false;
        },
        assignBrowse: function(domNodes, isDirectory, singleFile, attributes) {
            if (typeof domNodes.length === 'undefined') {
                domNodes = [domNodes];
            }
            each(domNodes, function(domNode) {
                var input;
                if (domNode.tagName === 'INPUT' && domNode.type === 'file') {
                    input = domNode;
                } else {
                    input = document.createElement('input');
                    input.setAttribute('type', 'file');
                    extend(input.style, {
                        visibility: 'hidden',
                        position: 'absolute'
                    });
                    domNode.appendChild(input);
                    domNode.addEventListener('click', function() {
                        input.click();
                    }, false);
                }
                if (!this.opts.singleFile && !singleFile) {
                    input.setAttribute('multiple', 'multiple');
                }
                if (isDirectory) {
                    input.setAttribute('webkitdirectory', 'webkitdirectory');
                }
                each(attributes, function(value, key) {
                    input.setAttribute(key, value);
                });
                var $ = this;
                input.addEventListener('change', function(e) {
                    $.addFiles(e.target.files, e);
                    e.target.value = '';
                }, false);
            }, this);
        },
        assignDrop: function(domNodes) {
            if (typeof domNodes.length === 'undefined') {
                domNodes = [domNodes];
            }
            each(domNodes, function(domNode) {
                domNode.addEventListener('dragover', this.preventEvent, false);
                domNode.addEventListener('dragenter', this.preventEvent, false);
                domNode.addEventListener('drop', this.onDrop, false);
            }, this);
        },
        unAssignDrop: function(domNodes) {
            if (typeof domNodes.length === 'undefined') {
                domNodes = [domNodes];
            }
            each(domNodes, function(domNode) {
                domNode.removeEventListener('dragover', this.preventEvent);
                domNode.removeEventListener('dragenter', this.preventEvent);
                domNode.removeEventListener('drop', this.onDrop);
            }, this);
        },
        isUploading: function() {
            var uploading = false;
            each(this.files, function(file) {
                if (file.isUploading()) {
                    uploading = true;
                    return false;
                }
            });
            return uploading;
        },
        _shouldUploadNext: function() {
            var num = 0;
            var should = true;
            var simultaneousUploads = this.opts.simultaneousUploads;
            each(this.files, function(file) {
                each(file.chunks, function(chunk) {
                    if (chunk.status() === 'uploading') {
                        num++;
                        if (num >= simultaneousUploads) {
                            should = false;
                            return false;
                        }
                    }
                });
            });
            return should && num;
        },
        upload: function() {
            var ret = this._shouldUploadNext();
            if (ret === false) {
                return;
            }
            this.fire('uploadStart');
            var started = false;
            for (var num = 1; num <= this.opts.simultaneousUploads - ret; num++) {
                started = this.uploadNextChunk(true) || started;
            }
            if (!started) {
                async (function() {
                    this.fire('complete');
                }, this);
            }
        },
        resume: function() {
            each(this.files, function(file) {
                file.resume();
            });
        },
        pause: function() {
            each(this.files, function(file) {
                file.pause();
            });
        },
        cancel: function() {
            for (var i = this.files.length - 1; i >= 0; i--) {
                this.files[i].cancel();
            }
        },
        progress: function() {
            var totalDone = 0;
            var totalSize = 0;
            each(this.files, function(file) {
                totalDone += file.progress() * file.size;
                totalSize += file.size;
            });
            return totalSize > 0 ? totalDone / totalSize : 0;
        },
        addFile: function(file, event) {
            this.addFiles([file], event);
        },
        addFiles: function(fileList, event) {
            var files = [];
            each(fileList, function(file) {
                if ((!ie10plus || ie10plus && file.size > 0) && !(file.size % 4096 === 0 && (file.name === '.' || file.fileName === '.')) && !this.getFromUniqueIdentifier(this.generateUniqueIdentifier(file))) {
                    var f = new FlowFile(this, file);
                    if (this.fire('fileAdded', f, event)) {
                        files.push(f);
                    }
                }
            }, this);
            if (this.fire('filesAdded', files, event)) {
                each(files, function(file) {
                    if (this.opts.singleFile && this.files.length > 0) {
                        this.removeFile(this.files[0]);
                    }
                    this.files.push(file);
                }, this);
            }
            this.fire('filesSubmitted', files, event);
        },
        removeFile: function(file) {
            for (var i = this.files.length - 1; i >= 0; i--) {
                if (this.files[i] === file) {
                    this.files.splice(i, 1);
                    file.abort();
                }
            }
        },
        getFromUniqueIdentifier: function(uniqueIdentifier) {
            var ret = false;
            each(this.files, function(file) {
                if (file.uniqueIdentifier === uniqueIdentifier) {
                    ret = file;
                }
            });
            return ret;
        },
        getSize: function() {
            var totalSize = 0;
            each(this.files, function(file) {
                totalSize += file.size;
            });
            return totalSize;
        },
        sizeUploaded: function() {
            var size = 0;
            each(this.files, function(file) {
                size += file.sizeUploaded();
            });
            return size;
        },
        timeRemaining: function() {
            var sizeDelta = 0;
            var averageSpeed = 0;
            each(this.files, function(file) {
                if (!file.paused && !file.error) {
                    sizeDelta += file.size - file.sizeUploaded();
                    averageSpeed += file.averageSpeed;
                }
            });
            if (sizeDelta && !averageSpeed) {
                return Number.POSITIVE_INFINITY;
            }
            if (!sizeDelta && !averageSpeed) {
                return 0;
            }
            return Math.floor(sizeDelta / averageSpeed);
        }
    };

    function FlowFile(flowObj, file) {
        this.flowObj = flowObj;
        this.file = file;
        this.name = file.fileName || file.name;
        this.size = file.size;
        this.relativePath = file.relativePath || file.webkitRelativePath || this.name;
        this.uniqueIdentifier = flowObj.generateUniqueIdentifier(file);
        this.chunks = [];
        this.paused = false;
        this.error = false;
        this.averageSpeed = 0;
        this.currentSpeed = 0;
        this._lastProgressCallback = Date.now();
        this._prevUploadedSize = 0;
        this._prevProgress = 0;
        this.bootstrap();
    }
    FlowFile.prototype = {
        measureSpeed: function() {
            var timeSpan = Date.now() - this._lastProgressCallback;
            if (!timeSpan) {
                return;
            }
            var smoothingFactor = this.flowObj.opts.speedSmoothingFactor;
            var uploaded = this.sizeUploaded();
            this.currentSpeed = Math.max((uploaded - this._prevUploadedSize) / timeSpan * 1000, 0);
            this.averageSpeed = smoothingFactor * this.currentSpeed + (1 - smoothingFactor) * this.averageSpeed;
            this._prevUploadedSize = uploaded;
        },
        chunkEvent: function(chunk, event, message) {
            switch (event) {
                case 'progress':
                    if (Date.now() - this._lastProgressCallback < this.flowObj.opts.progressCallbacksInterval) {
                        break;
                    }
                    this.measureSpeed();
                    this.flowObj.fire('fileProgress', this, chunk);
                    this.flowObj.fire('progress');
                    this._lastProgressCallback = Date.now();
                    break;
                case 'error':
                    this.error = true;
                    this.abort(true);
                    this.flowObj.fire('fileError', this, message, chunk);
                    this.flowObj.fire('error', message, this, chunk);
                    break;
                case 'success':
                    if (this.error) {
                        return;
                    }
                    this.measureSpeed();
                    this.flowObj.fire('fileProgress', this, chunk);
                    this.flowObj.fire('progress');
                    this._lastProgressCallback = Date.now();
                    if (this.isComplete()) {
                        this.currentSpeed = 0;
                        this.averageSpeed = 0;
                        this.flowObj.fire('fileSuccess', this, message, chunk);
                    }
                    break;
                case 'retry':
                    this.flowObj.fire('fileRetry', this, chunk);
                    break;
            }
        },
        pause: function() {
            this.paused = true;
            this.abort();
        },
        resume: function() {
            this.paused = false;
            this.flowObj.upload();
        },
        abort: function(reset) {
            this.currentSpeed = 0;
            this.averageSpeed = 0;
            var chunks = this.chunks;
            if (reset) {
                this.chunks = [];
            }
            each(chunks, function(c) {
                if (c.status() === 'uploading') {
                    c.abort();
                    this.flowObj.uploadNextChunk();
                }
            }, this);
        },
        cancel: function() {
            this.flowObj.removeFile(this);
        },
        retry: function() {
            this.bootstrap();
            this.flowObj.upload();
        },
        bootstrap: function() {
            this.abort(true);
            this.error = false;
            this._prevProgress = 0;
            var round = this.flowObj.opts.forceChunkSize ? Math.ceil : Math.floor;
            var chunks = Math.max(round(this.file.size / this.flowObj.opts.chunkSize), 1);
            for (var offset = 0; offset < chunks; offset++) {
                this.chunks.push(new FlowChunk(this.flowObj, this, offset));
            }
        },
        progress: function() {
            if (this.error) {
                return 1;
            }
            if (this.chunks.length === 1) {
                this._prevProgress = Math.max(this._prevProgress, this.chunks[0].progress());
                return this._prevProgress;
            }
            var bytesLoaded = 0;
            each(this.chunks, function(c) {
                bytesLoaded += c.progress() * (c.endByte - c.startByte);
            });
            var percent = bytesLoaded / this.size;
            this._prevProgress = Math.max(this._prevProgress, percent > 0.9999 ? 1 : percent);
            return this._prevProgress;
        },
        isUploading: function() {
            var uploading = false;
            each(this.chunks, function(chunk) {
                if (chunk.status() === 'uploading') {
                    uploading = true;
                    return false;
                }
            });
            return uploading;
        },
        isComplete: function() {
            var outstanding = false;
            each(this.chunks, function(chunk) {
                var status = chunk.status();
                if (status === 'pending' || status === 'uploading' || chunk.preprocessState === 1) {
                    outstanding = true;
                    return false;
                }
            });
            return !outstanding;
        },
        sizeUploaded: function() {
            var size = 0;
            each(this.chunks, function(chunk) {
                size += chunk.sizeUploaded();
            });
            return size;
        },
        timeRemaining: function() {
            if (this.paused || this.error) {
                return 0;
            }
            var delta = this.size - this.sizeUploaded();
            if (delta && !this.averageSpeed) {
                return Number.POSITIVE_INFINITY;
            }
            if (!delta && !this.averageSpeed) {
                return 0;
            }
            return Math.floor(delta / this.averageSpeed);
        },
        getType: function() {
            return this.file.type && this.file.type.split('/')[1];
        },
        getExtension: function() {
            return this.name.substr((~-this.name.lastIndexOf(".") >>> 0) + 2).toLowerCase();
        }
    };

    function FlowChunk(flowObj, fileObj, offset) {
        this.flowObj = flowObj;
        this.fileObj = fileObj;
        this.fileObjSize = fileObj.size;
        this.offset = offset;
        this.tested = false;
        this.retries = 0;
        this.pendingRetry = false;
        this.preprocessState = 0;
        this.loaded = 0;
        this.total = 0;
        var chunkSize = this.flowObj.opts.chunkSize;
        this.startByte = this.offset * chunkSize;
        this.endByte = Math.min(this.fileObjSize, (this.offset + 1) * chunkSize);
        this.xhr = null;
        if (this.fileObjSize - this.endByte < chunkSize && !this.flowObj.opts.forceChunkSize) {
            this.endByte = this.fileObjSize;
        }
        var $ = this;
        this.event = function(event, args) {
            args = Array.prototype.slice.call(arguments);
            args.unshift($);
            $.fileObj.chunkEvent.apply($.fileObj, args);
        };
        this.progressHandler = function(event) {
            if (event.lengthComputable) {
                $.loaded = event.loaded;
                $.total = event.total;
            }
            $.event('progress', event);
        };
        this.testHandler = function(event) {
            var status = $.status(true);
            if (status === 'error') {
                $.event(status, $.message());
                $.flowObj.uploadNextChunk();
            } else if (status === 'success') {
                $.tested = true;
                $.event(status, $.message());
                $.flowObj.uploadNextChunk();
            } else if (!$.fileObj.paused) {
                $.tested = true;
                $.send();
            }
        };
        this.doneHandler = function(event) {
            var status = $.status();
            if (status === 'success' || status === 'error') {
                $.event(status, $.message());
                $.flowObj.uploadNextChunk();
            } else {
                $.event('retry', $.message());
                $.pendingRetry = true;
                $.abort();
                $.retries++;
                var retryInterval = $.flowObj.opts.chunkRetryInterval;
                if (retryInterval !== null) {
                    setTimeout(function() {
                        $.send();
                    }, retryInterval);
                } else {
                    $.send();
                }
            }
        };
    }
    FlowChunk.prototype = {
        getParams: function() {
            return {
                flowChunkNumber: this.offset + 1,
                flowChunkSize: this.flowObj.opts.chunkSize,
                flowCurrentChunkSize: this.endByte - this.startByte,
                flowTotalSize: this.fileObjSize,
                flowIdentifier: this.fileObj.uniqueIdentifier,
                flowFilename: this.fileObj.name,
                flowRelativePath: this.fileObj.relativePath,
                flowTotalChunks: this.fileObj.chunks.length
            };
        },
        getTarget: function(target, params) {
            if (target.indexOf('?') < 0) {
                target += '?';
            } else {
                target += '&';
            }
            return target + params.join('&');
        },
        test: function() {
            this.xhr = new XMLHttpRequest();
            this.xhr.addEventListener("load", this.testHandler, false);
            this.xhr.addEventListener("error", this.testHandler, false);
            var testMethod = evalOpts(this.flowObj.opts.testMethod, this.fileObj, this);
            var data = this.prepareXhrRequest(testMethod, true);
            this.xhr.send(data);
        },
        preprocessFinished: function() {
            this.preprocessState = 2;
            this.send();
        },
        send: function() {
            var preprocess = this.flowObj.opts.preprocess;
            if (typeof preprocess === 'function') {
                switch (this.preprocessState) {
                    case 0:
                        this.preprocessState = 1;
                        preprocess(this);
                        return;
                    case 1:
                        return;
                }
            }
            if (this.flowObj.opts.testChunks && !this.tested) {
                this.test();
                return;
            }
            this.loaded = 0;
            this.total = 0;
            this.pendingRetry = false;
            var func = (this.fileObj.file.slice ? 'slice' : (this.fileObj.file.mozSlice ? 'mozSlice' : (this.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice')));
            var bytes = this.fileObj.file[func](this.startByte, this.endByte, this.fileObj.file.type);
            this.xhr = new XMLHttpRequest();
            this.xhr.upload.addEventListener('progress', this.progressHandler, false);
            this.xhr.addEventListener("load", this.doneHandler, false);
            this.xhr.addEventListener("error", this.doneHandler, false);
            var uploadMethod = evalOpts(this.flowObj.opts.uploadMethod, this.fileObj, this);
            var data = this.prepareXhrRequest(uploadMethod, false, this.flowObj.opts.method, bytes);
            this.xhr.send(data);
        },
        abort: function() {
            var xhr = this.xhr;
            this.xhr = null;
            if (xhr) {
                xhr.abort();
            }
        },
        status: function(isTest) {
            if (this.pendingRetry || this.preprocessState === 1) {
                return 'uploading';
            } else if (!this.xhr) {
                return 'pending';
            } else if (this.xhr.readyState < 4) {
                return 'uploading';
            } else {
                if (this.flowObj.opts.successStatuses.indexOf(this.xhr.status) > -1) {
                    return 'success';
                } else if (this.flowObj.opts.permanentErrors.indexOf(this.xhr.status) > -1 || !isTest && this.retries >= this.flowObj.opts.maxChunkRetries) {
                    return 'error';
                } else {
                    this.abort();
                    return 'pending';
                }
            }
        },
        message: function() {
            return this.xhr ? this.xhr.responseText : '';
        },
        progress: function() {
            if (this.pendingRetry) {
                return 0;
            }
            var s = this.status();
            if (s === 'success' || s === 'error') {
                return 1;
            } else if (s === 'pending') {
                return 0;
            } else {
                return this.total > 0 ? this.loaded / this.total : 0;
            }
        },
        sizeUploaded: function() {
            var size = this.endByte - this.startByte;
            if (this.status() !== 'success') {
                size = this.progress() * size;
            }
            return size;
        },
        prepareXhrRequest: function(method, isTest, paramsMethod, blob) {
            var query = evalOpts(this.flowObj.opts.query, this.fileObj, this, isTest);
            query = extend(this.getParams(), query);
            var target = evalOpts(this.flowObj.opts.target, this.fileObj, this, isTest);
            var data = null;
            if (method === 'GET' || paramsMethod === 'octet') {
                var params = [];
                each(query, function(v, k) {
                    params.push([encodeURIComponent(k), encodeURIComponent(v)].join('='));
                });
                target = this.getTarget(target, params);
                data = blob || null;
            } else {
                data = new FormData();
                each(query, function(v, k) {
                    data.append(k, v);
                });
                data.append(this.flowObj.opts.fileParameterName, blob, this.fileObj.file.name);
            }
            this.xhr.open(method, target, true);
            this.xhr.withCredentials = this.flowObj.opts.withCredentials;
            each(evalOpts(this.flowObj.opts.headers, this.fileObj, this, isTest), function(v, k) {
                this.xhr.setRequestHeader(k, v);
            }, this);
            return data;
        }
    };

    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index > -1) {
            array.splice(index, 1);
        }
    }

    function evalOpts(data, args) {
        if (typeof data === "function") {
            args = Array.prototype.slice.call(arguments);
            data = data.apply(null, args.slice(1));
        }
        return data;
    }
    Flow.evalOpts = evalOpts;

    function async (fn, context) {
        setTimeout(fn.bind(context), 0);
    }

    function extend(dst, src) {
        each(arguments, function(obj) {
            if (obj !== dst) {
                each(obj, function(value, key) {
                    dst[key] = value;
                });
            }
        });
        return dst;
    }
    Flow.extend = extend;

    function each(obj, callback, context) {
        if (!obj) {
            return;
        }
        var key;
        if (typeof(obj.length) !== 'undefined') {
            for (key = 0; key < obj.length; key++) {
                if (callback.call(context, obj[key], key) === false) {
                    return;
                }
            }
        } else {
            for (key in obj) {
                if (obj.hasOwnProperty(key) && callback.call(context, obj[key], key) === false) {
                    return;
                }
            }
        }
    }
    Flow.each = each;
    Flow.FlowFile = FlowFile;
    Flow.FlowChunk = FlowChunk;
    Flow.version = '2.9.0';
    if (typeof module === "object" && module && typeof module.exports === "object") {
        module.exports = Flow;
    } else {
        window.Flow = Flow;
        if (typeof define === "function" && define.amd) {
            define("flow", [], function() {
                return Flow;
            });
        }
    }
})(window, document);
(function(window, angular, undefined) {
    'use strict';
    angular.module('ngIdle', ['ngIdle.keepalive', 'ngIdle.idle', 'ngIdle.countdown', 'ngIdle.title', 'ngIdle.localStorage']);
    angular.module('ngIdle.keepalive', []).provider('Keepalive', function() {
        var options = {
            http: null,
            interval: 10 * 60
        };
        this.http = function(value) {
            if (!value) throw new Error('Argument must be a string containing a URL, or an object containing the HTTP request configuration.');
            if (angular.isString(value)) {
                value = {
                    url: value,
                    method: 'GET'
                };
            }
            value.cache = false;
            options.http = value;
        };
        var setInterval = this.interval = function(seconds) {
            seconds = parseInt(seconds);
            if (isNaN(seconds) || seconds <= 0) throw new Error('Interval must be expressed in seconds and be greater than 0.');
            options.interval = seconds;
        };
        this.$get = ['$rootScope', '$log', '$interval', '$http', function($rootScope, $log, $interval, $http) {
            var state = {
                ping: null
            };

            function handleResponse(data, status) {
                $rootScope.$broadcast('KeepaliveResponse', data, status);
            }

            function ping() {
                $rootScope.$broadcast('Keepalive');
                if (angular.isObject(options.http)) {
                    $http(options.http).success(handleResponse).error(handleResponse);
                }
            }
            return {
                _options: function() {
                    return options;
                },
                setInterval: setInterval,
                start: function() {
                    $interval.cancel(state.ping);
                    state.ping = $interval(ping, options.interval * 1000);
                    return state.ping;
                },
                stop: function() {
                    $interval.cancel(state.ping);
                },
                ping: function() {
                    ping();
                }
            };
        }];
    });
    angular.module('ngIdle.idle', ['ngIdle.keepalive', 'ngIdle.localStorage']).provider('Idle', function() {
        var options = {
            idle: 20 * 60,
            timeout: 30,
            autoResume: 'idle',
            interrupt: 'mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll',
            keepalive: true
        };
        var setTimeout = this.timeout = function(seconds) {
            if (seconds === false) options.timeout = 0;
            else if (angular.isNumber(seconds) && seconds >= 0) options.timeout = seconds;
            else throw new Error('Timeout must be zero or false to disable the feature, or a positive integer (in seconds) to enable it.');
        };
        this.interrupt = function(events) {
            options.interrupt = events;
        };
        var setIdle = this.idle = function(seconds) {
            if (seconds <= 0) throw new Error('Idle must be a value in seconds, greater than 0.');
            options.idle = seconds;
        };
        this.autoResume = function(value) {
            if (value === true) options.autoResume = 'idle';
            else if (value === false) options.autoResume = 'off';
            else options.autoResume = value;
        };
        this.keepalive = function(enabled) {
            options.keepalive = enabled === true;
        };
        this.$get = ['$interval', '$log', '$rootScope', '$document', 'Keepalive', 'IdleLocalStorage', '$window', function($interval, $log, $rootScope, $document, Keepalive, LocalStorage, $window) {
            var state = {
                idle: null,
                timeout: null,
                idling: false,
                running: false,
                countdown: null
            };
            var id = new Date().getTime();

            function startKeepalive() {
                if (!options.keepalive) return;
                if (state.running) Keepalive.ping();
                Keepalive.start();
            }

            function stopKeepalive() {
                if (!options.keepalive) return;
                Keepalive.stop();
            }

            function toggleState() {
                state.idling = !state.idling;
                var name = state.idling ? 'Start' : 'End';
                $rootScope.$broadcast('Idle' + name);
                if (state.idling) {
                    stopKeepalive();
                    if (options.timeout) {
                        state.countdown = options.timeout;
                        countdown();
                        state.timeout = $interval(countdown, 1000, options.timeout, false);
                    }
                } else {
                    startKeepalive();
                }
                $interval.cancel(state.idle);
            }

            function countdown() {
                if (state.countdown <= 0) {
                    timeout();
                    return;
                }
                $rootScope.$broadcast('IdleWarn', state.countdown);
                state.countdown--;
            }

            function timeout() {
                stopKeepalive();
                $interval.cancel(state.idle);
                $interval.cancel(state.timeout);
                state.idling = true;
                state.running = false;
                state.countdown = 0;
                $rootScope.$broadcast('IdleTimeout');
            }

            function changeOption(self, fn, value) {
                var reset = self.running();
                self.unwatch();
                fn(value);
                if (reset) self.watch();
            }

            function getExpiry() {
                var obj = LocalStorage.get('expiry');
                return obj && obj.time ? new Date(obj.time) : null;
            }

            function setExpiry(date) {
                if (!date) LocalStorage.remove('expiry');
                else LocalStorage.set('expiry', {
                    id: id,
                    time: date
                });
            }
            var svc = {
                _options: function() {
                    return options;
                },
                _getNow: function() {
                    return new Date();
                },
                getIdle: function() {
                    return options.idle;
                },
                getTimeout: function() {
                    return options.timeout;
                },
                setIdle: function(seconds) {
                    changeOption(this, setIdle, seconds);
                },
                setTimeout: function(seconds) {
                    changeOption(this, setTimeout, seconds);
                },
                isExpired: function() {
                    var expiry = getExpiry();
                    return expiry !== null && expiry <= this._getNow();
                },
                running: function() {
                    return state.running;
                },
                idling: function() {
                    return state.idling;
                },
                watch: function(noExpiryUpdate) {
                    $interval.cancel(state.idle);
                    $interval.cancel(state.timeout);
                    var timeout = !options.timeout ? 0 : options.timeout;
                    if (!noExpiryUpdate) setExpiry(new Date(new Date().getTime() + ((options.idle + timeout) * 1000)));
                    if (state.idling) toggleState();
                    else if (!state.running) startKeepalive();
                    state.running = true;
                    state.idle = $interval(toggleState, options.idle * 1000, 0, false);
                },
                unwatch: function() {
                    $interval.cancel(state.idle);
                    $interval.cancel(state.timeout);
                    state.idling = false;
                    state.running = false;
                    setExpiry(null);
                    stopKeepalive();
                },
                interrupt: function(noExpiryUpdate) {
                    if (!state.running) return;
                    if (options.timeout && this.isExpired()) {
                        timeout();
                        return;
                    }
                    if (options.autoResume === 'idle' || (options.autoResume === 'notIdle' && !state.idling)) this.watch(noExpiryUpdate);
                }
            };
            $document.find('html').on(options.interrupt, function(event) {
                if (event.type === 'mousemove' && event.originalEvent && event.originalEvent.movementX === 0 && event.originalEvent.movementY === 0) {
                    return;
                }
                if (event.type !== 'mousemove' || angular.isUndefined(event.movementX) || (event.movementX || event.movementY)) {
                    svc.interrupt();
                }
            });
            var wrap = function(event) {
                if (event.key === 'ngIdle.expiry' && event.newValue && event.newValue !== event.oldValue) {
                    var val = angular.fromJson(event.newValue);
                    if (val.id === id) return;
                    svc.interrupt(true);
                }
            };
            if ($window.addEventListener) $window.addEventListener('storage', wrap, false);
            else $window.attachEvent('onstorage', wrap);
            return svc;
        }];
    });
    angular.module('ngIdle.countdown', ['ngIdle.idle']).directive('idleCountdown', ['Idle', function(Idle) {
        return {
            restrict: 'A',
            scope: {
                value: '=idleCountdown'
            },
            link: function($scope) {
                $scope.value = Idle.getTimeout();
                $scope.$on('IdleWarn', function(e, countdown) {
                    $scope.$evalAsync(function() {
                        $scope.value = countdown;
                    });
                });
                $scope.$on('IdleTimeout', function() {
                    $scope.$evalAsync(function() {
                        $scope.value = 0;
                    });
                });
            }
        };
    }]);
    angular.module('ngIdle.title', []).provider('Title', function() {
        var options = {
            enabled: true
        };
        var setEnabled = this.enabled = function(enabled) {
            options.enabled = enabled === true;
        };

        function padLeft(nr, n, str) {
            return new Array(n - String(nr).length + 1).join(str || '0') + nr;
        }
        this.$get = ['$document', '$interpolate', function($document, $interpolate) {
            var state = {
                original: null,
                idle: '{{minutes}}:{{seconds}} until your session times out!',
                timedout: 'Your session has expired.'
            };
            return {
                setEnabled: setEnabled,
                isEnabled: function() {
                    return options.enabled;
                },
                original: function(val) {
                    if (angular.isUndefined(val)) return state.original;
                    state.original = val;
                },
                store: function(overwrite) {
                    if (overwrite || !state.original) state.original = this.value();
                },
                value: function(val) {
                    if (angular.isUndefined(val)) return $document[0].title;
                    $document[0].title = val;
                },
                idleMessage: function(val) {
                    if (angular.isUndefined(val)) return state.idle;
                    state.idle = val;
                },
                timedOutMessage: function(val) {
                    if (angular.isUndefined(val)) return state.timedout;
                    state.timedout = val;
                },
                setAsIdle: function(countdown) {
                    this.store();
                    var remaining = {
                        totalSeconds: countdown
                    };
                    remaining.minutes = Math.floor(countdown / 60);
                    remaining.seconds = padLeft(countdown - remaining.minutes * 60, 2);
                    this.value($interpolate(this.idleMessage())(remaining));
                },
                setAsTimedOut: function() {
                    this.store();
                    this.value(this.timedOutMessage());
                },
                restore: function() {
                    if (this.original()) this.value(this.original());
                }
            };
        }];
    }).directive('title', ['Title', function(Title) {
        return {
            restrict: 'E',
            link: function($scope, $element, $attr) {
                if (!Title.isEnabled() || $attr.idleDisabled) return;
                Title.store(true);
                $scope.$on('IdleStart', function() {
                    Title.original($element[0].innerText);
                });
                $scope.$on('IdleWarn', function(e, countdown) {
                    Title.setAsIdle(countdown);
                });
                $scope.$on('IdleEnd', function() {
                    Title.restore();
                });
                $scope.$on('IdleTimeout', function() {
                    Title.setAsTimedOut();
                });
            }
        };
    }]);
    angular.module('ngIdle.localStorage', []).service('IdleStorageAccessor', ['$window', function($window) {
        return {
            get: function() {
                return $window.localStorage;
            }
        }
    }]).service('IdleLocalStorage', ['IdleStorageAccessor', function(IdleStorageAccessor) {
        function AlternativeStorage() {
            var storageMap = {};
            this.setItem = function(key, value) {
                storageMap[key] = value;
            };
            this.getItem = function(key) {
                if (typeof storageMap[key] !== 'undefined') {
                    return storageMap[key];
                }
                return null;
            };
            this.removeItem = function(key) {
                storageMap[key] = undefined;
            };
        }

        function getStorage() {
            try {
                var s = IdleStorageAccessor.get();
                s.setItem('ngIdleStorage', '');
                s.removeItem('ngIdleStorage');
                return s;
            } catch (err) {
                return new AlternativeStorage();
            }
        }
        var storage = getStorage();
        return {
            set: function(key, value) {
                storage.setItem('ngIdle.' + key, angular.toJson(value));
            },
            get: function(key) {
                return angular.fromJson(storage.getItem('ngIdle.' + key));
            },
            remove: function(key) {
                storage.removeItem('ngIdle.' + key);
            },
            _wrapped: function() {
                return storage;
            }
        };
    }]);
})(window, window.angular);
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['angular', 'moment'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('angular'), require('moment'));
    } else {
        factory(window.angular, window.moment);
    }
}(function(angular, moment) {
    'use strict';
    angular.module('ui.bootstrap.datetimepicker', []).constant('dateTimePickerConfig', {
        configureOn: null,
        dropdownSelector: null,
        minuteStep: 5,
        minView: 'minute',
        renderOn: null,
        startView: 'day'
    }).directive('datetimepicker', ['$log', 'dateTimePickerConfig', function datetimepickerDirective($log, defaultConfig) {
        function DateObject() {
            var tempDate = new Date();
            var localOffset = tempDate.getTimezoneOffset() * 60000;
            this.utcDateValue = tempDate.getTime();
            this.selectable = true;
            this.localDateValue = function() {
                return this.utcDateValue + localOffset;
            };
            var validProperties = ['utcDateValue', 'localDateValue', 'display', 'active', 'selectable', 'past', 'future'];
            for (var prop in arguments[0]) {
                if (validProperties.indexOf(prop) >= 0) {
                    this[prop] = arguments[0][prop];
                }
            }
        }
        var validateConfiguration = function validateConfiguration(configuration) {
            var validOptions = ['configureOn', 'dropdownSelector', 'minuteStep', 'minView', 'renderOn', 'startView'];
            for (var prop in configuration) {
                if (validOptions.indexOf(prop) < 0) {
                    throw ('invalid option: ' + prop);
                }
            }
            var validViews = ['minute', 'hour', 'day', 'month', 'year'];
            if (validViews.indexOf(configuration.startView) < 0) {
                throw ('invalid startView value: ' + configuration.startView);
            }
            if (validViews.indexOf(configuration.minView) < 0) {
                throw ('invalid minView value: ' + configuration.minView);
            }
            if (validViews.indexOf(configuration.minView) > validViews.indexOf(configuration.startView)) {
                throw ('startView must be greater than minView');
            }
            if (!angular.isNumber(configuration.minuteStep)) {
                throw ('minuteStep must be numeric');
            }
            if (configuration.minuteStep <= 0 || configuration.minuteStep >= 60) {
                throw ('minuteStep must be greater than zero and less than 60');
            }
            if (configuration.configureOn !== null && !angular.isString(configuration.configureOn)) {
                throw ('configureOn must be a string');
            }
            if (configuration.configureOn !== null && configuration.configureOn.length < 1) {
                throw ('configureOn must not be an empty string');
            }
            if (configuration.renderOn !== null && !angular.isString(configuration.renderOn)) {
                throw ('renderOn must be a string');
            }
            if (configuration.renderOn !== null && configuration.renderOn.length < 1) {
                throw ('renderOn must not be an empty string');
            }
            if (configuration.dropdownSelector !== null && !angular.isString(configuration.dropdownSelector)) {
                throw ('dropdownSelector must be a string');
            }
            if (configuration.dropdownSelector !== null && ((typeof jQuery === 'undefined') || (typeof jQuery().dropdown !== 'function'))) {
                $log.error('Please DO NOT specify the dropdownSelector option unless you are using jQuery AND Bootstrap.js. ' + 'Please include jQuery AND Bootstrap.js, or write code to close the dropdown in the on-set-time callback. \n\n' + 'The dropdownSelector configuration option is being removed because it will not function properly.');
                delete configuration.dropdownSelector;
            }
        };
        return {
            restrict: 'E',
            require: 'ngModel',
            template: '<div class="datetimepicker table-responsive">' + '<table class="table table-condensed  {{ data.currentView }}-view">' + '   <thead>' + '       <tr>' + '           <th class="left" data-ng-click="changeView(data.currentView, data.leftDate, $event)" data-ng-show="data.leftDate.selectable"><i class="glyphicon glyphicon-arrow-left"/></th>' + '           <th class="switch" colspan="5" data-ng-show="data.previousViewDate.selectable" data-ng-click="changeView(data.previousView, data.previousViewDate, $event)">{{ data.previousViewDate.display }}</th>' + '           <th class="right" data-ng-click="changeView(data.currentView, data.rightDate, $event)" data-ng-show="data.rightDate.selectable"><i class="glyphicon glyphicon-arrow-right"/></th>' + '       </tr>' + '       <tr>' + '           <th class="dow" data-ng-repeat="day in data.dayNames" >{{ day }}</th>' + '       </tr>' + '   </thead>' + '   <tbody>' + '       <tr data-ng-if="data.currentView !== \'day\'" >' + '           <td colspan="7" >' + '              <span    class="{{ data.currentView }}" ' + '                       data-ng-repeat="dateObject in data.dates"  ' + '                       data-ng-class="{active: dateObject.active, past: dateObject.past, future: dateObject.future, disabled: !dateObject.selectable}" ' + '                       data-ng-click="changeView(data.nextView, dateObject, $event)">{{ dateObject.display }}</span> ' + '           </td>' + '       </tr>' + '       <tr data-ng-if="data.currentView === \'day\'" data-ng-repeat="week in data.weeks">' + '           <td data-ng-repeat="dateObject in week.dates" ' + '               data-ng-click="changeView(data.nextView, dateObject, $event)"' + '               class="day" ' + '               data-ng-class="{active: dateObject.active, past: dateObject.past, future: dateObject.future, disabled: !dateObject.selectable}" >{{ dateObject.display }}</td>' + '       </tr>' + '   </tbody>' + '</table></div>',
            scope: {
                onSetTime: '&',
                beforeRender: '&'
            },
            replace: true,
            link: function link(scope, element, attrs, ngModelController) {
                var configure = function configure() {
                    var directiveConfig = {};
                    if (attrs.datetimepickerConfig) {
                        directiveConfig = scope.$parent.$eval(attrs.datetimepickerConfig);
                    }
                    var configuration = {};
                    angular.extend(configuration, defaultConfig, directiveConfig);
                    validateConfiguration(configuration);
                    return configuration;
                };
                var configuration = configure();
                var startOfDecade = function startOfDecade(unixDate) {
                    var startYear = (parseInt(moment.utc(unixDate).year() / 10, 10) * 10);
                    return moment.utc(unixDate).year(startYear).startOf('year');
                };
                var dataFactory = {
                    year: function year(unixDate) {
                        var selectedDate = moment.utc(unixDate).startOf('year');
                        var startDecade = (parseInt(selectedDate.year() / 10, 10) * 10);
                        var startDate = moment.utc(startOfDecade(unixDate)).subtract(1, 'year').startOf('year');
                        var activeYear = ngModelController.$modelValue ? moment(ngModelController.$modelValue).year() : 0;
                        var result = {
                            'currentView': 'year',
                            'nextView': configuration.minView === 'year' ? 'setTime' : 'month',
                            'previousViewDate': new DateObject({
                                utcDateValue: null,
                                display: startDecade + '-' + (startDecade + 9)
                            }),
                            'leftDate': new DateObject({
                                utcDateValue: moment.utc(startDate).subtract(9, 'year').valueOf()
                            }),
                            'rightDate': new DateObject({
                                utcDateValue: moment.utc(startDate).add(11, 'year').valueOf()
                            }),
                            'dates': []
                        };
                        for (var i = 0; i < 12; i += 1) {
                            var yearMoment = moment.utc(startDate).add(i, 'years');
                            var dateValue = {
                                'utcDateValue': yearMoment.valueOf(),
                                'display': yearMoment.format('YYYY'),
                                'past': yearMoment.year() < startDecade,
                                'future': yearMoment.year() > startDecade + 9,
                                'active': yearMoment.year() === activeYear
                            };
                            result.dates.push(new DateObject(dateValue));
                        }
                        return result;
                    },
                    month: function month(unixDate) {
                        var startDate = moment.utc(unixDate).startOf('year');
                        var previousViewDate = startOfDecade(unixDate);
                        var activeDate = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MMM') : 0;
                        var result = {
                            'previousView': 'year',
                            'currentView': 'month',
                            'nextView': configuration.minView === 'month' ? 'setTime' : 'day',
                            'previousViewDate': new DateObject({
                                utcDateValue: previousViewDate.valueOf(),
                                display: startDate.format('YYYY')
                            }),
                            'leftDate': new DateObject({
                                utcDateValue: moment.utc(startDate).subtract(1, 'year').valueOf()
                            }),
                            'rightDate': new DateObject({
                                utcDateValue: moment.utc(startDate).add(1, 'year').valueOf()
                            }),
                            'dates': []
                        };
                        for (var i = 0; i < 12; i += 1) {
                            var monthMoment = moment.utc(startDate).add(i, 'months');
                            var dateValue = {
                                'utcDateValue': monthMoment.valueOf(),
                                'display': monthMoment.format('MMM'),
                                'active': monthMoment.format('YYYY-MMM') === activeDate
                            };
                            result.dates.push(new DateObject(dateValue));
                        }
                        return result;
                    },
                    day: function day(unixDate) {
                        var selectedDate = moment.utc(unixDate);
                        var startOfMonth = moment.utc(selectedDate).startOf('month');
                        var previousViewDate = moment.utc(selectedDate).startOf('year');
                        var endOfMonth = moment.utc(selectedDate).endOf('month');
                        var startDate = moment.utc(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
                        var activeDate = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MMM-DD') : '';
                        var result = {
                            'previousView': 'month',
                            'currentView': 'day',
                            'nextView': configuration.minView === 'day' ? 'setTime' : 'hour',
                            'previousViewDate': new DateObject({
                                utcDateValue: previousViewDate.valueOf(),
                                display: startOfMonth.format('YYYY-MMM')
                            }),
                            'leftDate': new DateObject({
                                utcDateValue: moment.utc(startOfMonth).subtract(1, 'months').valueOf()
                            }),
                            'rightDate': new DateObject({
                                utcDateValue: moment.utc(startOfMonth).add(1, 'months').valueOf()
                            }),
                            'dayNames': [],
                            'weeks': []
                        };
                        for (var dayNumber = 0; dayNumber < 7; dayNumber += 1) {
                            result.dayNames.push(moment.utc().weekday(dayNumber).format('dd'));
                        }
                        for (var i = 0; i < 6; i += 1) {
                            var week = {
                                dates: []
                            };
                            for (var j = 0; j < 7; j += 1) {
                                var monthMoment = moment.utc(startDate).add((i * 7) + j, 'days');
                                var dateValue = {
                                    'utcDateValue': monthMoment.valueOf(),
                                    'display': monthMoment.format('D'),
                                    'active': monthMoment.format('YYYY-MMM-DD') === activeDate,
                                    'past': monthMoment.isBefore(startOfMonth),
                                    'future': monthMoment.isAfter(endOfMonth)
                                };
                                week.dates.push(new DateObject(dateValue));
                            }
                            result.weeks.push(week);
                        }
                        return result;
                    },
                    hour: function hour(unixDate) {
                        var selectedDate = moment.utc(unixDate).startOf('day');
                        var previousViewDate = moment.utc(selectedDate).startOf('month');
                        var activeFormat = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MM-DD H') : '';
                        var result = {
                            'previousView': 'day',
                            'currentView': 'hour',
                            'nextView': configuration.minView === 'hour' ? 'setTime' : 'minute',
                            'previousViewDate': new DateObject({
                                utcDateValue: previousViewDate.valueOf(),
                                display: selectedDate.format('ll')
                            }),
                            'leftDate': new DateObject({
                                utcDateValue: moment.utc(selectedDate).subtract(1, 'days').valueOf()
                            }),
                            'rightDate': new DateObject({
                                utcDateValue: moment.utc(selectedDate).add(1, 'days').valueOf()
                            }),
                            'dates': []
                        };
                        for (var i = 0; i < 24; i += 1) {
                            var hourMoment = moment.utc(selectedDate).add(i, 'hours');
                            var dateValue = {
                                'utcDateValue': hourMoment.valueOf(),
                                'display': hourMoment.format('LT'),
                                'active': hourMoment.format('YYYY-MM-DD H') === activeFormat
                            };
                            result.dates.push(new DateObject(dateValue));
                        }
                        return result;
                    },
                    minute: function minute(unixDate) {
                        var selectedDate = moment.utc(unixDate).startOf('hour');
                        var previousViewDate = moment.utc(selectedDate).startOf('day');
                        var activeFormat = ngModelController.$modelValue ? moment(ngModelController.$modelValue).format('YYYY-MM-DD H:mm') : '';
                        var result = {
                            'previousView': 'hour',
                            'currentView': 'minute',
                            'nextView': 'setTime',
                            'previousViewDate': new DateObject({
                                utcDateValue: previousViewDate.valueOf(),
                                display: selectedDate.format('lll')
                            }),
                            'leftDate': new DateObject({
                                utcDateValue: moment.utc(selectedDate).subtract(1, 'hours').valueOf()
                            }),
                            'rightDate': new DateObject({
                                utcDateValue: moment.utc(selectedDate).add(1, 'hours').valueOf()
                            }),
                            'dates': []
                        };
                        var limit = 60 / configuration.minuteStep;
                        for (var i = 0; i < limit; i += 1) {
                            var hourMoment = moment.utc(selectedDate).add(i * configuration.minuteStep, 'minute');
                            var dateValue = {
                                'utcDateValue': hourMoment.valueOf(),
                                'display': hourMoment.format('LT'),
                                'active': hourMoment.format('YYYY-MM-DD H:mm') === activeFormat
                            };
                            result.dates.push(new DateObject(dateValue));
                        }
                        return result;
                    },
                    setTime: function setTime(unixDate) {
                        var tempDate = new Date(unixDate);
                        var newDate = new Date(tempDate.getUTCFullYear(), tempDate.getUTCMonth(), tempDate.getUTCDate(), tempDate.getUTCHours(), tempDate.getUTCMinutes(), tempDate.getUTCSeconds(), tempDate.getUTCMilliseconds());
                        var oldDate = ngModelController.$modelValue;
                        ngModelController.$setViewValue(newDate);
                        if (configuration.dropdownSelector) {
                            jQuery(configuration.dropdownSelector).dropdown('toggle');
                        }
                        scope.onSetTime({
                            newDate: newDate,
                            oldDate: oldDate
                        });
                        return dataFactory[configuration.startView](unixDate);
                    }
                };
                var getUTCTime = function getUTCTime(modelValue) {
                    var tempDate = (modelValue ? moment(modelValue).toDate() : new Date());
                    return tempDate.getTime() - (tempDate.getTimezoneOffset() * 60000);
                };
                scope.changeView = function changeView(viewName, dateObject, event) {
                    if (event) {
                        event.stopPropagation();
                        event.preventDefault();
                    }
                    if (viewName && (dateObject.utcDateValue > -Infinity) && dateObject.selectable && dataFactory[viewName]) {
                        var result = dataFactory[viewName](dateObject.utcDateValue);
                        var weekDates = [];
                        if (result.weeks) {
                            for (var i = 0; i < result.weeks.length; i += 1) {
                                var week = result.weeks[i];
                                for (var j = 0; j < week.dates.length; j += 1) {
                                    var weekDate = week.dates[j];
                                    weekDates.push(weekDate);
                                }
                            }
                        }
                        scope.beforeRender({
                            $view: result.currentView,
                            $dates: result.dates || weekDates,
                            $leftDate: result.leftDate,
                            $upDate: result.previousViewDate,
                            $rightDate: result.rightDate
                        });
                        scope.data = result;
                    }
                };
                ngModelController.$render = function $render() {
                    scope.changeView(configuration.startView, new DateObject({
                        utcDateValue: getUTCTime(ngModelController.$viewValue)
                    }));
                };
                if (configuration.configureOn) {
                    scope.$on(configuration.configureOn, function() {
                        configuration = configure();
                        ngModelController.$render();
                    });
                }
                if (configuration.renderOn) {
                    scope.$on(configuration.renderOn, ngModelController.$render);
                }
            }
        };
    }]);
}));
(function(window, document) {
    'use strict';
    angular.module('toaster', []).constant('toasterConfig', {
        'limit': 0,
        'tap-to-dismiss': true,
        'close-button': false,
        'close-html': '<button class="toast-close-button" type="button">&times;</button>',
        'newest-on-top': true,
        'time-out': 5000,
        'icon-classes': {
            error: 'toast-error',
            info: 'toast-info',
            wait: 'toast-wait',
            success: 'toast-success',
            warning: 'toast-warning'
        },
        'body-output-type': '',
        'body-template': 'toasterBodyTmpl.html',
        'icon-class': 'toast-info',
        'position-class': 'toast-top-right',
        'title-class': 'toast-title',
        'message-class': 'toast-message',
        'prevent-duplicates': false,
        'mouseover-timer-stop': true
    }).service('toaster', ['$rootScope', 'toasterConfig', function($rootScope, toasterConfig) {
        this.pop = function(type, title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton, toastId, onHideCallback) {
            if (angular.isObject(type)) {
                var params = type;
                this.toast = {
                    type: params.type,
                    title: params.title,
                    body: params.body,
                    timeout: params.timeout,
                    bodyOutputType: params.bodyOutputType,
                    clickHandler: params.clickHandler,
                    showCloseButton: params.showCloseButton,
                    closeHtml: params.closeHtml,
                    uid: params.toastId,
                    onHideCallback: params.onHideCallback,
                    directiveData: params.directiveData
                };
                toastId = params.toastId;
                toasterId = params.toasterId;
            } else {
                this.toast = {
                    type: type,
                    title: title,
                    body: body,
                    timeout: timeout,
                    bodyOutputType: bodyOutputType,
                    clickHandler: clickHandler,
                    showCloseButton: showCloseButton,
                    uid: toastId,
                    onHideCallback: onHideCallback
                };
            }
            $rootScope.$emit('toaster-newToast', toasterId, toastId);
        };
        this.clear = function(toasterId, toastId) {
            $rootScope.$emit('toaster-clearToasts', toasterId, toastId);
        };
        for (var type in toasterConfig['icon-classes']) {
            this[type] = createTypeMethod(type);
        }

        function createTypeMethod(toasterType) {
            return function(title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton, toastId, onHideCallback) {
                if (angular.isString(title)) {
                    this.pop(toasterType, title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton, toastId, onHideCallback);
                } else {
                    this.pop(angular.extend(title, {
                        type: toasterType
                    }));
                }
            };
        }
    }]).factory('toasterEventRegistry', ['$rootScope', function($rootScope) {
        var deregisterNewToast = null,
            deregisterClearToasts = null,
            newToastEventSubscribers = [],
            clearToastsEventSubscribers = [],
            toasterFactory;
        toasterFactory = {
            setup: function() {
                if (!deregisterNewToast) {
                    deregisterNewToast = $rootScope.$on('toaster-newToast', function(event, toasterId, toastId) {
                        for (var i = 0, len = newToastEventSubscribers.length; i < len; i++) {
                            newToastEventSubscribers[i](event, toasterId, toastId);
                        }
                    });
                }
                if (!deregisterClearToasts) {
                    deregisterClearToasts = $rootScope.$on('toaster-clearToasts', function(event, toasterId, toastId) {
                        for (var i = 0, len = clearToastsEventSubscribers.length; i < len; i++) {
                            clearToastsEventSubscribers[i](event, toasterId, toastId);
                        }
                    });
                }
            },
            subscribeToNewToastEvent: function(onNewToast) {
                newToastEventSubscribers.push(onNewToast);
            },
            subscribeToClearToastsEvent: function(onClearToasts) {
                clearToastsEventSubscribers.push(onClearToasts);
            },
            unsubscribeToNewToastEvent: function(onNewToast) {
                var index = newToastEventSubscribers.indexOf(onNewToast);
                if (index >= 0) {
                    newToastEventSubscribers.splice(index, 1);
                }
                if (newToastEventSubscribers.length === 0) {
                    deregisterNewToast();
                    deregisterNewToast = null;
                }
            },
            unsubscribeToClearToastsEvent: function(onClearToasts) {
                var index = clearToastsEventSubscribers.indexOf(onClearToasts);
                if (index >= 0) {
                    clearToastsEventSubscribers.splice(index, 1);
                }
                if (clearToastsEventSubscribers.length === 0) {
                    deregisterClearToasts();
                    deregisterClearToasts = null;
                }
            }
        };
        return {
            setup: toasterFactory.setup,
            subscribeToNewToastEvent: toasterFactory.subscribeToNewToastEvent,
            subscribeToClearToastsEvent: toasterFactory.subscribeToClearToastsEvent,
            unsubscribeToNewToastEvent: toasterFactory.unsubscribeToNewToastEvent,
            unsubscribeToClearToastsEvent: toasterFactory.unsubscribeToClearToastsEvent
        };
    }]).directive('directiveTemplate', ['$compile', '$injector', function($compile, $injector) {
        return {
            restrict: 'A',
            scope: {
                directiveName: '@directiveName',
                directiveData: '@directiveData'
            },
            replace: true,
            link: function(scope, elm, attrs) {
                scope.$watch('directiveName', function(directiveName) {
                    if (angular.isUndefined(directiveName) || directiveName.length <= 0) throw new Error('A valid directive name must be provided via the toast body argument when using bodyOutputType: directive');
                    var directiveExists = $injector.has(attrs.$normalize(directiveName) + 'Directive');
                    if (!directiveExists) throw new Error(directiveName + ' could not be found.');
                    if (scope.directiveData) scope.directiveData = angular.fromJson(scope.directiveData);
                    var template = $compile('<div ' + directiveName + '></div>')(scope);
                    elm.append(template);
                });
            }
        }
    }]).directive('toasterContainer', ['$parse', '$rootScope', '$interval', '$sce', 'toasterConfig', 'toaster', 'toasterEventRegistry', function($parse, $rootScope, $interval, $sce, toasterConfig, toaster, toasterEventRegistry) {
        return {
            replace: true,
            restrict: 'EA',
            scope: true,
            link: function(scope, elm, attrs) {
                var id = 0,
                    mergedConfig;
                mergedConfig = angular.extend({}, toasterConfig, scope.$eval(attrs.toasterOptions));
                scope.config = {
                    toasterId: mergedConfig['toaster-id'],
                    position: mergedConfig['position-class'],
                    title: mergedConfig['title-class'],
                    message: mergedConfig['message-class'],
                    tap: mergedConfig['tap-to-dismiss'],
                    closeButton: mergedConfig['close-button'],
                    closeHtml: mergedConfig['close-html'],
                    animation: mergedConfig['animation-class'],
                    mouseoverTimer: mergedConfig['mouseover-timer-stop']
                };
                scope.$on("$destroy", function() {
                    toasterEventRegistry.unsubscribeToNewToastEvent(scope._onNewToast);
                    toasterEventRegistry.unsubscribeToClearToastsEvent(scope._onClearToasts);
                });

                function setTimeout(toast, time) {
                    toast.timeoutPromise = $interval(function() {
                        scope.removeToast(toast.id);
                    }, time, 1);
                }
                scope.configureTimer = function(toast) {
                    var timeout = angular.isNumber(toast.timeout) ? toast.timeout : mergedConfig['time-out'];
                    if (typeof timeout === "object") timeout = timeout[toast.type];
                    if (timeout > 0) {
                        setTimeout(toast, timeout);
                    }
                };

                function addToast(toast, toastId) {
                    toast.type = mergedConfig['icon-classes'][toast.type];
                    if (!toast.type) {
                        toast.type = mergedConfig['icon-class'];
                    }
                    if (mergedConfig['prevent-duplicates'] === true) {
                        if (isUndefinedOrNull(toastId)) {
                            if (scope.toasters.length > 0 && scope.toasters[scope.toasters.length - 1].body === toast.body) {
                                return;
                            }
                        } else {
                            var i, len;
                            for (i = 0, len = scope.toasters.length; i < len; i++) {
                                if (scope.toasters[i].uid === toastId) {
                                    removeToast(i);
                                    i--;
                                    len = scope.toasters.length;
                                }
                            }
                        }
                    }
                    toast.id = ++id;
                    if (!isUndefinedOrNull(toastId)) {
                        toast.uid = toastId;
                    }
                    var closeButton = mergedConfig['close-button'];
                    if (typeof toast.showCloseButton === "boolean") {} else if (typeof closeButton === "boolean") {
                        toast.showCloseButton = closeButton;
                    } else if (typeof closeButton === "object") {
                        var closeButtonForType = closeButton[toast.type];
                        if (typeof closeButtonForType !== "undefined" && closeButtonForType !== null) {
                            toast.showCloseButton = closeButtonForType;
                        }
                    } else {
                        toast.showCloseButton = false;
                    }
                    if (toast.showCloseButton) {
                        toast.closeHtml = $sce.trustAsHtml(toast.closeHtml || scope.config.closeHtml);
                    }
                    toast.bodyOutputType = toast.bodyOutputType || mergedConfig['body-output-type'];
                    switch (toast.bodyOutputType) {
                        case 'trustedHtml':
                            toast.html = $sce.trustAsHtml(toast.body);
                            break;
                        case 'template':
                            toast.bodyTemplate = toast.body || mergedConfig['body-template'];
                            break;
                        case 'templateWithData':
                            var fcGet = $parse(toast.body || mergedConfig['body-template']);
                            var templateWithData = fcGet(scope);
                            toast.bodyTemplate = templateWithData.template;
                            toast.data = templateWithData.data;
                            break;
                        case 'directive':
                            toast.html = toast.body;
                            break;
                    }
                    scope.configureTimer(toast);
                    if (mergedConfig['newest-on-top'] === true) {
                        scope.toasters.unshift(toast);
                        if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {
                            scope.toasters.pop();
                        }
                    } else {
                        scope.toasters.push(toast);
                        if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {
                            scope.toasters.shift();
                        }
                    }
                }
                scope.removeToast = function(id) {
                    var i, len;
                    for (i = 0, len = scope.toasters.length; i < len; i++) {
                        if (scope.toasters[i].id === id) {
                            removeToast(i);
                            break;
                        }
                    }
                };

                function removeToast(toastIndex) {
                    var toast = scope.toasters[toastIndex];
                    if (toast) {
                        if (toast.timeoutPromise) {
                            $interval.cancel(toast.timeoutPromise);
                        }
                        scope.toasters.splice(toastIndex, 1);
                        if (angular.isFunction(toast.onHideCallback)) {
                            toast.onHideCallback();
                        }
                    }
                }

                function removeAllToasts(toastId) {
                    for (var i = scope.toasters.length - 1; i >= 0; i--) {
                        if (isUndefinedOrNull(toastId)) {
                            removeToast(i);
                        } else {
                            if (scope.toasters[i].uid == toastId) {
                                removeToast(i);
                            }
                        }
                    }
                }
                scope.toasters = [];

                function isUndefinedOrNull(val) {
                    return angular.isUndefined(val) || val === null;
                }
                scope._onNewToast = function(event, toasterId, toastId) {
                    if ((isUndefinedOrNull(scope.config.toasterId) && isUndefinedOrNull(toasterId)) || (!isUndefinedOrNull(scope.config.toasterId) && !isUndefinedOrNull(toasterId) && scope.config.toasterId == toasterId)) {
                        addToast(toaster.toast, toastId);
                    }
                };
                scope._onClearToasts = function(event, toasterId, toastId) {
                    if (toasterId == '*' || (isUndefinedOrNull(scope.config.toasterId) && isUndefinedOrNull(toasterId)) || (!isUndefinedOrNull(scope.config.toasterId) && !isUndefinedOrNull(toasterId) && scope.config.toasterId == toasterId)) {
                        removeAllToasts(toastId);
                    }
                };
                toasterEventRegistry.setup();
                toasterEventRegistry.subscribeToNewToastEvent(scope._onNewToast);
                toasterEventRegistry.subscribeToClearToastsEvent(scope._onClearToasts);
            },
            controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
                $scope.stopTimer = function(toast) {
                    if ($scope.config.mouseoverTimer === true) {
                        if (toast.timeoutPromise) {
                            $interval.cancel(toast.timeoutPromise);
                            toast.timeoutPromise = null;
                        }
                    }
                };
                $scope.restartTimer = function(toast) {
                    if ($scope.config.mouseoverTimer === true) {
                        if (!toast.timeoutPromise) {
                            $scope.configureTimer(toast);
                        }
                    } else if (toast.timeoutPromise === null) {
                        $scope.removeToast(toast.id);
                    }
                };
                $scope.click = function(toast, isCloseButton) {
                    if ($scope.config.tap === true || (toast.showCloseButton === true && isCloseButton === true)) {
                        var removeToast = true;
                        if (toast.clickHandler) {
                            if (angular.isFunction(toast.clickHandler)) {
                                removeToast = toast.clickHandler(toast, isCloseButton);
                            } else if (angular.isFunction($scope.$parent.$eval(toast.clickHandler))) {
                                removeToast = $scope.$parent.$eval(toast.clickHandler)(toast, isCloseButton);
                            } else {
                                console.log("TOAST-NOTE: Your click handler is not inside a parent scope of toaster-container.");
                            }
                        }
                        if (removeToast) {
                            $scope.removeToast(toast.id);
                        }
                    }
                };
            }],
            template: '<div id="toast-container" ng-class="[config.position, config.animation]">' + '<div ng-repeat="toaster in toasters" class="toast" ng-class="toaster.type" ng-click="click(toaster)" ng-mouseover="stopTimer(toaster)" ng-mouseout="restartTimer(toaster)">' + '<div ng-if="toaster.showCloseButton" ng-click="click(toaster, true)" ng-bind-html="toaster.closeHtml"></div>' + '<div ng-class="config.title">{{toaster.title}}</div>' + '<div ng-class="config.message" ng-switch on="toaster.bodyOutputType">' + '<div ng-switch-when="trustedHtml" ng-bind-html="toaster.html">i am here</div>' + '<div ng-switch-when="template"><div ng-include="toaster.bodyTemplate"></div></div>' + '<div ng-switch-when="templateWithData"><div ng-include="toaster.bodyTemplate"></div></div>' + '<div ng-switch-when="directive"><div directive-template directive-name="{{toaster.html}}" directive-data="{{toaster.directiveData}}"></div></div>' + '<div ng-switch-default >{{toaster.body}}</div>' + '</div>' + '</div>' + '</div>'
        };
    }]);
})(window, document);
var bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments);
    };
};
angular.module('nemLogging', []).provider('nemSimpleLogger', function() {
    var LEVELS, Logger, _fns, maybeExecLevel;
    _fns = ['log', 'info', 'debug', 'warn', 'error'];
    LEVELS = {
        log: 1,
        info: 2,
        debug: 3,
        warn: 4,
        error: 5
    };
    maybeExecLevel = function(level, current, fn) {
        if (level >= current) {
            return fn();
        }
    };
    Logger = (function() {
        function Logger($log1) {
            var logFns;
            this.$log = $log1;
            this.spawn = bind(this.spawn, this);
            if (!this.$log) {
                throw 'internalLogger undefined';
            }
            this.doLog = true;
            logFns = {};
            _fns.forEach((function(_this) {
                return function(level) {
                    return logFns[level] = function(msg) {
                        if (_this.doLog) {
                            return maybeExecLevel(LEVELS[level], _this.currentLevel, function() {
                                return _this.$log[level](msg);
                            });
                        }
                    };
                };
            })(this));
            this.LEVELS = LEVELS;
            this.currentLevel = LEVELS.error;
            _fns.forEach((function(_this) {
                return function(fnName) {
                    return _this[fnName] = logFns[fnName];
                };
            })(this));
        }
        Logger.prototype.spawn = function(newInternalLogger) {
            return new Logger(newInternalLogger || this.$log);
        };
        return Logger;
    })();
    this.decorator = ['$log', function($delegate) {
        var log;
        log = new Logger($delegate);
        log.currentLevel = LEVELS.log;
        return log;
    }];
    this.$get = ['$log', function($log) {
        return new Logger($log);
    }];
    return this;
});
! function(a) {
    "use strict";
    a.module("720kb.socialshare", []).directive("socialshare", ["$window", "$location", function(a, b) {
        return {
            restrict: "A",
            link: function(c, d, e) {
                var f, g, h = {},
                    i = {
                        url: "",
                        redirectUri: "",
                        provider: "",
                        type: "",
                        text: "",
                        caption: "",
                        to: "",
                        ref: "",
                        display: "",
                        from: "",
                        media: "",
                        hashtags: "",
                        via: "",
                        description: "",
                        source: "",
                        subreddit: "",
                        follow: "",
                        popupHeight: 500,
                        popupWidth: 500
                    };
                for (f in i) i.hasOwnProperty(f) && (g = "socialshare" + f.substring(0, 1).toUpperCase() + f.substring(1), function(a) {
                    e.$observe(g, function(b) {
                        b && (h[a] = b)
                    })
                }(f), void 0 === h[f] && (h[f] = i[f]));
                h.eventTrigger = e.socialshareTrigger || "click", c.facebookShare = function(c) {
                    if (c.type && "feed" === c.type) {
                        var d = "https://www.facebook.com/dialog/feed?display=popup&app_id=" + encodeURI(c.via) + "&redirect_uri=" + encodeURI(c.redirectUri);
                        c.url && (d += "&link=" + encodeURIComponent(c.url)), c.to && (d += "&to=" + encodeURIComponent(c.to)), c.display && (d += "&display=" + encodeURIComponent(c.display)), c.ref && (d += "&ref=" + encodeURIComponent(c.ref)), c.from && (d += "&from=" + encodeURIComponent(c.from)), c.description && (d += "&description=" + encodeURIComponent(c.description)), c.text && (d += "&name=" + encodeURIComponent(c.text)), c.caption && (d += "&caption=" + encodeURIComponent(c.caption)), c.media && (d += "&picture=" + encodeURIComponent(c.media)), c.source && (d += "&source=" + encodeURIComponent(c.source)), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                    } else a.open("https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(c.url || b.absUrl()), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.twitterShare = function(c) {
                    var d = "https://www.twitter.com/intent/tweet?";
                    c.text && (d += "text=" + encodeURIComponent(c.text)), c.via && (d += "&via=" + encodeURI(c.via)), c.hashtags && (d += "&hashtags=" + encodeURI(c.hashtags)), d += "&url=" + encodeURIComponent(c.url || b.absUrl()), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.googlePlusShare = function(c) {
                    a.open("https://plus.google.com/share?url=" + encodeURIComponent(c.url || b.absUrl()), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.redditShare = function(c) {
                    var d = "https://www.reddit.com/";
                    d += c.subreddit ? "r/" + c.subreddit + "/submit?url=" : "submit?url=", c.popupWidth < 900 && (c.popupWidth = 900), c.popupHeight < 650 && (c.popupHeight = 650), a.open(d + encodeURIComponent(c.url || b.absUrl()) + "&title=" + encodeURIComponent(c.text), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.stumbleuponShare = function(c) {
                    a.open("https://www.stumbleupon.com/submit?url=" + encodeURIComponent(c.url || b.absUrl()) + "&title=" + encodeURIComponent(c.text), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.linkedinShare = function(c) {
                    var d = "https://www.linkedin.com/shareArticle?mini=true";
                    d += "&url=" + encodeURIComponent(c.url || b.absUrl()), c.text && (d += "&title=" + encodeURIComponent(c.text)), c.description && (d += "&summary=" + encodeURIComponent(c.description)), c.source && (d += "&source=" + encodeURIComponent(c.source)), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.pinterestShare = function(c) {
                    a.open("https://www.pinterest.com/pin/create/button/?url=" + encodeURIComponent(c.url || b.absUrl()) + "&media=" + encodeURI(c.media) + "&description=" + encodeURIComponent(c.text), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.diggShare = function(c) {
                    a.open("https://www.digg.com/submit?url=" + encodeURIComponent(c.url || b.absUrl()) + "&title=" + encodeURIComponent(c.text), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.tumblrShare = function(b) {
                    if (b.media) {
                        var c = "https://www.tumblr.com/share/photo?source=" + encodeURIComponent(b.media);
                        b.text && (c += "&caption=" + encodeURIComponent(b.text)), a.open(c, "sharer", "toolbar=0,status=0,width=" + b.popupWidth + ",height=" + b.popupHeight)
                    } else a.open("https://www.tumblr.com/share/link?url=" + encodeURIComponent(b.url) + "&description=" + encodeURIComponent(b.text), "sharer", "toolbar=0,status=0,width=" + b.popupWidth + ",height=" + b.popupHeight)
                }, c.vkShare = function(c) {
                    a.open("https://www.vk.com/share.php?url=" + encodeURIComponent(c.url || b.absUrl()), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.deliciousShare = function(c) {
                    a.open("https://www.delicious.com/save?v=5&noui&jump=close&url=" + encodeURIComponent(c.url || b.absUrl()) + "&title=" + encodeURIComponent(c.text), "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.bufferShare = function(c) {
                    var d = "https://bufferapp.com/add?";
                    c.text && (d += "text=" + encodeURIComponent(c.text)), c.via && (d += "&via=" + encodeURI(c.via)), d += "&url=" + encodeURIComponent(c.url || b.absUrl()), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.hackernewsShare = function(c) {
                    var d = "https://news.ycombinator.com/submitlink?";
                    c.text && (d += "t=" + encodeURIComponent(c.text) + "&"), d += "u=" + encodeURIComponent(c.url || b.absUrl()), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.flipboardShare = function(c) {
                    var d = "https://share.flipboard.com/bookmarklet/popout?v=2&";
                    c.text && (d += "title=" + encodeURIComponent(c.text) + "&"), d += "url=" + encodeURIComponent(c.url || b.absUrl()), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.pocketShare = function(c) {
                    var d = "https://getpocket.com/save?";
                    c.text && (d += "text=" + encodeURIComponent(c.text) + "&"), d += "url=" + encodeURIComponent(c.url || b.absUrl()), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.wordpressShare = function(c) {
                    var d = "http://wordpress.com/press-this.php?";
                    c.text && (d += "t=" + encodeURIComponent(c.text) + "&"), c.media && (d += "i=" + encodeURIComponent(c.media) + "&"), d += "u=" + encodeURIComponent(c.url || b.absUrl()), a.open(d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, c.xingShare = function(c) {
                    var d = "";
                    c.follow && (d = "&follow_url=" + encodeURIComponent(c.follow)), a.open("https://www.xing.com/spi/shares/new?url=" + encodeURIComponent(c.url || b.absUrl()) + d, "sharer", "toolbar=0,status=0,width=" + c.popupWidth + ",height=" + c.popupHeight)
                }, d.bind(h.eventTrigger, function() {
                    switch (h.provider) {
                        case "facebook":
                            c.facebookShare(h);
                            break;
                        case "google+":
                            c.googlePlusShare(h);
                            break;
                        case "twitter":
                            c.twitterShare(h);
                            break;
                        case "stumbleupon":
                            c.stumbleuponShare(h);
                            break;
                        case "reddit":
                            c.redditShare(h);
                            break;
                        case "pinterest":
                            c.pinterestShare(h);
                            break;
                        case "linkedin":
                            c.linkedinShare(h);
                            break;
                        case "digg":
                            c.diggShare(h);
                            break;
                        case "tumblr":
                            c.tumblrShare(h);
                            break;
                        case "delicious":
                            c.deliciousShare(h);
                            break;
                        case "vk":
                            c.vkShare(h);
                            break;
                        case "buffer":
                            c.bufferShare(h);
                            break;
                        case "pocket":
                            c.pocketShare(h);
                            break;
                        case "wordpress":
                            c.wordpressShare(h);
                            break;
                        case "flipboard":
                            c.flipboardShare(h);
                            break;
                        case "hackernews":
                            c.hackernewsShare(h);
                            break;
                        case "xing":
                            c.xingShare(h);
                            break;
                        default:
                            return
                    }
                })
            }
        }
    }])
}(angular);;
(function(root, factory) {
    if (typeof module == 'object' && module.exports) module.exports = factory()
    else if (typeof define == 'function' && define.amd) define(factory)
    else root.Spinner = factory()
}(this, function() {
    "use strict"
    var prefixes = ['webkit', 'Moz', 'ms', 'O'],
        animations = {},
        useCssAnimations, sheet

    function createEl(tag, prop) {
        var el = document.createElement(tag || 'div'),
            n
        for (n in prop) el[n] = prop[n]
        return el
    }

    function ins(parent) {
        for (var i = 1, n = arguments.length; i < n; i++) {
            parent.appendChild(arguments[i])
        }
        return parent
    }

    function addAnimation(alpha, trail, i, lines) {
        var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-'),
            start = 0.01 + i / lines * 100,
            z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha),
            prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase(),
            pre = prefix && '-' + prefix + '-' || ''
        if (!animations[name]) {
            sheet.insertRule('@' + pre + 'keyframes ' + name + '{' + '0%{opacity:' + z + '}' + start + '%{opacity:' + alpha + '}' + (start + 0.01) + '%{opacity:1}' + (start + trail) % 100 + '%{opacity:' + alpha + '}' + '100%{opacity:' + z + '}' + '}', sheet.cssRules.length)
            animations[name] = 1
        }
        return name
    }

    function vendor(el, prop) {
        var s = el.style,
            pp, i
        prop = prop.charAt(0).toUpperCase() + prop.slice(1)
        if (s[prop] !== undefined) return prop
        for (i = 0; i < prefixes.length; i++) {
            pp = prefixes[i] + prop
            if (s[pp] !== undefined) return pp
        }
    }

    function css(el, prop) {
        for (var n in prop) {
            el.style[vendor(el, n) || n] = prop[n]
        }
        return el
    }

    function merge(obj) {
        for (var i = 1; i < arguments.length; i++) {
            var def = arguments[i]
            for (var n in def) {
                if (obj[n] === undefined) obj[n] = def[n]
            }
        }
        return obj
    }

    function getColor(color, idx) {
        return typeof color == 'string' ? color : color[idx % color.length]
    }
    var defaults = {
        lines: 12,
        length: 7,
        width: 5,
        radius: 10,
        scale: 1.0,
        corners: 1,
        color: '#000',
        opacity: 1 / 4,
        rotate: 0,
        direction: 1,
        speed: 1,
        trail: 100,
        fps: 20,
        zIndex: 2e9,
        className: 'spinner',
        top: '50%',
        left: '50%',
        shadow: false,
        hwaccel: false,
        position: 'absolute'
    }

    function Spinner(o) {
        this.opts = merge(o || {}, Spinner.defaults, defaults)
    }
    Spinner.defaults = {}
    merge(Spinner.prototype, {
        spin: function(target) {
            this.stop()
            var self = this,
                o = self.opts,
                el = self.el = createEl(null, {
                    className: o.className
                })
            css(el, {
                position: o.position,
                width: 0,
                zIndex: o.zIndex,
                left: o.left,
                top: o.top
            })
            if (target) {
                target.insertBefore(el, target.firstChild || null)
            }
            el.setAttribute('role', 'progressbar')
            self.lines(el, self.opts)
            if (!useCssAnimations) {
                var i = 0,
                    start = (o.lines - 1) * (1 - o.direction) / 2,
                    alpha, fps = o.fps,
                    f = fps / o.speed,
                    ostep = (1 - o.opacity) / (f * o.trail / 100),
                    astep = f / o.lines;
                (function anim() {
                    i++
                    for (var j = 0; j < o.lines; j++) {
                        alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)
                        self.opacity(el, j * o.direction + start, alpha, o)
                    }
                    self.timeout = self.el && setTimeout(anim, ~~(1000 / fps))
                })()
            }
            return self
        },
        stop: function() {
            var el = this.el
            if (el) {
                clearTimeout(this.timeout)
                if (el.parentNode) el.parentNode.removeChild(el)
                this.el = undefined
            }
            return this
        },
        lines: function(el, o) {
            var i = 0,
                start = (o.lines - 1) * (1 - o.direction) / 2,
                seg

            function fill(color, shadow) {
                return css(createEl(), {
                    position: 'absolute',
                    width: o.scale * (o.length + o.width) + 'px',
                    height: o.scale * o.width + 'px',
                    background: color,
                    boxShadow: shadow,
                    transformOrigin: 'left',
                    transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.scale * o.radius + 'px' + ',0)',
                    borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'
                })
            }
            for (; i < o.lines; i++) {
                seg = css(createEl(), {
                    position: 'absolute',
                    top: 1 + ~(o.scale * o.width / 2) + 'px',
                    transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
                    opacity: o.opacity,
                    animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
                })
                if (o.shadow) ins(seg, css(fill('#000', '0 0 4px #000'), {
                    top: '2px'
                }))
                ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))
            }
            return el
        },
        opacity: function(el, i, val) {
            if (i < el.childNodes.length) el.childNodes[i].style.opacity = val
        }
    })

    function initVML() {
        function vml(tag, attr) {
            return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
        }
        sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')
        Spinner.prototype.lines = function(el, o) {
            var r = o.scale * (o.length + o.width),
                s = o.scale * 2 * r

            function grp() {
                return css(vml('group', {
                    coordsize: s + ' ' + s,
                    coordorigin: -r + ' ' + -r
                }), {
                    width: s,
                    height: s
                })
            }
            var margin = -(o.width + o.length) * o.scale * 2 + 'px',
                g = css(grp(), {
                    position: 'absolute',
                    top: margin,
                    left: margin
                }),
                i

            function seg(i, dx, filter) {
                ins(g, ins(css(grp(), {
                    rotation: 360 / o.lines * i + 'deg',
                    left: ~~dx
                }), ins(css(vml('roundrect', {
                    arcsize: o.corners
                }), {
                    width: r,
                    height: o.scale * o.width,
                    left: o.scale * o.radius,
                    top: -o.scale * o.width >> 1,
                    filter: filter
                }), vml('fill', {
                    color: getColor(o.color, i),
                    opacity: o.opacity
                }), vml('stroke', {
                    opacity: 0
                }))))
            }
            if (o.shadow)
                for (i = 1; i <= o.lines; i++) {
                    seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')
                }
            for (i = 1; i <= o.lines; i++) seg(i)
            return ins(el, g)
        }
        Spinner.prototype.opacity = function(el, i, val, o) {
            var c = el.firstChild
            o = o.shadow && o.lines || 0
            if (c && i + o < c.childNodes.length) {
                c = c.childNodes[i + o];
                c = c && c.firstChild;
                c = c && c.firstChild
                if (c) c.opacity = val
            }
        }
    }
    if (typeof document !== 'undefined') {
        sheet = (function() {
            var el = createEl('style', {
                type: 'text/css'
            })
            ins(document.getElementsByTagName('head')[0], el)
            return el.sheet || el.styleSheet
        }())
        var probe = css(createEl('group'), {
            behavior: 'url(#default#VML)'
        })
        if (!vendor(probe, 'transform') && probe.adj) initVML()
        else useCssAnimations = vendor(probe, 'animation')
    }
    return Spinner
}));
var mod;
mod = angular.module('infinite-scroll', []);
mod.value('THROTTLE_MILLISECONDS', null);
mod.directive('infiniteScroll', ['$rootScope', '$window', '$interval', 'THROTTLE_MILLISECONDS', function($rootScope, $window, $interval, THROTTLE_MILLISECONDS) {
    return {
        scope: {
            infiniteScroll: '&',
            infiniteScrollContainer: '=',
            infiniteScrollDistance: '=',
            infiniteScrollDisabled: '=',
            infiniteScrollUseDocumentBottom: '=',
            infiniteScrollListenForEvent: '@'
        },
        link: function(scope, elem, attrs) {
            var changeContainer, checkInterval, checkWhenEnabled, container, handleInfiniteScrollContainer, handleInfiniteScrollDisabled, handleInfiniteScrollDistance, handleInfiniteScrollUseDocumentBottom, handler, height, immediateCheck, offsetTop, pageYOffset, scrollDistance, scrollEnabled, throttle, unregisterEventListener, useDocumentBottom, windowElement;
            windowElement = angular.element($window);
            scrollDistance = null;
            scrollEnabled = null;
            checkWhenEnabled = null;
            container = null;
            immediateCheck = true;
            useDocumentBottom = false;
            unregisterEventListener = null;
            checkInterval = false;
            height = function(elem) {
                elem = elem[0] || elem;
                if (isNaN(elem.offsetHeight)) {
                    return elem.document.documentElement.clientHeight;
                } else {
                    return elem.offsetHeight;
                }
            };
            offsetTop = function(elem) {
                if (!elem[0].getBoundingClientRect || elem.css('none')) {
                    return;
                }
                return elem[0].getBoundingClientRect().top + pageYOffset(elem);
            };
            pageYOffset = function(elem) {
                elem = elem[0] || elem;
                if (isNaN(window.pageYOffset)) {
                    return elem.document.documentElement.scrollTop;
                } else {
                    return elem.ownerDocument.defaultView.pageYOffset;
                }
            };
            handler = function() {
                var containerBottom, containerTopOffset, elementBottom, remaining, shouldScroll;
                if (container === windowElement) {
                    containerBottom = height(container) + pageYOffset(container[0].document.documentElement);
                    elementBottom = offsetTop(elem) + height(elem);
                } else {
                    containerBottom = height(container);
                    containerTopOffset = 0;
                    if (offsetTop(container) !== void 0) {
                        containerTopOffset = offsetTop(container);
                    }
                    elementBottom = offsetTop(elem) - containerTopOffset + height(elem);
                }
                if (useDocumentBottom) {
                    elementBottom = height((elem[0].ownerDocument || elem[0].document).documentElement);
                }
                remaining = elementBottom - containerBottom;
                shouldScroll = remaining <= height(container) * scrollDistance + 1;
                if (shouldScroll) {
                    checkWhenEnabled = true;
                    if (scrollEnabled) {
                        if (scope.$$phase || $rootScope.$$phase) {
                            return scope.infiniteScroll();
                        } else {
                            return scope.$apply(scope.infiniteScroll);
                        }
                    }
                } else {
                    if (checkInterval) {
                        $interval.cancel(checkInterval);
                    }
                    return checkWhenEnabled = false;
                }
            };
            throttle = function(func, wait) {
                var later, previous, timeout;
                timeout = null;
                previous = 0;
                later = function() {
                    var context;
                    previous = new Date().getTime();
                    $interval.cancel(timeout);
                    timeout = null;
                    func.call();
                    return context = null;
                };
                return function() {
                    var now, remaining;
                    now = new Date().getTime();
                    remaining = wait - (now - previous);
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        $interval.cancel(timeout);
                        timeout = null;
                        previous = now;
                        return func.call();
                    } else {
                        if (!timeout) {
                            return timeout = $interval(later, remaining, 1);
                        }
                    }
                };
            };
            if (THROTTLE_MILLISECONDS != null) {
                handler = throttle(handler, THROTTLE_MILLISECONDS);
            }
            scope.$on('$destroy', function() {
                container.unbind('scroll', handler);
                if (unregisterEventListener != null) {
                    unregisterEventListener();
                    return unregisterEventListener = null;
                }
            });
            handleInfiniteScrollDistance = function(v) {
                return scrollDistance = parseFloat(v) || 0;
            };
            scope.$watch('infiniteScrollDistance', handleInfiniteScrollDistance);
            handleInfiniteScrollDistance(scope.infiniteScrollDistance);
            handleInfiniteScrollDisabled = function(v) {
                scrollEnabled = !v;
                if (scrollEnabled && checkWhenEnabled) {
                    checkWhenEnabled = false;
                    return handler();
                }
            };
            scope.$watch('infiniteScrollDisabled', handleInfiniteScrollDisabled);
            handleInfiniteScrollDisabled(scope.infiniteScrollDisabled);
            handleInfiniteScrollUseDocumentBottom = function(v) {
                return useDocumentBottom = v;
            };
            scope.$watch('infiniteScrollUseDocumentBottom', handleInfiniteScrollUseDocumentBottom);
            handleInfiniteScrollUseDocumentBottom(scope.infiniteScrollUseDocumentBottom);
            changeContainer = function(newContainer) {
                if (container != null) {
                    container.unbind('scroll', handler);
                }
                container = newContainer;
                if (newContainer != null) {
                    return container.bind('scroll', handler);
                }
            };
            changeContainer(windowElement);
            if (scope.infiniteScrollListenForEvent) {
                unregisterEventListener = $rootScope.$on(scope.infiniteScrollListenForEvent, handler);
            }
            handleInfiniteScrollContainer = function(newContainer) {
                if ((newContainer == null) || newContainer.length === 0) {
                    return;
                }
                if (newContainer instanceof HTMLElement) {
                    newContainer = angular.element(newContainer);
                } else if (typeof newContainer.append === 'function') {
                    newContainer = angular.element(newContainer[newContainer.length - 1]);
                } else if (typeof newContainer === 'string') {
                    newContainer = angular.element(document.querySelector(newContainer));
                }
                if (newContainer != null) {
                    return changeContainer(newContainer);
                } else {
                    throw new Exception("invalid infinite-scroll-container attribute.");
                }
            };
            scope.$watch('infiniteScrollContainer', handleInfiniteScrollContainer);
            handleInfiniteScrollContainer(scope.infiniteScrollContainer || []);
            if (attrs.infiniteScrollParent != null) {
                changeContainer(angular.element(elem.parent()));
            }
            if (attrs.infiniteScrollImmediateCheck != null) {
                immediateCheck = scope.$eval(attrs.infiniteScrollImmediateCheck);
            }
            return checkInterval = $interval((function() {
                if (immediateCheck) {
                    return handler();
                }
            }), 0);
        }
    };
}]);
(function() {
    'use strict';
    angular.module('jkuri.slimscroll', []).directive('ngSlimscroll', slimScroll);
    slimScroll.$inject = ['$document', '$window', '$compile'];

    function slimScroll($document, $window, $compile) {
        return {
            restrict: 'A',
            scope: true,
            link: linkFn
        };

        function linkFn(scope, element, attrs) {
            setScopeValues(scope, element, attrs);
            var el = element[0];
            var minBarHeight = 30,
                releaseScroll = false,
                touchDiff, minBarWidth = 30;
            element.css({
                'overflow': 'hidden',
                'width': scope.width,
                'height': scope.height
            });
            var wrapper = angular.element('<div></div>');
            wrapper.css({
                'position': 'relative',
                'overflow': 'hidden',
                'width': scope.width,
                'height': scope.height
            });
            var bar = getBaseBar(scope);
            element.wrap(wrapper);
            element.append(bar);
            $compile(bar)(scope);
            element.on('mouseenter', function() {
                if (!scope.horizontalScroll) {
                    scope.getBarHeight();
                } else {
                    scope.getBarWidth();
                }
            });
            element.on('mouseleave', function() {
                if (!scope.alwaysVisible) {
                    bar.css({
                        display: 'none'
                    });
                }
            });
            scope.makeBarDraggable = function() {
                bar.bind('mousedown', function(e) {
                    var top = parseFloat(bar.css('top')),
                        pageY = e.pageY,
                        isDrag = true;
                    $document.bind('mousemove', function(e) {
                        bar.css({
                            'top': top + e.pageY - pageY + 'px'
                        });
                        scope.scrollContent(0, bar[0].offsetTop, false);
                    });
                    $document.bind('mouseup', function(e) {
                        isDrag = false;
                        $document.unbind('mousemove');
                    });
                }).bind('selectstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                });
            };
            scope.makeBarDraggableHorizontal = function() {
                bar.bind('mousedown', function(e) {
                    var left = parseFloat(bar.css('left')),
                        pageX = e.pageX,
                        isDrag = true;
                    $document.bind('mousemove', function(e) {
                        bar.css({
                            'left': left + e.pageX - pageX + 'px'
                        });
                        scope.scrollContentHorizontal(0, bar[0].offsetLeft, false);
                    });
                    $document.bind('mouseup', function(e) {
                        isDrag = false;
                        $document.unbind('mousemove');
                    });
                }).bind('selectstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                });
            };
            scope.getBarHeight = function() {
                var barHeight = Math.max((el.offsetHeight / el.scrollHeight) * el.offsetHeight, minBarHeight);
                var display = barHeight === el.offsetHeight ? 'none' : 'block';
                bar.css({
                    height: barHeight + 'px',
                    display: display
                });
            };
            scope.getBarWidth = function() {
                var barWidth = Math.max((el.offsetWidth / el.scrollWidth) * el.offsetWidth, minBarWidth);
                var display = barWidth === el.offsetWidth ? 'none' : 'block';
                bar.css({
                    width: barWidth + 'px',
                    display: display
                });
            };
            scope.attachWheel = function(target) {
                if ($window.addEventListener) {
                    target.addEventListener('DOMMouseScroll', scope.onWheel, false);
                    target.addEventListener('mousewheel', scope.onWheel, false);
                } else {
                    $document.addEventListener('onmousewheel', scope.onWheel);
                }
            };
            scope.detachWheel = function(target) {
                if ($window.removeEventListener) {
                    target.removeEventListener('DOMMouseScroll', scope.onWheel, false);
                    target.removeEventListener('mousewheel', scope.onWheel, false);
                } else {
                    $document.removeEventListener('onmousewheel', scope.wheel);
                }
            };
            scope.onWheel = function(e) {
                e = e || $window.event;
                var delta = 0;
                if (e.wheelDelta) {
                    delta = -e.wheelDelta / 120;
                }
                if (e.detail) {
                    delta = e.detail / 3;
                }
                if (!scope.horizontalScroll) {
                    scope.scrollContent(delta, true);
                } else {
                    scope.scrollContentHorizontal(delta, true);
                }
                if (e.preventDefault && !releaseScroll) {
                    e.preventDefault();
                }
                if (!releaseScroll) {
                    e.returnValue = false;
                }
            };
            scope.scrollContent = function(y, isWheel) {
                releaseScroll = false;
                var delta = y,
                    maxTop = el.offsetHeight - bar[0].offsetHeight,
                    percentScroll;
                if (isWheel) {
                    delta = parseInt(bar.css('top'), 10) + y * parseInt(scope.wheelStep, 10) / 100 * bar[0].offsetHeight;
                    delta = Math.min(Math.max(delta, 0), maxTop);
                    delta = (y > 0) ? Math.ceil(delta) : Math.floor(delta);
                    bar.css({
                        top: delta + 'px'
                    });
                }
                percentScroll = parseInt(bar.css('top'), 10) / (el.offsetHeight - bar[0].offsetHeight);
                delta = percentScroll * (el.scrollHeight - el.offsetHeight);
                el.scrollTop = delta;
            };
            scope.scrollContentHorizontal = function(x, isWheel) {
                releaseScroll = false;
                var delta = x,
                    maxLeft = el.offsetWidth - bar[0].offsetWidth,
                    percentScroll;
                if (isWheel) {
                    delta = parseInt(bar.css('left'), 10) + x * parseInt(scope.wheelStep, 10) / 100 * bar[0].offsetWidth;
                    delta = Math.min(Math.max(delta, 0), maxLeft);
                    delta = (x > 0) ? Math.ceil(delta) : Math.floor(delta);
                    bar.css({
                        left: delta + 'px'
                    });
                }
                percentScroll = parseInt(bar.css('left'), 10) / (el.offsetWidth - bar[0].offsetWidth);
                delta = percentScroll * (el.scrollWidth - el.offsetWidth);
                el.scrollLeft = delta;
            };
            element.bind('touchstart', function(e, b) {
                if (e.touches.length) {
                    touchDiff = e.touches[0].pageY;
                }
            });
            element.bind('touchmove', function(e) {
                if (!releaseScroll) {
                    e.preventDefault();
                }
                if (e.touches.length) {
                    var diff = (touchDiff - e.touches[0].pageY) / scope.touchScrollStep;
                    if (!scope.horizontalScroll) {
                        scope.scrollContent(diff, true);
                    } else {
                        scope.scrollContentHorizontal(diff, true);
                    }
                    touchDiff = e.touches[0].pageY;
                }
            });
            attrs.$observe('enabled', function() {
                scope.enabled = scope.$eval(attrs.enabled);
                if (scope.enabled === false) {
                    bar.remove();
                    scope.detachWheel(el);
                } else {
                    element.append(bar);
                    scope.attachWheel(el);
                }
            });
            if (scope.watchContent) {
                var contentWatcher = scope.$watch(function() {
                    return element.html();
                }, function() {
                    init();
                });
                scope.$on("$destroy", function() {
                    contentWatcher();
                });
            }

            function init() {
                bar.css('top');
                if (!scope.horizontalScroll) {
                    scope.getBarHeight();
                    scope.makeBarDraggable();
                } else {
                    scope.getBarWidth();
                    scope.makeBarDraggableHorizontal();
                }
                if (!scope.alwaysVisible) {
                    bar.css({
                        display: 'none'
                    });
                }
                scope.attachWheel(el);
                return true;
            }
            init();
        }

        function getBaseBar(scope) {
            var bar, positionCss, commonCssProperty = {
                'background': scope.color,
                'position': 'absolute',
                'opacity': scope.opacity,
                'display': scope.alwaysVisible ? 'block' : 'none',
                'border-radius': scope.borderRadius,
                'z-index': '99',
                'cursor': 'pointer'
            };
            if (scope.horizontalScroll) {
                bar = angular.element('<div ng-mousedown="makeBarDraggableHorizontal($event)"></div>');
                commonCssProperty = angular.extend(commonCssProperty, {
                    'height': scope.size,
                    'left': '0'
                });
                positionCss = (scope.horizontalScrollPosition === 'bottom') ? {
                    bottom: scope.distance
                } : {
                    top: scope.distance
                };
            } else {
                bar = angular.element('<div ng-mousedown="makeBarDraggable($event)""></div>');
                commonCssProperty = angular.extend(commonCssProperty, {
                    'width': scope.size,
                    'top': '0'
                });
                positionCss = (scope.position === 'right') ? {
                    right: scope.distance
                } : {
                    left: scope.distance
                };
            }
            commonCssProperty = angular.extend(commonCssProperty, positionCss);
            bar.css(commonCssProperty);
            return bar;
        }

        function setScopeValues(scope, element, attrs) {
            var height = undefined;
            if (attrs.height !== 0 && attrs.height !== undefined) {
                height = attrs.height;
            } else if (element[0].clientHeight !== 0) {
                height = element[0].clientHeight;
            } else {
                height = 250;
            }
            scope.width = attrs['width'] || element[0].clientWidth || 'auto';
            scope.height = height;
            scope.size = attrs['size'] || '7px';
            scope.color = attrs['color'] || '#000';
            scope.position = attrs['position'] || 'right';
            scope.distance = attrs['distance'] || '1px';
            scope.borderRadius = attrs['borderRadius'] || '3px';
            scope.start = attrs['start'] || 'top';
            scope.alwaysVisible = scope.$eval(attrs['alwaysVisible']) !== false;
            scope.barDraggable = scope.$eval(attrs['barDraggable']) !== false;
            scope.wheelStep = attrs['wheelStep'] || 20;
            scope.opacity = attrs['opacity'] || 0.5;
            scope.enabled = scope.$eval(attrs['enabled']) !== false;
            scope.horizontalScroll = scope.$eval(attrs['horizontalScroll']) || false;
            scope.horizontalScrollPosition = attrs['horizontalScrollPosition'] || 'bottom';
            scope.touchScrollStep = attrs['touchScrollStep'] || 200;
            scope.watchContent = scope.$eval(attrs['watchContent']) || false;
        }
    }
})();
(function(angular) {
    var blkUI = angular.module('blockUI', []);
    blkUI.config(["$provide", "$httpProvider", function($provide, $httpProvider) {
        $provide.decorator('$exceptionHandler', ['$delegate', '$injector', function($delegate, $injector) {
            var blockUI, blockUIConfig;
            return function(exception, cause) {
                blockUIConfig = blockUIConfig || $injector.get('blockUIConfig');
                if (blockUIConfig.resetOnException) {
                    try {
                        blockUI = blockUI || $injector.get('blockUI');
                        blockUI.instances.reset();
                    } catch (ex) {
                        console.log('$exceptionHandler', exception);
                    }
                }
                $delegate(exception, cause);
            };
        }]);
        $httpProvider.interceptors.push('blockUIHttpInterceptor');
    }]);
    blkUI.run(["$document", "blockUIConfig", "$templateCache", function($document, blockUIConfig, $templateCache) {
        if (blockUIConfig.autoInjectBodyBlock) {
            $document.find('body').attr('block-ui', 'main');
        }
        if (blockUIConfig.template) {
            blockUIConfig.templateUrl = '$$block-ui-template$$';
            $templateCache.put(blockUIConfig.templateUrl, blockUIConfig.template);
        }
    }]);

    function moduleLoaded(name) {
        try {
            angular.module(name);
        } catch (ex) {
            return false;
        }
        return true;
    }
    blkUI.config(["$provide", function($provide) {
        $provide.decorator('$location', decorateLocation);
    }]);
    var decorateLocation = ['$delegate', 'blockUI', 'blockUIConfig', function($delegate, blockUI, blockUIConfig) {
        if (blockUIConfig.blockBrowserNavigation) {
            blockUI.$_blockLocationChange = true;
            var overrides = ['url', 'path', 'search', 'hash', 'state'];

            function hook(f) {
                var s = $delegate[f];
                $delegate[f] = function() {
                    var result = s.apply($delegate, arguments);
                    if (result === $delegate) {
                        blockUI.$_blockLocationChange = false;
                    }
                    return result;
                };
            }
            angular.forEach(overrides, hook);
        }
        return $delegate;
    }];

    function blockNavigation($scope, mainBlockUI, blockUIConfig) {
        if (blockUIConfig.blockBrowserNavigation) {
            function registerLocationChange() {
                $scope.$on('$locationChangeStart', function(event) {
                    if (mainBlockUI.$_blockLocationChange && mainBlockUI.state().blockCount > 0) {
                        event.preventDefault();
                    }
                });
                $scope.$on('$locationChangeSuccess', function() {
                    mainBlockUI.$_blockLocationChange = blockUIConfig.blockBrowserNavigation;
                });
            }
            if (moduleLoaded('ngRoute')) {
                var fn = $scope.$on('$viewContentLoaded', function() {
                    fn();
                    registerLocationChange();
                });
            } else {
                registerLocationChange();
            }
        }
    }
    blkUI.directive('blockUiContainer', ["blockUIConfig", "blockUiContainerLinkFn", function(blockUIConfig, blockUiContainerLinkFn) {
        return {
            scope: true,
            restrict: 'A',
            templateUrl: blockUIConfig.templateUrl,
            compile: function($element) {
                return blockUiContainerLinkFn;
            }
        };
    }]).factory('blockUiContainerLinkFn', ["blockUI", "blockUIUtils", function(blockUI, blockUIUtils) {
        return function($scope, $element, $attrs) {
            var srvInstance = $element.inheritedData('block-ui');
            if (!srvInstance) {
                throw new Error('No parent block-ui service instance located.');
            }
            $scope.state = srvInstance.state();
        };
    }]);
    blkUI.directive('blockUi', ["blockUiCompileFn", function(blockUiCompileFn) {
        return {
            scope: true,
            restrict: 'A',
            compile: blockUiCompileFn
        };
    }]).factory('blockUiCompileFn', ["blockUiPreLinkFn", function(blockUiPreLinkFn) {
        return function($element, $attrs) {
            $element.append('<div block-ui-container class="block-ui-container"></div>');
            return {
                pre: blockUiPreLinkFn
            };
        };
    }]).factory('blockUiPreLinkFn', ["blockUI", "blockUIUtils", "blockUIConfig", function(blockUI, blockUIUtils, blockUIConfig) {
        return function($scope, $element, $attrs) {
            if (!$element.hasClass('block-ui')) {
                $element.addClass(blockUIConfig.cssClass);
            }
            $attrs.$observe('blockUiMessageClass', function(value) {
                $scope.$_blockUiMessageClass = value;
            });
            var instanceId = $attrs.blockUi || '_' + $scope.$id;
            var srvInstance = blockUI.instances.get(instanceId);
            if (instanceId === 'main') {
                blockNavigation($scope, srvInstance, blockUIConfig);
            } else {
                var parentInstance = $element.inheritedData('block-ui');
                if (parentInstance) {
                    srvInstance._parent = parentInstance;
                }
            }
            $scope.$on('$destroy', function() {
                srvInstance.release();
            });
            srvInstance.addRef();
            $scope.$_blockUiState = srvInstance.state();
            $scope.$watch('$_blockUiState.blocking', function(value) {
                $element.attr('aria-busy', !!value);
                $element.toggleClass('block-ui-visible', !!value);
            });
            $scope.$watch('$_blockUiState.blockCount > 0', function(value) {
                $element.toggleClass('block-ui-active', !!value);
            });
            var pattern = $attrs.blockUiPattern;
            if (pattern) {
                var regExp = blockUIUtils.buildRegExp(pattern);
                srvInstance.pattern(regExp);
            }
            $element.data('block-ui', srvInstance);
        };
    }]);
    blkUI.constant('blockUIConfig', {
        templateUrl: 'angular-block-ui/angular-block-ui.ng.html',
        delay: 250,
        message: "Loading ...",
        autoBlock: true,
        resetOnException: true,
        requestFilter: angular.noop,
        autoInjectBodyBlock: true,
        cssClass: 'block-ui block-ui-anim-fade',
        blockBrowserNavigation: false
    });
    blkUI.factory('blockUIHttpInterceptor', ["$q", "$injector", "blockUIConfig", "$templateCache", function($q, $injector, blockUIConfig, $templateCache) {
        var blockUI;

        function injectBlockUI() {
            blockUI = blockUI || $injector.get('blockUI');
        }

        function stopBlockUI(config) {
            if (blockUIConfig.autoBlock && (config && !config.$_noBlock && config.$_blocks)) {
                injectBlockUI();
                config.$_blocks.stop();
            }
        }

        function error(rejection) {
            try {
                stopBlockUI(rejection.config);
            } catch (ex) {
                console.log('httpRequestError', ex);
            }
            return $q.reject(rejection);
        }
        return {
            request: function(config) {
                if (blockUIConfig.autoBlock && !(config.method == 'GET' && $templateCache.get(config.url))) {
                    var result = blockUIConfig.requestFilter(config);
                    if (result === false) {
                        config.$_noBlock = true;
                    } else {
                        injectBlockUI();
                        config.$_blocks = blockUI.instances.locate(config);
                        config.$_blocks.start(result);
                    }
                }
                return config;
            },
            requestError: error,
            response: function(response) {
                if (response) {
                    stopBlockUI(response.config);
                }
                return response;
            },
            responseError: error
        };
    }]);
    blkUI.factory('blockUI', ["blockUIConfig", "$timeout", "blockUIUtils", "$document", function(blockUIConfig, $timeout, blockUIUtils, $document) {
        var $body = $document.find('body');
        var reservedStateProperties = ['id', 'blockCount', 'blocking'];

        function BlockUI(id) {
            var self = this;
            var state = {
                    id: id,
                    blockCount: 0,
                    message: blockUIConfig.message,
                    blocking: false
                },
                startPromise, doneCallbacks = [];
            this._id = id;
            this._refs = 0;
            this.start = function(messageOrOptions) {
                messageOrOptions = messageOrOptions || {};
                if (angular.isString(messageOrOptions)) {
                    messageOrOptions = {
                        message: messageOrOptions
                    };
                } else {
                    angular.forEach(reservedStateProperties, function(x) {
                        if (messageOrOptions[x]) {
                            throw new Error('The property ' + x + ' is reserved for the block state.');
                        }
                    });
                }
                angular.extend(state, messageOrOptions);
                if (state.blockCount > 0) {
                    state.message = messageOrOptions.message || state.message || blockUIConfig.message;
                } else {
                    state.message = messageOrOptions.message || blockUIConfig.message;
                }
                state.blockCount++;
                var $ae = angular.element($document[0].activeElement);
                if ($ae.length && blockUIUtils.isElementInBlockScope($ae, self)) {
                    self._restoreFocus = $ae[0];
                    $timeout(function() {
                        if (self._restoreFocus && self._restoreFocus !== $body[0]) {
                            self._restoreFocus.blur();
                        }
                    });
                }
                if (!startPromise && blockUIConfig.delay !== 0) {
                    startPromise = $timeout(block, blockUIConfig.delay);
                } else if (blockUIConfig.delay === 0) {
                    block();
                }

                function block() {
                    startPromise = null;
                    state.blocking = true;
                }
            };
            this._cancelStartTimeout = function() {
                if (startPromise) {
                    $timeout.cancel(startPromise);
                    startPromise = null;
                }
            };
            this.stop = function() {
                state.blockCount = Math.max(0, --state.blockCount);
                if (state.blockCount === 0) {
                    self.reset(true);
                }
            };
            this.isBlocking = function() {
                return state.blocking;
            };
            this.message = function(value) {
                state.message = value;
            };
            this.pattern = function(regexp) {
                if (regexp !== undefined) {
                    self._pattern = regexp;
                }
                return self._pattern;
            };
            this.reset = function(executeCallbacks) {
                self._cancelStartTimeout();
                state.blockCount = 0;
                state.blocking = false;
                if (self._restoreFocus && (!$document[0].activeElement || $document[0].activeElement === $body[0])) {
                    try {
                        self._restoreFocus.focus();
                    } catch (e1) {
                        (function() {
                            var elementToFocus = self._restoreFocus;
                            $timeout(function() {
                                if (elementToFocus) {
                                    try {
                                        elementToFocus.focus();
                                    } catch (e2) {}
                                }
                            }, 100);
                        })();
                    }
                    self._restoreFocus = null;
                }
                try {
                    if (executeCallbacks) {
                        angular.forEach(doneCallbacks, function(cb) {
                            cb();
                        });
                    }
                } finally {
                    doneCallbacks.length = 0;
                }
            };
            this.done = function(fn) {
                doneCallbacks.push(fn);
            };
            this.state = function() {
                return state;
            };
            this.addRef = function() {
                self._refs += 1;
            };
            this.release = function() {
                if (--self._refs <= 0) {
                    mainBlock.instances._destroy(self);
                }
            };
        }
        var instances = [];
        instances.get = function(id) {
            if (!isNaN(id)) {
                throw new Error('BlockUI id cannot be a number');
            }
            var instance = instances[id];
            if (!instance) {
                instance = instances[id] = new BlockUI(id);
                instances.push(instance);
            }
            return instance;
        };
        instances._destroy = function(idOrInstance) {
            if (angular.isString(idOrInstance)) {
                idOrInstance = instances[idOrInstance];
            }
            if (idOrInstance) {
                idOrInstance.reset();
                var i = blockUIUtils.indexOf(instances, idOrInstance);
                instances.splice(i, 1);
                delete instances[idOrInstance.state().id];
            }
        };
        instances.locate = function(request) {
            var result = [];
            blockUIUtils.forEachFnHook(result, 'start');
            blockUIUtils.forEachFnHook(result, 'stop');
            var i = instances.length;
            while (i--) {
                var instance = instances[i];
                var pattern = instance._pattern;
                if (pattern && pattern.test(request.url)) {
                    result.push(instance);
                }
            }
            if (result.length === 0) {
                result.push(mainBlock);
            }
            return result;
        };
        blockUIUtils.forEachFnHook(instances, 'reset');
        var mainBlock = instances.get('main');
        mainBlock.addRef();
        mainBlock.instances = instances;
        return mainBlock;
    }]);
    blkUI.factory('blockUIUtils', function() {
        var $ = angular.element;
        var utils = {
            buildRegExp: function(pattern) {
                var match = pattern.match(/^\/(.*)\/([gim]*)$/),
                    regExp;
                if (match) {
                    regExp = new RegExp(match[1], match[2]);
                } else {
                    throw Error('Incorrect regular expression format: ' + pattern);
                }
                return regExp;
            },
            forEachFn: function(arr, fnName, args) {
                var i = arr.length;
                while (i--) {
                    var t = arr[i];
                    t[fnName].apply(t, args);
                }
            },
            forEachFnHook: function(arr, fnName) {
                arr[fnName] = function() {
                    utils.forEachFn(this, fnName, arguments);
                }
            },
            isElementInBlockScope: function($element, blockScope) {
                var c = $element.inheritedData('block-ui');
                while (c) {
                    if (c === blockScope) {
                        return true;
                    }
                    c = c._parent;
                }
                return false;
            },
            findElement: function($element, predicateFn, traverse) {
                var ret = null;
                if (predicateFn($element)) {
                    ret = $element;
                } else {
                    var $elements;
                    if (traverse) {
                        $elements = $element.parent();
                    } else {
                        $elements = $element.children();
                    }
                    var i = $elements.length;
                    while (!ret && i--) {
                        ret = utils.findElement($($elements[i]), predicateFn, traverse);
                    }
                }
                return ret;
            },
            indexOf: function(arr, obj, start) {
                for (var i = (start || 0), j = arr.length; i < j; i++) {
                    if (arr[i] === obj) {
                        return i;
                    }
                }
                return -1;
            }
        };
        return utils;
    });
    angular.module('blockUI').run(['$templateCache', function($templateCache) {
        $templateCache.put('angular-block-ui/angular-block-ui.ng.html', '<div class=\"block-ui-overlay\"></div><div class=\"block-ui-message-container\" aria-live=\"assertive\" aria-atomic=\"true\"><div class=\"block-ui-message\" ng-class=\"$_blockUiMessageClass\">{{ state.message }}</div></div>');
    }]);
})(angular);
(function(Flow, window, document, undefined) {
    'use strict';
    var extend = Flow.extend;
    var each = Flow.each;

    function addEvent(element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + type, handler);
        } else {
            element["on" + type] = handler;
        }
    }

    function removeEvent(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = null;
        }
    }

    function removeElement(element) {
        element.parentNode.removeChild(element);
    }

    function isFunction(functionToCheck) {
        var getType = {};
        return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
    }

    function FustyFlow(opts) {
        this.support = false;
        this.files = [];
        this.events = [];
        this.defaults = {
            simultaneousUploads: 3,
            fileParameterName: 'file',
            query: {},
            target: '/',
            generateUniqueIdentifier: null,
            matchJSON: false
        };
        var $ = this;
        this.inputChangeEvent = function(event) {
            var input = event.target || event.srcElement;
            removeEvent(input, 'change', $.inputChangeEvent);
            var newClone = input.cloneNode(false);
            input.parentNode.replaceChild(newClone, input);
            $.addFile(input, event);
            newClone.value = '';
            addEvent(newClone, 'change', $.inputChangeEvent);
        };
        this.opts = Flow.extend({}, this.defaults, opts || {});
    }
    FustyFlow.prototype = {
        on: Flow.prototype.on,
        off: Flow.prototype.off,
        fire: Flow.prototype.fire,
        cancel: Flow.prototype.cancel,
        assignBrowse: function(domNodes) {
            if (typeof domNodes.length == 'undefined') {
                domNodes = [domNodes];
            }
            each(domNodes, function(domNode) {
                var input;
                if (domNode.tagName === 'INPUT' && domNode.type === 'file') {
                    input = domNode;
                } else {
                    input = document.createElement('input');
                    input.setAttribute('type', 'file');
                    extend(domNode.style, {
                        display: 'inline-block',
                        position: 'relative',
                        overflow: 'hidden',
                        verticalAlign: 'top'
                    });
                    extend(input.style, {
                        position: 'absolute',
                        top: 0,
                        right: 0,
                        fontFamily: 'Arial',
                        fontSize: '118px',
                        margin: 0,
                        padding: 0,
                        opacity: 0,
                        filter: 'alpha(opacity=0)',
                        cursor: 'pointer'
                    });
                    domNode.appendChild(input);
                }
                addEvent(input, 'change', this.inputChangeEvent);
            }, this);
        },
        assignDrop: function() {},
        unAssignDrop: function() {},
        isUploading: function() {
            var uploading = false;
            each(this.files, function(file) {
                if (file.isUploading()) {
                    uploading = true;
                    return false;
                }
            });
            return uploading;
        },
        upload: function() {
            var files = 0;
            each(this.files, function(file) {
                if (file.progress() == 1 || file.isPaused()) {
                    return;
                }
                if (file.isUploading()) {
                    files++;
                    return;
                }
                if (files++ >= this.opts.simultaneousUploads) {
                    return false;
                }
                if (files == 1) {
                    this.fire('uploadStart');
                }
                file.send();
            }, this);
            if (!files) {
                this.fire('complete');
            }
        },
        pause: function() {
            each(this.files, function(file) {
                file.pause();
            });
        },
        resume: function() {
            each(this.files, function(file) {
                file.resume();
            });
        },
        progress: function() {
            var totalDone = 0;
            var totalFiles = 0;
            each(this.files, function(file) {
                totalDone += file.progress();
                totalFiles++;
            });
            return totalFiles > 0 ? totalDone / totalFiles : 0;
        },
        addFiles: function(elementsList, event) {
            var files = [];
            each(elementsList, function(element) {
                if (element.nodeType === 1 && element.value) {
                    var f = new FustyFlowFile(this, element);
                    if (this.fire('fileAdded', f, event)) {
                        files.push(f);
                    }
                }
            }, this);
            if (this.fire('filesAdded', files, event)) {
                each(files, function(file) {
                    if (this.opts.singleFile && this.files.length > 0) {
                        this.removeFile(this.files[0]);
                    }
                    this.files.push(file);
                }, this);
            }
            this.fire('filesSubmitted', files, event);
        },
        addFile: function(file, event) {
            this.addFiles([file], event);
        },
        generateUniqueIdentifier: function(element) {
            var custom = this.opts.generateUniqueIdentifier;
            if (typeof custom === 'function') {
                return custom(element);
            }
            return 'xxxxxxxx-xxxx-yxxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        },
        getFromUniqueIdentifier: function(uniqueIdentifier) {
            var ret = false;
            each(this.files, function(f) {
                if (f.uniqueIdentifier == uniqueIdentifier) ret = f;
            });
            return ret;
        },
        removeFile: function(file) {
            for (var i = this.files.length - 1; i >= 0; i--) {
                if (this.files[i] === file) {
                    this.files.splice(i, 1);
                }
            }
        },
        getSize: function() {},
        timeRemaining: function() {},
        sizeUploaded: function() {}
    };

    function FustyFlowFile(flowObj, element) {
        this.flowObj = flowObj;
        this.element = element;
        this.name = element.value && element.value.replace(/.*(\/|\\)/, "");
        this.relativePath = this.name;
        this.uniqueIdentifier = flowObj.generateUniqueIdentifier(element);
        this.iFrame = null;
        this.finished = false;
        this.error = false;
        this.paused = false;
        var $ = this;
        this.iFrameLoaded = function(event) {
            if (!$.iFrame || !$.iFrame.parentNode) {
                return;
            }
            $.finished = true;
            try {
                if ($.iFrame.contentDocument && $.iFrame.contentDocument.body && $.iFrame.contentDocument.body.innerHTML == "false") {
                    return;
                }
            } catch (error) {
                $.error = true;
                $.abort();
                $.flowObj.fire('fileError', $, error);
                return;
            }
            var doc = $.iFrame.contentDocument || $.iFrame.contentWindow.document;
            var innerHtml = doc.body.innerHTML;
            if ($.flowObj.opts.matchJSON) {
                innerHtml = /(\{.*\})/.exec(innerHtml)[0];
            }
            $.abort();
            $.flowObj.fire('fileSuccess', $, innerHtml);
            $.flowObj.upload();
        };
        this.bootstrap();
    }
    FustyFlowFile.prototype = {
        getExtension: Flow.FlowFile.prototype.getExtension,
        getType: function() {},
        send: function() {
            if (this.finished) {
                return;
            }
            var o = this.flowObj.opts;
            var form = this.createForm();
            var params = o.query;
            if (isFunction(params)) {
                params = params(this);
            }
            params[o.fileParameterName] = this.element;
            params['flowFilename'] = this.name;
            params['flowRelativePath'] = this.relativePath;
            params['flowIdentifier'] = this.uniqueIdentifier;
            this.addFormParams(form, params);
            addEvent(this.iFrame, 'load', this.iFrameLoaded);
            form.submit();
            removeElement(form);
        },
        abort: function(noupload) {
            if (this.iFrame) {
                this.iFrame.setAttribute('src', 'java' + String.fromCharCode(115) + 'cript:false;');
                removeElement(this.iFrame);
                this.iFrame = null;
                !noupload && this.flowObj.upload();
            }
        },
        cancel: function() {
            this.flowObj.removeFile(this);
            this.abort();
        },
        retry: function() {
            this.bootstrap();
            this.flowObj.upload();
        },
        bootstrap: function() {
            this.abort(true);
            this.finished = false;
            this.error = false;
        },
        timeRemaining: function() {},
        sizeUploaded: function() {},
        resume: function() {
            this.paused = false;
            this.flowObj.upload();
        },
        pause: function() {
            this.paused = true;
            this.abort();
        },
        isUploading: function() {
            return this.iFrame !== null;
        },
        isPaused: function() {
            return this.paused;
        },
        isComplete: function() {
            return this.progress() === 1;
        },
        progress: function() {
            if (this.error) {
                return 1;
            }
            return this.finished ? 1 : 0;
        },
        createIframe: function() {
            var iFrame = (/MSIE (6|7|8)/).test(navigator.userAgent) ? document.createElement('<iframe name="' + this.uniqueIdentifier + '_iframe' + '">') : document.createElement('iframe');
            iFrame.setAttribute('id', this.uniqueIdentifier + '_iframe_id');
            iFrame.setAttribute('name', this.uniqueIdentifier + '_iframe');
            iFrame.style.display = 'none';
            document.body.appendChild(iFrame);
            return iFrame;
        },
        createForm: function() {
            var target = this.flowObj.opts.target;
            if (typeof target === "function") {
                target = target.apply(null);
            }
            var form = document.createElement('form');
            form.encoding = "multipart/form-data";
            form.method = "POST";
            form.setAttribute('action', target);
            if (!this.iFrame) {
                this.iFrame = this.createIframe();
            }
            form.setAttribute('target', this.iFrame.name);
            form.style.display = 'none';
            document.body.appendChild(form);
            return form;
        },
        addFormParams: function(form, params) {
            var input;
            each(params, function(value, key) {
                if (value && value.nodeType === 1) {
                    input = value;
                } else {
                    input = document.createElement('input');
                    input.setAttribute('value', value);
                }
                input.setAttribute('name', key);
                form.appendChild(input);
            });
        }
    };
    FustyFlow.FustyFlowFile = FustyFlowFile;
    if (typeof module !== 'undefined') {
        module.exports = FustyFlow;
    } else if (typeof define === "function" && define.amd) {
        define(function() {
            return FustyFlow;
        });
    } else {
        window.FustyFlow = FustyFlow;
    }
})(window.Flow, window, document);
(function(Flow, FustyFlow, window) {
    'use strict';
    var fustyFlowFactory = function(opts) {
        var flow = new Flow(opts);
        if (flow.support) {
            return flow;
        }
        return new FustyFlow(opts);
    }
    window.fustyFlowFactory = fustyFlowFactory;
})(window.Flow, window.FustyFlow, window);
'format amd';
(function() {
    'use strict';

    function isUndefinedOrNull(val) {
        return angular.isUndefined(val) || val === null;
    }

    function angularMoment(angular, moment) {
        return angular.module('angularMoment', []).constant('angularMomentConfig', {
            preprocess: null,
            timezone: null,
            format: null,
            statefulFilters: true
        }).constant('moment', moment).constant('amTimeAgoConfig', {
            withoutSuffix: false,
            serverTime: null,
            titleFormat: null,
            fullDateThreshold: null,
            fullDateFormat: null
        }).directive('amTimeAgo', ['$window', 'moment', 'amMoment', 'amTimeAgoConfig', function($window, moment, amMoment, amTimeAgoConfig) {
            return function(scope, element, attr) {
                var activeTimeout = null;
                var currentValue;
                var withoutSuffix = amTimeAgoConfig.withoutSuffix;
                var titleFormat = amTimeAgoConfig.titleFormat;
                var fullDateThreshold = amTimeAgoConfig.fullDateThreshold;
                var fullDateFormat = amTimeAgoConfig.fullDateFormat;
                var localDate = new Date().getTime();
                var modelName = attr.amTimeAgo;
                var currentFrom;
                var isTimeElement = ('TIME' === element[0].nodeName.toUpperCase());

                function getNow() {
                    var now;
                    if (currentFrom) {
                        now = currentFrom;
                    } else if (amTimeAgoConfig.serverTime) {
                        var localNow = new Date().getTime();
                        var nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
                        now = moment(nowMillis);
                    } else {
                        now = moment();
                    }
                    return now;
                }

                function cancelTimer() {
                    if (activeTimeout) {
                        $window.clearTimeout(activeTimeout);
                        activeTimeout = null;
                    }
                }

                function updateTime(momentInstance) {
                    var daysAgo = getNow().diff(momentInstance, 'day');
                    var showFullDate = fullDateThreshold && daysAgo >= fullDateThreshold;
                    if (showFullDate) {
                        element.text(momentInstance.format(fullDateFormat));
                    } else {
                        element.text(momentInstance.from(getNow(), withoutSuffix));
                    }
                    if (titleFormat && !element.attr('title')) {
                        element.attr('title', momentInstance.local().format(titleFormat));
                    }
                    if (!showFullDate) {
                        var howOld = Math.abs(getNow().diff(momentInstance, 'minute'));
                        var secondsUntilUpdate = 3600;
                        if (howOld < 1) {
                            secondsUntilUpdate = 1;
                        } else if (howOld < 60) {
                            secondsUntilUpdate = 30;
                        } else if (howOld < 180) {
                            secondsUntilUpdate = 300;
                        }
                        activeTimeout = $window.setTimeout(function() {
                            updateTime(momentInstance);
                        }, secondsUntilUpdate * 1000);
                    }
                }

                function updateDateTimeAttr(value) {
                    if (isTimeElement) {
                        element.attr('datetime', value);
                    }
                }

                function updateMoment() {
                    cancelTimer();
                    if (currentValue) {
                        var momentValue = amMoment.preprocessDate(currentValue);
                        updateTime(momentValue);
                        updateDateTimeAttr(momentValue.toISOString());
                    }
                }
                scope.$watch(modelName, function(value) {
                    if (isUndefinedOrNull(value) || (value === '')) {
                        cancelTimer();
                        if (currentValue) {
                            element.text('');
                            updateDateTimeAttr('');
                            currentValue = null;
                        }
                        return;
                    }
                    currentValue = value;
                    updateMoment();
                });
                if (angular.isDefined(attr.amFrom)) {
                    scope.$watch(attr.amFrom, function(value) {
                        if (isUndefinedOrNull(value) || (value === '')) {
                            currentFrom = null;
                        } else {
                            currentFrom = moment(value);
                        }
                        updateMoment();
                    });
                }
                if (angular.isDefined(attr.amWithoutSuffix)) {
                    scope.$watch(attr.amWithoutSuffix, function(value) {
                        if (typeof value === 'boolean') {
                            withoutSuffix = value;
                            updateMoment();
                        } else {
                            withoutSuffix = amTimeAgoConfig.withoutSuffix;
                        }
                    });
                }
                attr.$observe('amFullDateThreshold', function(newValue) {
                    fullDateThreshold = newValue;
                    updateMoment();
                });
                attr.$observe('amFullDateFormat', function(newValue) {
                    fullDateFormat = newValue;
                    updateMoment();
                });
                scope.$on('$destroy', function() {
                    cancelTimer();
                });
                scope.$on('amMoment:localeChanged', function() {
                    updateMoment();
                });
            };
        }]).service('amMoment', ['moment', '$rootScope', '$log', 'angularMomentConfig', function(moment, $rootScope, $log, angularMomentConfig) {
            var defaultTimezone = null;
            this.changeLocale = function(locale, customization) {
                var result = moment.locale(locale, customization);
                if (angular.isDefined(locale)) {
                    $rootScope.$broadcast('amMoment:localeChanged');
                }
                return result;
            };
            this.changeTimezone = function(timezone) {
                if (moment.tz && moment.tz.setDefault) {
                    moment.tz.setDefault(timezone);
                    $rootScope.$broadcast('amMoment:timezoneChanged');
                } else {
                    $log.warn('angular-moment: changeTimezone() works only with moment-timezone.js v0.3.0 or greater.');
                }
                angularMomentConfig.timezone = timezone;
                defaultTimezone = timezone;
            };
            this.preprocessDate = function(value) {
                if (defaultTimezone !== angularMomentConfig.timezone) {
                    this.changeTimezone(angularMomentConfig.timezone);
                }
                if (angularMomentConfig.preprocess) {
                    return angularMomentConfig.preprocess(value);
                }
                if (!isNaN(parseFloat(value)) && isFinite(value)) {
                    return moment(parseInt(value, 10));
                }
                return moment(value);
            };
        }]).filter('amParse', ['moment', function(moment) {
            return function(value, format) {
                return moment(value, format);
            };
        }]).filter('amFromUnix', ['moment', function(moment) {
            return function(value) {
                return moment.unix(value);
            };
        }]).filter('amUtc', ['moment', function(moment) {
            return function(value) {
                return moment.utc(value);
            };
        }]).filter('amUtcOffset', ['amMoment', function(amMoment) {
            function amUtcOffset(value, offset) {
                return amMoment.preprocessDate(value).utcOffset(offset);
            }
            return amUtcOffset;
        }]).filter('amLocal', ['moment', function(moment) {
            return function(value) {
                return moment.isMoment(value) ? value.local() : null;
            };
        }]).filter('amTimezone', ['amMoment', 'angularMomentConfig', '$log', function(amMoment, angularMomentConfig, $log) {
            function amTimezone(value, timezone) {
                var aMoment = amMoment.preprocessDate(value);
                if (!timezone) {
                    return aMoment;
                }
                if (aMoment.tz) {
                    return aMoment.tz(timezone);
                } else {
                    $log.warn('angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js ?');
                    return aMoment;
                }
            }
            return amTimezone;
        }]).filter('amCalendar', ['moment', 'amMoment', 'angularMomentConfig', function(moment, amMoment, angularMomentConfig) {
            function amCalendarFilter(value) {
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                var date = amMoment.preprocessDate(value);
                return date.isValid() ? date.calendar() : '';
            }
            amCalendarFilter.$stateful = angularMomentConfig.statefulFilters;
            return amCalendarFilter;
        }]).filter('amDifference', ['moment', 'amMoment', 'angularMomentConfig', function(moment, amMoment, angularMomentConfig) {
            function amDifferenceFilter(value, otherValue, unit, usePrecision) {
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                var date = amMoment.preprocessDate(value);
                var date2 = !isUndefinedOrNull(otherValue) ? amMoment.preprocessDate(otherValue) : moment();
                if (!date.isValid() || !date2.isValid()) {
                    return '';
                }
                return date.diff(date2, unit, usePrecision);
            }
            amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDifferenceFilter;
        }]).filter('amDateFormat', ['moment', 'amMoment', 'angularMomentConfig', function(moment, amMoment, angularMomentConfig) {
            function amDateFormatFilter(value, format) {
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                var date = amMoment.preprocessDate(value);
                if (!date.isValid()) {
                    return '';
                }
                return date.format(format);
            }
            amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDateFormatFilter;
        }]).filter('amDurationFormat', ['moment', 'angularMomentConfig', function(moment, angularMomentConfig) {
            function amDurationFormatFilter(value, format, suffix) {
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                return moment.duration(value, format).humanize(suffix);
            }
            amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters;
            return amDurationFormatFilter;
        }]).filter('amTimeAgo', ['moment', 'amMoment', 'angularMomentConfig', function(moment, amMoment, angularMomentConfig) {
            function amTimeAgoFilter(value, suffix, from) {
                var date, dateFrom;
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                value = amMoment.preprocessDate(value);
                date = moment(value);
                if (!date.isValid()) {
                    return '';
                }
                dateFrom = moment(from);
                if (!isUndefinedOrNull(from) && dateFrom.isValid()) {
                    return date.from(dateFrom, suffix);
                }
                return date.fromNow(suffix);
            }
            amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters;
            return amTimeAgoFilter;
        }]).filter('amSubtract', ['moment', 'angularMomentConfig', function(moment, angularMomentConfig) {
            function amSubtractFilter(value, amount, type) {
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                return moment(value).subtract(parseInt(amount, 10), type);
            }
            amSubtractFilter.$stateful = angularMomentConfig.statefulFilters;
            return amSubtractFilter;
        }]).filter('amAdd', ['moment', 'angularMomentConfig', function(moment, angularMomentConfig) {
            function amAddFilter(value, amount, type) {
                if (isUndefinedOrNull(value)) {
                    return '';
                }
                return moment(value).add(parseInt(amount, 10), type);
            }
            amAddFilter.$stateful = angularMomentConfig.statefulFilters;
            return amAddFilter;
        }]);
    }
    if (typeof define === 'function' && define.amd) {
        define(['angular', 'moment'], angularMoment);
    } else if (typeof module !== 'undefined' && module && module.exports) {
        angularMoment(require('angular'), require('moment'));
        module.exports = 'angularMoment';
    } else {
        angularMoment(angular, (typeof global !== 'undefined' ? global : window).moment);
    }
})();
(function() {
    'use strict';
    angular.module('ui.mask', []).value('uiMaskConfig', {
        maskDefinitions: {
            '9': /\d/,
            'A': /[a-zA-Z]/,
            '*': /[a-zA-Z0-9]/
        },
        clearOnBlur: true,
        eventsToHandle: ['input', 'keyup', 'click', 'focus']
    }).directive('uiMask', ['uiMaskConfig', function(maskConfig) {
        function isFocused(elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        }
        return {
            priority: 100,
            require: 'ngModel',
            restrict: 'A',
            compile: function uiMaskCompilingFunction() {
                var options = maskConfig;
                return function uiMaskLinkingFunction(scope, iElement, iAttrs, controller) {
                    var maskProcessed = false,
                        eventsBound = false,
                        maskCaretMap, maskPatterns, maskPlaceholder, maskComponents, minRequiredLength, value, valueMasked, isValid, originalPlaceholder = iAttrs.placeholder,
                        originalMaxlength = iAttrs.maxlength,
                        oldValue, oldValueUnmasked, oldCaretPosition, oldSelectionLength;
                    var originalIsEmpty = controller.$isEmpty;
                    controller.$isEmpty = function(value) {
                        if (maskPatterns) {
                            return originalIsEmpty(unmaskValue(value || ''));
                        } else {
                            return originalIsEmpty(value);
                        }
                    };

                    function initialize(maskAttr) {
                        if (!angular.isDefined(maskAttr)) {
                            return uninitialize();
                        }
                        processRawMask(maskAttr);
                        if (!maskProcessed) {
                            return uninitialize();
                        }
                        initializeElement();
                        bindEventListeners();
                        return true;
                    }

                    function initPlaceholder(placeholderAttr) {
                        if (!placeholderAttr) {
                            return;
                        }
                        maskPlaceholder = placeholderAttr;
                        if (maskProcessed) {
                            iElement.val(maskValue(unmaskValue(iElement.val())));
                        }
                    }

                    function initPlaceholderChar() {
                        return initialize(iAttrs.uiMask);
                    }
                    var modelViewValue = false;
                    iAttrs.$observe('modelViewValue', function(val) {
                        if (val === 'true') {
                            modelViewValue = true;
                        }
                    });

                    function formatter(fromModelValue) {
                        if (!maskProcessed) {
                            return fromModelValue;
                        }
                        value = unmaskValue(fromModelValue || '');
                        isValid = validateValue(value);
                        controller.$setValidity('mask', isValid);
                        return isValid && value.length ? maskValue(value) : undefined;
                    }

                    function parser(fromViewValue) {
                        if (!maskProcessed) {
                            return fromViewValue;
                        }
                        value = unmaskValue(fromViewValue || '');
                        isValid = validateValue(value);
                        controller.$viewValue = value.length ? maskValue(value) : '';
                        controller.$setValidity('mask', isValid);
                        if (isValid) {
                            return modelViewValue ? controller.$viewValue : value;
                        } else {
                            return undefined;
                        }
                    }
                    var linkOptions = {};
                    if (iAttrs.uiOptions) {
                        linkOptions = scope.$eval('[' + iAttrs.uiOptions + ']');
                        if (angular.isObject(linkOptions[0])) {
                            linkOptions = (function(original, current) {
                                for (var i in original) {
                                    if (Object.prototype.hasOwnProperty.call(original, i)) {
                                        if (current[i] === undefined) {
                                            current[i] = angular.copy(original[i]);
                                        } else {
                                            if (angular.isObject(current[i]) && !angular.isArray(current[i])) {
                                                current[i] = angular.extend({}, original[i], current[i]);
                                            }
                                        }
                                    }
                                }
                                return current;
                            })(options, linkOptions[0]);
                        } else {
                            linkOptions = options;
                        }
                    } else {
                        linkOptions = options;
                    }
                    iAttrs.$observe('uiMask', initialize);
                    if (angular.isDefined(iAttrs.uiMaskPlaceholder)) {
                        iAttrs.$observe('uiMaskPlaceholder', initPlaceholder);
                    } else {
                        iAttrs.$observe('placeholder', initPlaceholder);
                    }
                    if (angular.isDefined(iAttrs.uiMaskPlaceholderChar)) {
                        iAttrs.$observe('uiMaskPlaceholderChar', initPlaceholderChar);
                    }
                    controller.$formatters.push(formatter);
                    controller.$parsers.push(parser);

                    function uninitialize() {
                        maskProcessed = false;
                        unbindEventListeners();
                        if (angular.isDefined(originalPlaceholder)) {
                            iElement.attr('placeholder', originalPlaceholder);
                        } else {
                            iElement.removeAttr('placeholder');
                        }
                        if (angular.isDefined(originalMaxlength)) {
                            iElement.attr('maxlength', originalMaxlength);
                        } else {
                            iElement.removeAttr('maxlength');
                        }
                        iElement.val(controller.$modelValue);
                        controller.$viewValue = controller.$modelValue;
                        return false;
                    }

                    function initializeElement() {
                        value = oldValueUnmasked = unmaskValue(controller.$modelValue || '');
                        valueMasked = oldValue = maskValue(value);
                        isValid = validateValue(value);
                        if (iAttrs.maxlength) {
                            iElement.attr('maxlength', maskCaretMap[maskCaretMap.length - 1] * 2);
                        }
                        if (!originalPlaceholder) {
                            iElement.attr('placeholder', maskPlaceholder);
                        }
                        var viewValue = controller.$modelValue;
                        var idx = controller.$formatters.length;
                        while (idx--) {
                            viewValue = controller.$formatters[idx](viewValue);
                        }
                        controller.$viewValue = viewValue || '';
                        controller.$render();
                    }

                    function bindEventListeners() {
                        if (eventsBound) {
                            return;
                        }
                        iElement.bind('blur', blurHandler);
                        iElement.bind('mousedown mouseup', mouseDownUpHandler);
                        iElement.bind(linkOptions.eventsToHandle.join(' '), eventHandler);
                        eventsBound = true;
                    }

                    function unbindEventListeners() {
                        if (!eventsBound) {
                            return;
                        }
                        iElement.unbind('blur', blurHandler);
                        iElement.unbind('mousedown', mouseDownUpHandler);
                        iElement.unbind('mouseup', mouseDownUpHandler);
                        iElement.unbind('input', eventHandler);
                        iElement.unbind('keyup', eventHandler);
                        iElement.unbind('click', eventHandler);
                        iElement.unbind('focus', eventHandler);
                        eventsBound = false;
                    }

                    function validateValue(value) {
                        return value.length ? value.length >= minRequiredLength : true;
                    }

                    function unmaskValue(value) {
                        var valueUnmasked = '',
                            maskPatternsCopy = maskPatterns.slice();
                        value = value.toString();
                        angular.forEach(maskComponents, function(component) {
                            value = value.replace(component, '');
                        });
                        angular.forEach(value.split(''), function(chr) {
                            if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                                valueUnmasked += chr;
                                maskPatternsCopy.shift();
                            }
                        });
                        return valueUnmasked;
                    }

                    function maskValue(unmaskedValue) {
                        var valueMasked = '',
                            maskCaretMapCopy = maskCaretMap.slice();
                        angular.forEach(maskPlaceholder.split(''), function(chr, i) {
                            if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                                valueMasked += unmaskedValue.charAt(0) || '_';
                                unmaskedValue = unmaskedValue.substr(1);
                                maskCaretMapCopy.shift();
                            } else {
                                valueMasked += chr;
                            }
                        });
                        return valueMasked;
                    }

                    function getPlaceholderChar(i) {
                        var placeholder = angular.isDefined(iAttrs.uiMaskPlaceholder) ? iAttrs.uiMaskPlaceholder : iAttrs.placeholder,
                            defaultPlaceholderChar;
                        if (angular.isDefined(placeholder) && placeholder[i]) {
                            return placeholder[i];
                        } else {
                            defaultPlaceholderChar = angular.isDefined(iAttrs.uiMaskPlaceholderChar) && iAttrs.uiMaskPlaceholderChar ? iAttrs.uiMaskPlaceholderChar : '_';
                            return (defaultPlaceholderChar.toLowerCase() === 'space') ? ' ' : defaultPlaceholderChar[0];
                        }
                    }

                    function getMaskComponents() {
                        return maskPlaceholder.replace(/[_]+/g, '_').replace(/([^_]+)([a-zA-Z0-9])([^_])/g, '$1$2_$3').split('_');
                    }

                    function processRawMask(mask) {
                        var characterCount = 0;
                        maskCaretMap = [];
                        maskPatterns = [];
                        maskPlaceholder = '';
                        if (angular.isString(mask)) {
                            minRequiredLength = 0;
                            var isOptional = false,
                                numberOfOptionalCharacters = 0,
                                splitMask = mask.split('');
                            angular.forEach(splitMask, function(chr, i) {
                                if (linkOptions.maskDefinitions[chr]) {
                                    maskCaretMap.push(characterCount);
                                    maskPlaceholder += getPlaceholderChar(i - numberOfOptionalCharacters);
                                    maskPatterns.push(linkOptions.maskDefinitions[chr]);
                                    characterCount++;
                                    if (!isOptional) {
                                        minRequiredLength++;
                                    }
                                    isOptional = false;
                                } else if (chr === '?') {
                                    isOptional = true;
                                    numberOfOptionalCharacters++;
                                } else {
                                    maskPlaceholder += chr;
                                    characterCount++;
                                }
                            });
                        }
                        maskCaretMap.push(maskCaretMap.slice().pop() + 1);
                        maskComponents = getMaskComponents();
                        maskProcessed = maskCaretMap.length > 1 ? true : false;
                    }
                    var prevValue = iElement.val();

                    function blurHandler() {
                        if (linkOptions.clearOnBlur) {
                            oldCaretPosition = 0;
                            oldSelectionLength = 0;
                            if (!isValid || value.length === 0) {
                                valueMasked = '';
                                iElement.val('');
                                scope.$apply(function() {
                                    controller.$viewValue = '';
                                });
                            }
                        }
                        if (value !== prevValue) {
                            triggerChangeEvent(iElement[0]);
                        }
                        prevValue = value;
                    }

                    function triggerChangeEvent(element) {
                        var change;
                        if (angular.isFunction(window.Event) && !element.fireEvent) {
                            change = new Event('change', {
                                view: window,
                                bubbles: true,
                                cancelable: false
                            });
                            element.dispatchEvent(change);
                        } else if ('createEvent' in document) {
                            change = document.createEvent('HTMLEvents');
                            change.initEvent('change', false, true);
                            element.dispatchEvent(change);
                        } else if (element.fireEvent) {
                            element.fireEvent('onchange');
                        }
                    }

                    function mouseDownUpHandler(e) {
                        if (e.type === 'mousedown') {
                            iElement.bind('mouseout', mouseoutHandler);
                        } else {
                            iElement.unbind('mouseout', mouseoutHandler);
                        }
                    }
                    iElement.bind('mousedown mouseup', mouseDownUpHandler);

                    function mouseoutHandler() {
                        oldSelectionLength = getSelectionLength(this);
                        iElement.unbind('mouseout', mouseoutHandler);
                    }

                    function eventHandler(e) {
                        e = e || {};
                        var eventWhich = e.which,
                            eventType = e.type;
                        if (eventWhich === 16 || eventWhich === 91) {
                            return;
                        }
                        var val = iElement.val(),
                            valOld = oldValue,
                            valMasked, valAltered = false,
                            valUnmasked = unmaskValue(val),
                            valUnmaskedOld = oldValueUnmasked,
                            caretPos = getCaretPosition(this) || 0,
                            caretPosOld = oldCaretPosition || 0,
                            caretPosDelta = caretPos - caretPosOld,
                            caretPosMin = maskCaretMap[0],
                            caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(),
                            selectionLenOld = oldSelectionLength || 0,
                            isSelected = getSelectionLength(this) > 0,
                            wasSelected = selectionLenOld > 0,
                            isAddition = (val.length > valOld.length) || (selectionLenOld && val.length > valOld.length - selectionLenOld),
                            isDeletion = (val.length < valOld.length) || (selectionLenOld && val.length === valOld.length - selectionLenOld),
                            isSelection = (eventWhich >= 37 && eventWhich <= 40) && e.shiftKey,
                            isKeyLeftArrow = eventWhich === 37,
                            isKeyBackspace = eventWhich === 8 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === -1)),
                            isKeyDelete = eventWhich === 46 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === 0) && !wasSelected),
                            caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === 'click') && caretPos > caretPosMin;
                        oldSelectionLength = getSelectionLength(this);
                        if (isSelection || (isSelected && (eventType === 'click' || eventType === 'keyup'))) {
                            return;
                        }
                        if ((eventType === 'input') && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
                            while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                                caretPos--;
                            }
                            while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                                caretPos++;
                            }
                            var charIndex = maskCaretMap.indexOf(caretPos);
                            valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
                            valAltered = true;
                        }
                        valMasked = maskValue(valUnmasked);
                        oldValue = valMasked;
                        oldValueUnmasked = valUnmasked;
                        if (!valAltered && val.length > valMasked.length) valAltered = true;
                        iElement.val(valMasked);
                        if (valAltered) {
                            scope.$apply(function() {
                                controller.$setViewValue(valUnmasked);
                            });
                        }
                        if (isAddition && (caretPos <= caretPosMin)) {
                            caretPos = caretPosMin + 1;
                        }
                        if (caretBumpBack) {
                            caretPos--;
                        }
                        caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;
                        while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
                            caretPos += caretBumpBack ? -1 : 1;
                        }
                        if ((caretBumpBack && caretPos < caretPosMax) || (isAddition && !isValidCaretPosition(caretPosOld))) {
                            caretPos++;
                        }
                        oldCaretPosition = caretPos;
                        setCaretPosition(this, caretPos);
                    }

                    function isValidCaretPosition(pos) {
                        return maskCaretMap.indexOf(pos) > -1;
                    }

                    function getCaretPosition(input) {
                        if (!input) return 0;
                        if (input.selectionStart !== undefined) {
                            return input.selectionStart;
                        } else if (document.selection) {
                            if (isFocused(iElement[0])) {
                                input.focus();
                                var selection = document.selection.createRange();
                                selection.moveStart('character', input.value ? -input.value.length : 0);
                                return selection.text.length;
                            }
                        }
                        return 0;
                    }

                    function setCaretPosition(input, pos) {
                        if (!input) return 0;
                        if (input.offsetWidth === 0 || input.offsetHeight === 0) {
                            return;
                        }
                        if (input.setSelectionRange) {
                            if (isFocused(iElement[0])) {
                                input.focus();
                                input.setSelectionRange(pos, pos);
                            }
                        } else if (input.createTextRange) {
                            var range = input.createTextRange();
                            range.collapse(true);
                            range.moveEnd('character', pos);
                            range.moveStart('character', pos);
                            range.select();
                        }
                    }

                    function getSelectionLength(input) {
                        if (!input) return 0;
                        if (input.selectionStart !== undefined) {
                            return (input.selectionEnd - input.selectionStart);
                        }
                        if (document.selection) {
                            return (document.selection.createRange().text.length);
                        }
                        return 0;
                    }
                    if (!Array.prototype.indexOf) {
                        Array.prototype.indexOf = function(searchElement) {
                            if (this === null) {
                                throw new TypeError();
                            }
                            var t = Object(this);
                            var len = t.length >>> 0;
                            if (len === 0) {
                                return -1;
                            }
                            var n = 0;
                            if (arguments.length > 1) {
                                n = Number(arguments[1]);
                                if (n !== n) {
                                    n = 0;
                                } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                                }
                            }
                            if (n >= len) {
                                return -1;
                            }
                            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
                            for (; k < len; k++) {
                                if (k in t && t[k] === searchElement) {
                                    return k;
                                }
                            }
                            return -1;
                        };
                    }
                };
            }
        };
    }]);
}());;
(function(window, angular, undefined) {
    'use strict';
    (function() {
        angular.module('uiGmapgoogle-maps.providers', ['nemLogging']);
        angular.module('uiGmapgoogle-maps.wrapped', []);
        angular.module('uiGmapgoogle-maps.extensions', ['uiGmapgoogle-maps.wrapped', 'uiGmapgoogle-maps.providers']);
        angular.module('uiGmapgoogle-maps.directives.api.utils', ['uiGmapgoogle-maps.extensions']);
        angular.module('uiGmapgoogle-maps.directives.api.managers', []);
        angular.module('uiGmapgoogle-maps.directives.api.options', ['uiGmapgoogle-maps.directives.api.utils']);
        angular.module('uiGmapgoogle-maps.directives.api.options.builders', []);
        angular.module('uiGmapgoogle-maps.directives.api.models.child', ['uiGmapgoogle-maps.directives.api.utils', 'uiGmapgoogle-maps.directives.api.options', 'uiGmapgoogle-maps.directives.api.options.builders']);
        angular.module('uiGmapgoogle-maps.directives.api.models.parent', ['uiGmapgoogle-maps.directives.api.managers', 'uiGmapgoogle-maps.directives.api.models.child', 'uiGmapgoogle-maps.providers']);
        angular.module('uiGmapgoogle-maps.directives.api', ['uiGmapgoogle-maps.directives.api.models.parent']);
        angular.module('uiGmapgoogle-maps', ['uiGmapgoogle-maps.directives.api', 'uiGmapgoogle-maps.providers']);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.providers').factory('uiGmapMapScriptLoader', ['$q', 'uiGmapuuid', function($q, uuid) {
            var getScriptUrl, includeScript, isGoogleMapsLoaded, scriptId;
            scriptId = void 0;
            getScriptUrl = function(options) {
                if (options.china) {
                    return 'http://maps.google.cn/maps/api/js?';
                } else {
                    if (options.transport === 'auto') {
                        return '//maps.googleapis.com/maps/api/js?';
                    } else {
                        return options.transport + '://maps.googleapis.com/maps/api/js?';
                    }
                }
            };
            includeScript = function(options) {
                var omitOptions, query, script;
                omitOptions = ['transport', 'isGoogleMapsForWork', 'china'];
                if (options.isGoogleMapsForWork) {
                    omitOptions.push('key');
                }
                query = _.map(_.omit(options, omitOptions), function(v, k) {
                    return k + '=' + v;
                });
                if (scriptId) {
                    document.getElementById(scriptId).remove();
                }
                query = query.join('&');
                script = document.createElement('script');
                script.id = scriptId = "ui_gmap_map_load_" + (uuid.generate());
                script.type = 'text/javascript';
                script.src = getScriptUrl(options) + query;
                return document.body.appendChild(script);
            };
            isGoogleMapsLoaded = function() {
                return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
            };
            return {
                load: function(options) {
                    var deferred, randomizedFunctionName;
                    deferred = $q.defer();
                    if (isGoogleMapsLoaded()) {
                        deferred.resolve(window.google.maps);
                        return deferred.promise;
                    }
                    randomizedFunctionName = options.callback = 'onGoogleMapsReady' + Math.round(Math.random() * 1000);
                    window[randomizedFunctionName] = function() {
                        window[randomizedFunctionName] = null;
                        deferred.resolve(window.google.maps);
                    };
                    if (window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE) {
                        document.addEventListener('online', function() {
                            if (!isGoogleMapsLoaded()) {
                                return includeScript(options);
                            }
                        });
                    } else {
                        includeScript(options);
                    }
                    return deferred.promise;
                }
            };
        }]).provider('uiGmapGoogleMapApi', function() {
            this.options = {
                transport: 'https',
                isGoogleMapsForWork: false,
                china: false,
                v: '3',
                libraries: '',
                language: 'en',
                sensor: 'false'
            };
            this.configure = function(options) {
                angular.extend(this.options, options);
            };
            this.$get = ['uiGmapMapScriptLoader', (function(_this) {
                return function(loader) {
                    return loader.load(_this.options);
                };
            })(this)];
            return this;
        });
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.extensions').service('uiGmapExtendGWin', function() {
            return {
                init: _.once(function() {
                    var uiGmapInfoBox;
                    if (!(google || (typeof google !== "undefined" && google !== null ? google.maps : void 0) || (google.maps.InfoWindow != null))) {
                        return;
                    }
                    google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
                    google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
                    google.maps.InfoWindow.prototype._isOpen = false;
                    google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
                        if (recurse != null) {
                            return;
                        }
                        this._isOpen = true;
                        this._open(map, anchor, true);
                    };
                    google.maps.InfoWindow.prototype.close = function(recurse) {
                        if (recurse != null) {
                            return;
                        }
                        this._isOpen = false;
                        this._close(true);
                    };
                    google.maps.InfoWindow.prototype.isOpen = function(val) {
                        if (val == null) {
                            val = void 0;
                        }
                        if (val == null) {
                            return this._isOpen;
                        } else {
                            return this._isOpen = val;
                        }
                    };
                    if (window.InfoBox) {
                        window.InfoBox.prototype._open = window.InfoBox.prototype.open;
                        window.InfoBox.prototype._close = window.InfoBox.prototype.close;
                        window.InfoBox.prototype._isOpen = false;
                        window.InfoBox.prototype.open = function(map, anchor) {
                            this._isOpen = true;
                            this._open(map, anchor);
                        };
                        window.InfoBox.prototype.close = function() {
                            this._isOpen = false;
                            this._close();
                        };
                        window.InfoBox.prototype.isOpen = function(val) {
                            if (val == null) {
                                val = void 0;
                            }
                            if (val == null) {
                                return this._isOpen;
                            } else {
                                return this._isOpen = val;
                            }
                        };
                        uiGmapInfoBox = (function(superClass) {
                            extend(uiGmapInfoBox, superClass);

                            function uiGmapInfoBox(opts) {
                                this.getOrigCloseBoxImg_ = bind(this.getOrigCloseBoxImg_, this);
                                this.getCloseBoxDiv_ = bind(this.getCloseBoxDiv_, this);
                                var box;
                                box = new window.InfoBox(opts);
                                _.extend(this, box);
                                if (opts.closeBoxDiv != null) {
                                    this.closeBoxDiv_ = opts.closeBoxDiv;
                                }
                            }
                            uiGmapInfoBox.prototype.getCloseBoxDiv_ = function() {
                                return this.closeBoxDiv_;
                            };
                            uiGmapInfoBox.prototype.getCloseBoxImg_ = function() {
                                var div, img;
                                div = this.getCloseBoxDiv_();
                                img = this.getOrigCloseBoxImg_();
                                return div || img;
                            };
                            uiGmapInfoBox.prototype.getOrigCloseBoxImg_ = function() {
                                var img;
                                img = "";
                                if (this.closeBoxURL_ !== "") {
                                    img = "<img";
                                    img += " src='" + this.closeBoxURL_ + "'";
                                    img += " align=right";
                                    img += " style='";
                                    img += " position: relative;";
                                    img += " cursor: pointer;";
                                    img += " margin: " + this.closeBoxMargin_ + ";";
                                    img += "'>";
                                }
                                return img;
                            };
                            return uiGmapInfoBox;
                        })(window.InfoBox);
                        window.uiGmapInfoBox = uiGmapInfoBox;
                    }
                    if (window.MarkerLabel_) {
                        return window.MarkerLabel_.prototype.setContent = function() {
                            var content;
                            content = this.marker_.get('labelContent');
                            if (!content || _.isEqual(this.oldContent, content)) {
                                return;
                            }
                            if (typeof(content != null ? content.nodeType : void 0) === 'undefined') {
                                this.labelDiv_.innerHTML = content;
                                this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                                this.oldContent = content;
                            } else {
                                this.labelDiv_.innerHTML = '';
                                this.labelDiv_.appendChild(content);
                                content = content.cloneNode(true);
                                this.labelDiv_.innerHTML = '';
                                this.eventDiv_.appendChild(content);
                                this.oldContent = content;
                            }
                        };
                    }
                })
            };
        });
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.extensions').service('uiGmapLodash', function() {
            var baseGet, baseToString, get, reIsDeepProp, reIsPlainProp, rePropName, toObject, toPath;
            if (_.get == null) {
                reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/;
                reIsPlainProp = /^\w*$/;
                rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
                toObject = function(value) {
                    if (_.isObject(value)) {
                        return value;
                    } else {
                        return Object(value);
                    }
                };
                baseToString = function(value) {
                    if (value === null) {
                        return '';
                    } else {
                        return value + '';
                    }
                };
                toPath = function(value) {
                    var result;
                    if (_.isArray(value)) {
                        return value;
                    }
                    result = [];
                    baseToString(value).replace(rePropName, function(match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
                    });
                    return result;
                };
                baseGet = function(object, path, pathKey) {
                    var index, length;
                    if (object === null) {
                        return;
                    }
                    if (pathKey !== void 0 && pathKey in toObject(object)) {
                        path = [pathKey];
                    }
                    index = 0;
                    length = path.length;
                    while (!_.isUndefined(object) && index < length) {
                        object = object[path[index++]];
                    }
                    if (index && index === length) {
                        return object;
                    } else {
                        return void 0;
                    }
                };
                get = function(object, path, defaultValue) {
                    var result;
                    result = object === null ? void 0 : baseGet(object, toPath(path), path + '');
                    if (result === void 0) {
                        return defaultValue;
                    } else {
                        return result;
                    }
                };
                _.get = get;
            }
            this.intersectionObjects = function(array1, array2, comparison) {
                var res;
                if (comparison == null) {
                    comparison = void 0;
                }
                res = _.map(array1, (function(_this) {
                    return function(obj1) {
                        return _.find(array2, function(obj2) {
                            if (comparison != null) {
                                return comparison(obj1, obj2);
                            } else {
                                return _.isEqual(obj1, obj2);
                            }
                        });
                    };
                })(this));
                return _.filter(res, function(o) {
                    return o != null;
                });
            };
            this.containsObject = _.includeObject = function(obj, target, comparison) {
                if (comparison == null) {
                    comparison = void 0;
                }
                if (obj === null) {
                    return false;
                }
                return _.any(obj, (function(_this) {
                    return function(value) {
                        if (comparison != null) {
                            return comparison(value, target);
                        } else {
                            return _.isEqual(value, target);
                        }
                    };
                })(this));
            };
            this.differenceObjects = function(array1, array2, comparison) {
                if (comparison == null) {
                    comparison = void 0;
                }
                return _.filter(array1, (function(_this) {
                    return function(value) {
                        return !_this.containsObject(array2, value, comparison);
                    };
                })(this));
            };
            this.withoutObjects = this.differenceObjects;
            this.indexOfObject = function(array, item, comparison, isSorted) {
                var i, length;
                if (array == null) {
                    return -1;
                }
                i = 0;
                length = array.length;
                if (isSorted) {
                    if (typeof isSorted === "number") {
                        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
                    } else {
                        i = _.sortedIndex(array, item);
                        return (array[i] === item ? i : -1);
                    }
                }
                while (i < length) {
                    if (comparison != null) {
                        if (comparison(array[i], item)) {
                            return i;
                        }
                    } else {
                        if (_.isEqual(array[i], item)) {
                            return i;
                        }
                    }
                    i++;
                }
                return -1;
            };
            this.isNullOrUndefined = function(thing) {
                return _.isNull(thing || _.isUndefined(thing));
            };
            return this;
        });
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.extensions').factory('uiGmapString', function() {
            return function(str) {
                this.contains = function(value, fromIndex) {
                    return str.indexOf(value, fromIndex) !== -1;
                };
                return this;
            };
        });
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmap_sync', [function() {
            return {
                fakePromise: function() {
                    var _cb;
                    _cb = void 0;
                    return {
                        then: function(cb) {
                            return _cb = cb;
                        },
                        resolve: function() {
                            return _cb.apply(void 0, arguments);
                        }
                    };
                }
            };
        }]).service('uiGmap_async', ['$timeout', 'uiGmapPromise', 'uiGmapLogger', '$q', 'uiGmapDataStructures', 'uiGmapGmapUtil', function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
            var ExposedPromise, PromiseQueueManager, SniffedPromise, _getArrayAndKeys, _getIterateeValue, defaultChunkSize, doChunk, doSkippPromise, each, errorObject, isInProgress, kickPromise, logTryCatch, managePromiseQueue, map, maybeCancelPromises, promiseStatus, promiseTypes, tryCatch;
            promiseTypes = uiGmapPromise.promiseTypes;
            isInProgress = uiGmapPromise.isInProgress;
            promiseStatus = uiGmapPromise.promiseStatus;
            ExposedPromise = uiGmapPromise.ExposedPromise;
            SniffedPromise = uiGmapPromise.SniffedPromise;
            kickPromise = function(sniffedPromise, cancelCb) {
                var promise;
                promise = sniffedPromise.promise();
                promise.promiseType = sniffedPromise.promiseType;
                if (promise.$$state) {
                    $log.debug("promiseType: " + promise.promiseType + ", state: " + (promiseStatus(promise.$$state.status)));
                }
                promise.cancelCb = cancelCb;
                return promise;
            };
            doSkippPromise = function(sniffedPromise, lastPromise) {
                if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes.init) {
                    $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
                    return true;
                }
                return false;
            };
            maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
                var first;
                if (sniffedPromise.promiseType === promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes["delete"]) {
                    if ((lastPromise.cancelCb != null) && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
                        $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
                        lastPromise.cancelCb('cancel safe');
                        first = queue.peek();
                        if ((first != null) && isInProgress(first)) {
                            if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
                                $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
                                return first.cancelCb('cancel safe');
                            } else {
                                return $log.warn('first promise was not cancelable');
                            }
                        }
                    }
                }
            };
            PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
                var lastPromise, newPromise;
                if (!existingPiecesObj.existingPieces) {
                    existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
                    return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
                } else {
                    lastPromise = _.last(existingPiecesObj.existingPieces._content);
                    if (doSkippPromise(sniffedPromise, lastPromise)) {
                        return;
                    }
                    maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
                    newPromise = ExposedPromise(lastPromise["finally"](function() {
                        return kickPromise(sniffedPromise, cancelCb);
                    }));
                    newPromise.cancelCb = cancelCb;
                    newPromise.promiseType = sniffedPromise.promiseType;
                    existingPiecesObj.existingPieces.enqueue(newPromise);
                    return lastPromise["finally"](function() {
                        return existingPiecesObj.existingPieces.dequeue();
                    });
                }
            };
            managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
                var cancelLogger;
                if (msg == null) {
                    msg = '';
                }
                cancelLogger = function(msg) {
                    $log.debug(msg + ": " + msg);
                    if ((cancelCb != null) && _.isFunction(cancelCb)) {
                        return cancelCb(msg);
                    }
                };
                return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
            };
            defaultChunkSize = 80;
            errorObject = {
                value: null
            };
            tryCatch = function(fn, ctx, args) {
                var e;
                try {
                    return fn.apply(ctx, args);
                } catch (_error) {
                    e = _error;
                    errorObject.value = e;
                    return errorObject;
                }
            };
            logTryCatch = function(fn, ctx, deferred, args) {
                var msg, result;
                result = tryCatch(fn, ctx, args);
                if (result === errorObject) {
                    msg = "error within chunking iterator: " + errorObject.value;
                    $log.error(msg);
                    deferred.reject(msg);
                }
                if (result === 'cancel safe') {
                    return false;
                }
                return true;
            };
            _getIterateeValue = function(collection, array, index) {
                var _isArray, valOrKey;
                _isArray = collection === array;
                valOrKey = array[index];
                if (_isArray) {
                    return valOrKey;
                }
                return collection[valOrKey];
            };
            _getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
                var array;
                if (angular.isArray(collection)) {
                    array = collection;
                } else {
                    array = keys ? keys : Object.keys(_.omit(collection, ['length', 'forEach', 'map']));
                    keys = array;
                }
                if (cb == null) {
                    cb = bailOutCb;
                }
                if (angular.isArray(array) && (array === void 0 || (array != null ? array.length : void 0) <= 0)) {
                    if (cb !== bailOutCb) {
                        return bailOutCb();
                    }
                }
                return cb(array, keys);
            };
            doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
                return _getArrayAndKeys(collection, _keys, function(array, keys) {
                    var cnt, i, keepGoing, val;
                    if (chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length) {
                        cnt = chunkSizeOrDontChunk;
                    } else {
                        cnt = array.length;
                    }
                    i = index;
                    keepGoing = true;
                    while (keepGoing && cnt-- && i < (array ? array.length : i + 1)) {
                        val = _getIterateeValue(collection, array, i);
                        keepGoing = angular.isFunction(val) ? true : logTryCatch(chunkCb, void 0, overallD, [val, i]);
                        ++i;
                    }
                    if (array) {
                        if (keepGoing && i < array.length) {
                            index = i;
                            if (chunkSizeOrDontChunk) {
                                if ((pauseCb != null) && _.isFunction(pauseCb)) {
                                    logTryCatch(pauseCb, void 0, overallD, []);
                                }
                                return $timeout(function() {
                                    return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
                                }, pauseMilli, false);
                            }
                        } else {
                            return overallD.resolve();
                        }
                    }
                });
            };
            each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var error, overallD, ret;
                if (chunkSizeOrDontChunk == null) {
                    chunkSizeOrDontChunk = defaultChunkSize;
                }
                if (index == null) {
                    index = 0;
                }
                if (pauseMilli == null) {
                    pauseMilli = 1;
                }
                ret = void 0;
                overallD = uiGmapPromise.defer();
                ret = overallD.promise;
                if (!pauseMilli) {
                    error = 'pause (delay) must be set from _async!';
                    $log.error(error);
                    overallD.reject(error);
                    return ret;
                }
                return _getArrayAndKeys(collection, _keys, function() {
                    overallD.resolve();
                    return ret;
                }, function(array, keys) {
                    doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
                    return ret;
                });
            };
            map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var results;
                results = [];
                return _getArrayAndKeys(collection, _keys, function() {
                    return uiGmapPromise.resolve(results);
                }, function(array, keys) {
                    return each(collection, function(o) {
                        return results.push(iterator(o));
                    }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
                        return results;
                    });
                });
            };
            return {
                each: each,
                map: map,
                managePromiseQueue: managePromiseQueue,
                promiseLock: managePromiseQueue,
                defaultChunkSize: defaultChunkSize,
                chunkSizeFrom: function(fromSize, ret) {
                    if (ret == null) {
                        ret = void 0;
                    }
                    if (_.isNumber(fromSize)) {
                        ret = fromSize;
                    }
                    if (uiGmapGmapUtil.isFalse(fromSize) || fromSize === false) {
                        ret = false;
                    }
                    return ret;
                }
            };
        }]);
    }).call(this);;
    (function() {
        var indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };
        angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapBaseObject', function() {
            var BaseObject, baseObjectKeywords;
            baseObjectKeywords = ['extended', 'included'];
            BaseObject = (function() {
                function BaseObject() {}
                BaseObject.extend = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        if (indexOf.call(baseObjectKeywords, key) < 0) {
                            this[key] = value;
                        }
                    }
                    if ((ref = obj.extended) != null) {
                        ref.apply(this);
                    }
                    return this;
                };
                BaseObject.include = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        if (indexOf.call(baseObjectKeywords, key) < 0) {
                            this.prototype[key] = value;
                        }
                    }
                    if ((ref = obj.included) != null) {
                        ref.apply(this);
                    }
                    return this;
                };
                return BaseObject;
            })();
            return BaseObject;
        });
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapChildEvents', function() {
            return {
                onChildCreation: function(child) {}
            };
        });
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapCtrlHandle', ['$q', function($q) {
            var CtrlHandle;
            return CtrlHandle = {
                handle: function($scope, $element) {
                    $scope.$on('$destroy', function() {
                        return CtrlHandle.handle($scope);
                    });
                    $scope.deferred = $q.defer();
                    return {
                        getScope: function() {
                            return $scope;
                        }
                    };
                },
                mapPromise: function(scope, ctrl) {
                    var mapScope;
                    mapScope = ctrl.getScope();
                    mapScope.deferred.promise.then(function(map) {
                        return scope.map = map;
                    });
                    return mapScope.deferred.promise;
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", ["uiGmapLogger", function($log) {
            var _getEventsObj, _hasEvents;
            _hasEvents = function(obj) {
                return angular.isDefined(obj.events) && (obj.events != null) && angular.isObject(obj.events);
            };
            _getEventsObj = function(scope, model) {
                if (_hasEvents(scope)) {
                    return scope;
                }
                if (_hasEvents(model)) {
                    return model;
                }
            };
            return {
                setEvents: function(gObject, scope, model, ignores) {
                    var eventObj;
                    eventObj = _getEventsObj(scope, model);
                    if (eventObj != null) {
                        return _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
                            var doIgnore;
                            if (ignores) {
                                doIgnore = _(ignores).contains(eventName);
                            }
                            if (eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore) {
                                return google.maps.event.addListener(gObject, eventName, function() {
                                    if (!scope.$evalAsync) {
                                        scope.$evalAsync = function() {};
                                    }
                                    return scope.$evalAsync(eventHandler.apply(scope, [gObject, eventName, model, arguments]));
                                });
                            }
                        }));
                    }
                },
                removeEvents: function(listeners) {
                    var key, l;
                    if (!listeners) {
                        return;
                    }
                    for (key in listeners) {
                        l = listeners[key];
                        if (l) {
                            google.maps.event.removeListener(l);
                        }
                    }
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapFitHelper', ['uiGmapLogger', function($log) {
            return {
                fit: function(markersOrPoints, gMap) {
                    var bounds, everSet, key, markerOrPoint, point;
                    if (gMap && (markersOrPoints != null ? markersOrPoints.length : void 0)) {
                        bounds = new google.maps.LatLngBounds();
                        everSet = false;
                        for (key in markersOrPoints) {
                            markerOrPoint = markersOrPoints[key];
                            if (markerOrPoint) {
                                if (!everSet) {
                                    everSet = true;
                                }
                                point = _.isFunction(markerOrPoint.getPosition) ? markerOrPoint.getPosition() : markerOrPoint;
                            }
                            bounds.extend(point);
                        }
                        if (everSet) {
                            return gMap.fitBounds(bounds);
                        }
                    }
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapGmapUtil', ['uiGmapLogger', '$compile', function(Logger, $compile) {
            var _isFalse, _isTruthy, getCoords, getLatitude, getLongitude, validateCoords;
            _isTruthy = function(value, bool, optionsArray) {
                return value === bool || optionsArray.indexOf(value) !== -1;
            };
            _isFalse = function(value) {
                return _isTruthy(value, false, ['false', 'FALSE', 0, 'n', 'N', 'no', 'NO']);
            };
            getLatitude = function(value) {
                if (Array.isArray(value) && value.length === 2) {
                    return value[1];
                } else if (angular.isDefined(value.type) && value.type === 'Point') {
                    return value.coordinates[1];
                } else {
                    return value.latitude;
                }
            };
            getLongitude = function(value) {
                if (Array.isArray(value) && value.length === 2) {
                    return value[0];
                } else if (angular.isDefined(value.type) && value.type === 'Point') {
                    return value.coordinates[0];
                } else {
                    return value.longitude;
                }
            };
            getCoords = function(value) {
                if (!value) {
                    return;
                }
                if (Array.isArray(value) && value.length === 2) {
                    return new google.maps.LatLng(value[1], value[0]);
                } else if (angular.isDefined(value.type) && value.type === 'Point') {
                    return new google.maps.LatLng(value.coordinates[1], value.coordinates[0]);
                } else {
                    return new google.maps.LatLng(value.latitude, value.longitude);
                }
            };
            validateCoords = function(coords) {
                if (angular.isUndefined(coords)) {
                    return false;
                }
                if (_.isArray(coords)) {
                    if (coords.length === 2) {
                        return true;
                    }
                } else if ((coords != null) && (coords != null ? coords.type : void 0)) {
                    if (coords.type === 'Point' && _.isArray(coords.coordinates) && coords.coordinates.length === 2) {
                        return true;
                    }
                }
                if (coords && angular.isDefined((coords != null ? coords.latitude : void 0) && angular.isDefined(coords != null ? coords.longitude : void 0))) {
                    return true;
                }
                return false;
            };
            return {
                setCoordsFromEvent: function(prevValue, newLatLon) {
                    if (!prevValue) {
                        return;
                    }
                    if (Array.isArray(prevValue) && prevValue.length === 2) {
                        prevValue[1] = newLatLon.lat();
                        prevValue[0] = newLatLon.lng();
                    } else if (angular.isDefined(prevValue.type) && prevValue.type === 'Point') {
                        prevValue.coordinates[1] = newLatLon.lat();
                        prevValue.coordinates[0] = newLatLon.lng();
                    } else {
                        prevValue.latitude = newLatLon.lat();
                        prevValue.longitude = newLatLon.lng();
                    }
                    return prevValue;
                },
                getLabelPositionPoint: function(anchor) {
                    var xPos, yPos;
                    if (anchor === void 0) {
                        return void 0;
                    }
                    anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
                    xPos = parseFloat(anchor[1]);
                    yPos = parseFloat(anchor[2]);
                    if ((xPos != null) && (yPos != null)) {
                        return new google.maps.Point(xPos, yPos);
                    }
                },
                createWindowOptions: function(gMarker, scope, content, defaults) {
                    var options;
                    if ((content != null) && (defaults != null) && ($compile != null)) {
                        options = angular.extend({}, defaults, {
                            content: this.buildContent(scope, defaults, content),
                            position: defaults.position != null ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
                        });
                        if ((gMarker != null) && ((options != null ? options.pixelOffset : void 0) == null)) {
                            if (options.boxClass == null) {} else {
                                options.pixelOffset = {
                                    height: 0,
                                    width: -2
                                };
                            }
                        }
                        return options;
                    } else {
                        if (!defaults) {
                            Logger.error('infoWindow defaults not defined');
                            if (!content) {
                                return Logger.error('infoWindow content not defined');
                            }
                        } else {
                            return defaults;
                        }
                    }
                },
                buildContent: function(scope, defaults, content) {
                    var parsed, ret;
                    if (defaults.content != null) {
                        ret = defaults.content;
                    } else {
                        if ($compile != null) {
                            content = content.replace(/^\s+|\s+$/g, '');
                            parsed = content === '' ? '' : $compile(content)(scope);
                            if (parsed.length > 0) {
                                ret = parsed[0];
                            }
                        } else {
                            ret = content;
                        }
                    }
                    return ret;
                },
                defaultDelay: 50,
                isTrue: function(value) {
                    return _isTruthy(value, true, ['true', 'TRUE', 1, 'y', 'Y', 'yes', 'YES']);
                },
                isFalse: _isFalse,
                isFalsy: function(value) {
                    return _isTruthy(value, false, [void 0, null]) || _isFalse(value);
                },
                getCoords: getCoords,
                validateCoords: validateCoords,
                equalCoords: function(coord1, coord2) {
                    return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
                },
                validatePath: function(path) {
                    var array, i, polygon, trackMaxVertices;
                    i = 0;
                    if (angular.isUndefined(path.type)) {
                        if (!Array.isArray(path) || path.length < 2) {
                            return false;
                        }
                        while (i < path.length) {
                            if (!((angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) || (typeof path[i].lat === 'function' && typeof path[i].lng === 'function'))) {
                                return false;
                            }
                            i++;
                        }
                        return true;
                    } else {
                        if (angular.isUndefined(path.coordinates)) {
                            return false;
                        }
                        if (path.type === 'Polygon') {
                            if (path.coordinates[0].length < 4) {
                                return false;
                            }
                            array = path.coordinates[0];
                        } else if (path.type === 'MultiPolygon') {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            polygon = path.coordinates[trackMaxVertices.index];
                            array = polygon[0];
                            if (array.length < 4) {
                                return false;
                            }
                        } else if (path.type === 'LineString') {
                            if (path.coordinates.length < 2) {
                                return false;
                            }
                            array = path.coordinates;
                        } else {
                            return false;
                        }
                        while (i < array.length) {
                            if (array[i].length !== 2) {
                                return false;
                            }
                            i++;
                        }
                        return true;
                    }
                },
                convertPathPoints: function(path) {
                    var array, i, latlng, result, trackMaxVertices;
                    i = 0;
                    result = new google.maps.MVCArray();
                    if (angular.isUndefined(path.type)) {
                        while (i < path.length) {
                            latlng;
                            if (angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) {
                                latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude);
                            } else if (typeof path[i].lat === 'function' && typeof path[i].lng === 'function') {
                                latlng = path[i];
                            }
                            result.push(latlng);
                            i++;
                        }
                    } else {
                        array;
                        if (path.type === 'Polygon') {
                            array = path.coordinates[0];
                        } else if (path.type === 'MultiPolygon') {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            array = path.coordinates[trackMaxVertices.index][0];
                        } else if (path.type === 'LineString') {
                            array = path.coordinates;
                        }
                        while (i < array.length) {
                            result.push(new google.maps.LatLng(array[i][1], array[i][0]));
                            i++;
                        }
                    }
                    return result;
                },
                getPath: function(object, key) {
                    var obj;
                    if ((key == null) || !_.isString(key)) {
                        return key;
                    }
                    obj = object;
                    _.each(key.split('.'), function(value) {
                        if (obj) {
                            return obj = obj[value];
                        }
                    });
                    return obj;
                },
                validateBoundPoints: function(bounds) {
                    if (angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude)) {
                        return false;
                    }
                    return true;
                },
                convertBoundPoints: function(bounds) {
                    var result;
                    result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
                    return result;
                },
                fitMapBounds: function(map, bounds) {
                    return map.fitBounds(bounds);
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapIsReady', ['$q', '$timeout', function($q, $timeout) {
            var _checkIfReady, _ctr, _promises, _proms;
            _ctr = 0;
            _proms = [];
            _promises = function() {
                return $q.all(_proms);
            };
            _checkIfReady = function(deferred, expectedInstances, retriesLeft) {
                return $timeout(function() {
                    if (retriesLeft <= 0) {
                        deferred.reject('Your maps are not found we have checked the maximum amount of times. :)');
                        return;
                    }
                    if (_ctr !== expectedInstances) {
                        _checkIfReady(deferred, expectedInstances, retriesLeft - 1);
                    } else {
                        deferred.resolve(_promises());
                    }
                }, 100);
            };
            return {
                spawn: function() {
                    var d;
                    d = $q.defer();
                    _proms.push(d.promise);
                    _ctr += 1;
                    return {
                        instance: _ctr,
                        deferred: d
                    };
                },
                promises: _promises,
                instances: function() {
                    return _ctr;
                },
                promise: function(expectedInstances, numRetries) {
                    var d;
                    if (expectedInstances == null) {
                        expectedInstances = 1;
                    }
                    if (numRetries == null) {
                        numRetries = 50;
                    }
                    d = $q.defer();
                    _checkIfReady(d, expectedInstances, numRetries);
                    return d.promise;
                },
                reset: function() {
                    _ctr = 0;
                    _proms.length = 0;
                },
                decrement: function() {
                    if (_ctr > 0) {
                        _ctr -= 1;
                    }
                    if (_proms.length) {
                        _proms.length -= 1;
                    }
                }
            };
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", ["uiGmapBaseObject", function(BaseObject) {
            var Linked;
            Linked = (function(superClass) {
                extend(Linked, superClass);

                function Linked(scope, element, attrs, ctrls) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.ctrls = ctrls;
                }
                return Linked;
            })(BaseObject);
            return Linked;
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapLogger', ['nemSimpleLogger', function(nemSimpleLogger) {
            return nemSimpleLogger.spawn();
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapModelKey', ['uiGmapBaseObject', 'uiGmapGmapUtil', 'uiGmapPromise', '$q', '$timeout', function(BaseObject, GmapUtil, uiGmapPromise, $q, $timeout) {
            var ModelKey;
            return ModelKey = (function(superClass) {
                extend(ModelKey, superClass);

                function ModelKey(scope1) {
                    this.scope = scope1;
                    this.modelsLength = bind(this.modelsLength, this);
                    this.updateChild = bind(this.updateChild, this);
                    this.destroy = bind(this.destroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.getChanges = bind(this.getChanges, this);
                    this.getProp = bind(this.getProp, this);
                    this.setIdKey = bind(this.setIdKey, this);
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    ModelKey.__super__.constructor.call(this);
                    this["interface"] = {};
                    this["interface"].scopeKeys = [];
                    this.defaultIdKey = 'id';
                    this.idKey = void 0;
                }
                ModelKey.prototype.evalModelHandle = function(model, modelKey) {
                    if ((model == null) || (modelKey == null)) {
                        return;
                    }
                    if (modelKey === 'self') {
                        return model;
                    } else {
                        if (_.isFunction(modelKey)) {
                            modelKey = modelKey();
                        }
                        return GmapUtil.getPath(model, modelKey);
                    }
                };
                ModelKey.prototype.modelKeyComparison = function(model1, model2) {
                    var hasCoords, isEqual, scope;
                    hasCoords = _.contains(this["interface"].scopeKeys, 'coords');
                    if (hasCoords && (this.scope.coords != null) || !hasCoords) {
                        scope = this.scope;
                    }
                    if (scope == null) {
                        throw 'No scope set!';
                    }
                    if (hasCoords) {
                        isEqual = GmapUtil.equalCoords(this.scopeOrModelVal('coords', scope, model1), this.scopeOrModelVal('coords', scope, model2));
                        if (!isEqual) {
                            return isEqual;
                        }
                    }
                    isEqual = _.every(_.without(this["interface"].scopeKeys, 'coords'), (function(_this) {
                        return function(k) {
                            return _this.scopeOrModelVal(scope[k], scope, model1) === _this.scopeOrModelVal(scope[k], scope, model2);
                        };
                    })(this));
                    return isEqual;
                };
                ModelKey.prototype.setIdKey = function(scope) {
                    return this.idKey = scope.idKey != null ? scope.idKey : this.defaultIdKey;
                };
                ModelKey.prototype.setVal = function(model, key, newValue) {
                    var thingToSet;
                    thingToSet = this.modelOrKey(model, key);
                    thingToSet = newValue;
                    return model;
                };
                ModelKey.prototype.modelOrKey = function(model, key) {
                    if (key == null) {
                        return;
                    }
                    if (key !== 'self') {
                        return GmapUtil.getPath(model, key);
                    }
                    return model;
                };
                ModelKey.prototype.getProp = function(propName, scope, model) {
                    return this.scopeOrModelVal(propName, scope, model);
                };
                ModelKey.prototype.getChanges = function(now, prev, whitelistedProps) {
                    var c, changes, prop;
                    if (whitelistedProps) {
                        prev = _.pick(prev, whitelistedProps);
                        now = _.pick(now, whitelistedProps);
                    }
                    changes = {};
                    prop = {};
                    c = {};
                    for (prop in now) {
                        if (!prev || prev[prop] !== now[prop]) {
                            if (_.isArray(now[prop])) {
                                changes[prop] = now[prop];
                            } else if (_.isObject(now[prop])) {
                                c = this.getChanges(now[prop], (prev ? prev[prop] : null));
                                if (!_.isEmpty(c)) {
                                    changes[prop] = c;
                                }
                            } else {
                                changes[prop] = now[prop];
                            }
                        }
                    }
                    return changes;
                };
                ModelKey.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
                    var maybeWrap, modelKey, modelProp, scopeProp;
                    if (doWrap == null) {
                        doWrap = false;
                    }
                    maybeWrap = function(isScope, ret, doWrap) {
                        if (doWrap == null) {
                            doWrap = false;
                        }
                        if (doWrap) {
                            return {
                                isScope: isScope,
                                value: ret
                            };
                        }
                        return ret;
                    };
                    scopeProp = _.get(scope, key);
                    if (_.isFunction(scopeProp)) {
                        return maybeWrap(true, scopeProp(model), doWrap);
                    }
                    if (_.isObject(scopeProp)) {
                        return maybeWrap(true, scopeProp, doWrap);
                    }
                    if (!_.isString(scopeProp)) {
                        return maybeWrap(true, scopeProp, doWrap);
                    }
                    modelKey = scopeProp;
                    if (!modelKey) {
                        modelProp = _.get(model, key);
                    } else {
                        modelProp = modelKey === 'self' ? model : _.get(model, modelKey);
                    }
                    if (_.isFunction(modelProp)) {
                        return maybeWrap(false, modelProp(), doWrap);
                    }
                    return maybeWrap(false, modelProp, doWrap);
                };
                ModelKey.prototype.setChildScope = function(keys, childScope, model) {
                    var isScopeObj, key, name, newValue;
                    for (key in keys) {
                        name = keys[key];
                        isScopeObj = this.scopeOrModelVal(name, childScope, model, true);
                        if ((isScopeObj != null ? isScopeObj.value : void 0) != null) {
                            newValue = isScopeObj.value;
                            if (newValue !== childScope[name]) {
                                childScope[name] = newValue;
                            }
                        }
                    }
                    return childScope.model = model;
                };
                ModelKey.prototype.onDestroy = function(scope) {};
                ModelKey.prototype.destroy = function(manualOverride) {
                    var ref;
                    if (manualOverride == null) {
                        manualOverride = false;
                    }
                    if ((this.scope != null) && !((ref = this.scope) != null ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) {
                        return this.scope.$destroy();
                    } else {
                        return this.clean();
                    }
                };
                ModelKey.prototype.updateChild = function(child, model) {
                    if (model[this.idKey] == null) {
                        this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                        return;
                    }
                    return child.updateModel(model);
                };
                ModelKey.prototype.modelsLength = function(arrayOrObjModels) {
                    var len, toCheck;
                    if (arrayOrObjModels == null) {
                        arrayOrObjModels = void 0;
                    }
                    len = 0;
                    toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
                    if (toCheck == null) {
                        return len;
                    }
                    if (angular.isArray(toCheck) || (toCheck.length != null)) {
                        len = toCheck.length;
                    } else {
                        len = Object.keys(toCheck).length;
                    }
                    return len;
                };
                return ModelKey;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapModelsWatcher', ['uiGmapLogger', 'uiGmap_async', '$q', 'uiGmapPromise', function(Logger, _async, $q, uiGmapPromise) {
            return {
                didQueueInitPromise: function(existingPiecesObj, scope) {
                    if (scope.models.length === 0) {
                        _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, ((function(_this) {
                            return function() {
                                return uiGmapPromise.resolve();
                            };
                        })(this)));
                        return true;
                    }
                    return false;
                },
                figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
                    var adds, children, mappedScopeModelIds, removals, updates;
                    adds = [];
                    mappedScopeModelIds = {};
                    removals = [];
                    updates = [];
                    scope.models.forEach(function(m) {
                        var child;
                        if (m[idKey] != null) {
                            mappedScopeModelIds[m[idKey]] = {};
                            if (childObjects.get(m[idKey]) == null) {
                                return adds.push(m);
                            } else {
                                child = childObjects.get(m[idKey]);
                                if (!comparison(m, child.clonedModel, scope)) {
                                    return updates.push({
                                        model: m,
                                        child: child
                                    });
                                }
                            }
                        } else {
                            return Logger.error(' id missing for model #{m.toString()},\ncan not use do comparison/insertion');
                        }
                    });
                    children = childObjects.values();
                    children.forEach(function(c) {
                        var id;
                        if (c == null) {
                            Logger.error('child undefined in ModelsWatcher.');
                            return;
                        }
                        if (c.model == null) {
                            Logger.error('child.model undefined in ModelsWatcher.');
                            return;
                        }
                        id = c.model[idKey];
                        if (mappedScopeModelIds[id] == null) {
                            return removals.push(c);
                        }
                    });
                    return {
                        adds: adds,
                        removals: removals,
                        updates: updates
                    };
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapPromise', ['$q', '$timeout', 'uiGmapLogger', function($q, $timeout, $log) {
            var ExposedPromise, SniffedPromise, defer, isInProgress, isResolved, promise, promiseStatus, promiseStatuses, promiseTypes, resolve, strPromiseStatuses;
            promiseTypes = {
                create: 'create',
                update: 'update',
                "delete": 'delete',
                init: 'init'
            };
            promiseStatuses = {
                IN_PROGRESS: 0,
                RESOLVED: 1,
                REJECTED: 2
            };
            strPromiseStatuses = (function() {
                var obj;
                obj = {};
                obj["" + promiseStatuses.IN_PROGRESS] = 'in-progress';
                obj["" + promiseStatuses.RESOLVED] = 'resolved';
                obj["" + promiseStatuses.REJECTED] = 'rejected';
                return obj;
            })();
            isInProgress = function(promise) {
                if (promise.$$state) {
                    return promise.$$state.status === promiseStatuses.IN_PROGRESS;
                }
                if (!promise.hasOwnProperty("$$v")) {
                    return true;
                }
            };
            isResolved = function(promise) {
                if (promise.$$state) {
                    return promise.$$state.status === promiseStatuses.RESOLVED;
                }
                if (promise.hasOwnProperty("$$v")) {
                    return true;
                }
            };
            promiseStatus = function(status) {
                return strPromiseStatuses[status] || 'done w error';
            };
            ExposedPromise = function(promise) {
                var cancelDeferred, combined, wrapped;
                cancelDeferred = $q.defer();
                combined = $q.all([promise, cancelDeferred.promise]);
                wrapped = $q.defer();
                promise.then(cancelDeferred.resolve, (function() {}), function(notify) {
                    cancelDeferred.notify(notify);
                    return wrapped.notify(notify);
                });
                combined.then(function(successes) {
                    return wrapped.resolve(successes[0] || successes[1]);
                }, function(error) {
                    return wrapped.reject(error);
                });
                wrapped.promise.cancel = function(reason) {
                    if (reason == null) {
                        reason = 'canceled';
                    }
                    return cancelDeferred.reject(reason);
                };
                wrapped.promise.notify = function(msg) {
                    if (msg == null) {
                        msg = 'cancel safe';
                    }
                    wrapped.notify(msg);
                    if (promise.hasOwnProperty('notify')) {
                        return promise.notify(msg);
                    }
                };
                if (promise.promiseType != null) {
                    wrapped.promise.promiseType = promise.promiseType;
                }
                return wrapped.promise;
            };
            SniffedPromise = function(fnPromise, promiseType) {
                return {
                    promise: fnPromise,
                    promiseType: promiseType
                };
            };
            defer = function() {
                return $q.defer();
            };
            resolve = function() {
                var d;
                d = $q.defer();
                d.resolve.apply(void 0, arguments);
                return d.promise;
            };
            promise = function(fnToWrap) {
                var d;
                if (!_.isFunction(fnToWrap)) {
                    $log.error("uiGmapPromise.promise() only accepts functions");
                    return;
                }
                d = $q.defer();
                $timeout(function() {
                    var result;
                    result = fnToWrap();
                    return d.resolve(result);
                });
                return d.promise;
            };
            return {
                defer: defer,
                promise: promise,
                resolve: resolve,
                promiseTypes: promiseTypes,
                isInProgress: isInProgress,
                isResolved: isResolved,
                promiseStatus: promiseStatus,
                ExposedPromise: ExposedPromise,
                SniffedPromise: SniffedPromise
            };
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
            var PropMap;
            return PropMap = (function() {
                function PropMap() {
                    this.removeAll = bind(this.removeAll, this);
                    this.slice = bind(this.slice, this);
                    this.push = bind(this.push, this);
                    this.keys = bind(this.keys, this);
                    this.values = bind(this.values, this);
                    this.remove = bind(this.remove, this);
                    this.put = bind(this.put, this);
                    this.stateChanged = bind(this.stateChanged, this);
                    this.get = bind(this.get, this);
                    this.length = 0;
                    this.dict = {};
                    this.didValsStateChange = false;
                    this.didKeysStateChange = false;
                    this.allVals = [];
                    this.allKeys = [];
                }
                PropMap.prototype.get = function(key) {
                    return this.dict[key];
                };
                PropMap.prototype.stateChanged = function() {
                    this.didValsStateChange = true;
                    return this.didKeysStateChange = true;
                };
                PropMap.prototype.put = function(key, value) {
                    if (this.get(key) == null) {
                        this.length++;
                    }
                    this.stateChanged();
                    return this.dict[key] = value;
                };
                PropMap.prototype.remove = function(key, isSafe) {
                    var value;
                    if (isSafe == null) {
                        isSafe = false;
                    }
                    if (isSafe && !this.get(key)) {
                        return void 0;
                    }
                    value = this.dict[key];
                    delete this.dict[key];
                    this.length--;
                    this.stateChanged();
                    return value;
                };
                PropMap.prototype.valuesOrKeys = function(str) {
                    var keys, vals;
                    if (str == null) {
                        str = 'Keys';
                    }
                    if (!this["did" + str + "StateChange"]) {
                        return this['all' + str];
                    }
                    vals = [];
                    keys = [];
                    _.each(this.dict, function(v, k) {
                        vals.push(v);
                        return keys.push(k);
                    });
                    this.didKeysStateChange = false;
                    this.didValsStateChange = false;
                    this.allVals = vals;
                    this.allKeys = keys;
                    return this['all' + str];
                };
                PropMap.prototype.values = function() {
                    return this.valuesOrKeys('Vals');
                };
                PropMap.prototype.keys = function() {
                    return this.valuesOrKeys();
                };
                PropMap.prototype.push = function(obj, key) {
                    if (key == null) {
                        key = "key";
                    }
                    return this.put(obj[key], obj);
                };
                PropMap.prototype.slice = function() {
                    return this.keys().map((function(_this) {
                        return function(k) {
                            return _this.remove(k);
                        };
                    })(this));
                };
                PropMap.prototype.removeAll = function() {
                    return this.slice();
                };
                PropMap.prototype.each = function(cb) {
                    return _.each(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                PropMap.prototype.map = function(cb) {
                    return _.map(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                return PropMap;
            })();
        });
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", ["uiGmapLogger", function(Logger) {
            var PropertyAction;
            PropertyAction = function(setterFn) {
                this.setIfChange = function(newVal, oldVal) {
                    var callingKey;
                    callingKey = this.exp;
                    if (!_.isEqual(oldVal, newVal)) {
                        return setterFn(callingKey, newVal);
                    }
                };
                this.sic = this.setIfChange;
                return this;
            };
            return PropertyAction;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module('uiGmapgoogle-maps.directives.api.managers').factory('uiGmapClustererMarkerManager', ['uiGmapLogger', 'uiGmapFitHelper', 'uiGmapPropMap', 'uiGmapEventsHelper', function($log, FitHelper, PropMap, EventsHelper) {
            var ClustererMarkerManager;
            ClustererMarkerManager = (function() {
                ClustererMarkerManager.type = 'ClustererMarkerManager';

                function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
                    if (opt_markers == null) {
                        opt_markers = {};
                    }
                    this.opt_options = opt_options != null ? opt_options : {};
                    this.opt_events = opt_events;
                    this.checkSync = bind(this.checkSync, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.attachEvents = bind(this.attachEvents, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = ClustererMarkerManager.type;
                    this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, 'opt_events');
                    this.clusterer.setIgnoreHidden(true);
                    this.noDrawOnSingleAddRemoves = true;
                    $log.info(this);
                }
                ClustererMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (gMarker.key == null) {
                        msg = 'gMarker.key undefined and it is REQUIRED!!';
                        return $log.error(msg);
                    }
                };
                ClustererMarkerManager.prototype.add = function(gMarker) {
                    this.checkKey(gMarker);
                    this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                ClustererMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach((function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    })(this));
                };
                ClustererMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach((function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    })(this));
                };
                ClustererMarkerManager.prototype.draw = function() {
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.clear = function() {
                    this.removeMany(this.getGMarkers());
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    this.listeners = [];
                    if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
                                results.push(this.listeners.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName])));
                            } else {
                                results.push(void 0);
                            }
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.clearEvents = function() {
                    EventsHelper.removeEvents(this.listeners);
                    return this.listeners = [];
                };
                ClustererMarkerManager.prototype.destroy = function() {
                    this.clearEvents();
                    return this.clear();
                };
                ClustererMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
                };
                ClustererMarkerManager.prototype.getGMarkers = function() {
                    return this.clusterer.getMarkers().values();
                };
                ClustererMarkerManager.prototype.checkSync = function() {};
                return ClustererMarkerManager;
            })();
            return ClustererMarkerManager;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", ["uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
            var MarkerManager;
            MarkerManager = (function() {
                MarkerManager.type = 'MarkerManager';

                function MarkerManager(gMap, opt_markers, opt_options) {
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.handleOptDraw = bind(this.handleOptDraw, this);
                    this.clear = bind(this.clear, this);
                    this.destroy = bind(this.destroy, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = MarkerManager.type;
                    this.gMap = gMap;
                    this.gMarkers = new PropMap();
                    this.$log = Logger;
                    this.$log.info(this);
                }
                MarkerManager.prototype.add = function(gMarker, optDraw) {
                    var exists, msg;
                    if (optDraw == null) {
                        optDraw = true;
                    }
                    if (gMarker.key == null) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        Logger.error(msg);
                        throw msg;
                    }
                    exists = this.gMarkers.get(gMarker.key);
                    if (!exists) {
                        this.handleOptDraw(gMarker, optDraw, true);
                        return this.gMarkers.put(gMarker.key, gMarker);
                    }
                };
                MarkerManager.prototype.update = function(gMarker, optDraw) {
                    if (optDraw == null) {
                        optDraw = true;
                    }
                    this.remove(gMarker, optDraw);
                    return this.add(gMarker, optDraw);
                };
                MarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach((function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    })(this));
                };
                MarkerManager.prototype.remove = function(gMarker, optDraw) {
                    if (optDraw == null) {
                        optDraw = true;
                    }
                    this.handleOptDraw(gMarker, optDraw, false);
                    if (this.gMarkers.get(gMarker.key)) {
                        return this.gMarkers.remove(gMarker.key);
                    }
                };
                MarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach((function(_this) {
                        return function(marker) {
                            return _this.remove(marker);
                        };
                    })(this));
                };
                MarkerManager.prototype.draw = function() {
                    var deletes;
                    deletes = [];
                    this.gMarkers.each((function(_this) {
                        return function(gMarker) {
                            if (!gMarker.isDrawn) {
                                if (gMarker.doAdd) {
                                    gMarker.setMap(_this.gMap);
                                    return gMarker.isDrawn = true;
                                } else {
                                    return deletes.push(gMarker);
                                }
                            }
                        };
                    })(this));
                    return deletes.forEach((function(_this) {
                        return function(gMarker) {
                            gMarker.isDrawn = false;
                            return _this.remove(gMarker, true);
                        };
                    })(this));
                };
                MarkerManager.prototype.destroy = function() {
                    return this.clear();
                };
                MarkerManager.prototype.clear = function() {
                    this.gMarkers.each(function(gMarker) {
                        return gMarker.setMap(null);
                    });
                    delete this.gMarkers;
                    return this.gMarkers = new PropMap();
                };
                MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
                    if (optDraw === true) {
                        if (doAdd) {
                            gMarker.setMap(this.gMap);
                        } else {
                            gMarker.setMap(null);
                        }
                        return gMarker.isDrawn = true;
                    } else {
                        gMarker.isDrawn = false;
                        return gMarker.doAdd = doAdd;
                    }
                };
                MarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.gMap);
                };
                MarkerManager.prototype.getGMarkers = function() {
                    return this.gMarkers.values();
                };
                return MarkerManager;
            })();
            return MarkerManager;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module('uiGmapgoogle-maps.directives.api.managers').factory('uiGmapSpiderfierMarkerManager', ['uiGmapLogger', 'uiGmapFitHelper', 'uiGmapPropMap', 'uiGmapMarkerSpiderfier', function($log, FitHelper, PropMap, MarkerSpiderfier) {
            var SpiderfierMarkerManager;
            return SpiderfierMarkerManager = (function() {
                SpiderfierMarkerManager.type = 'SpiderfierMarkerManager';

                function SpiderfierMarkerManager(gMap, opt_markers, opt_options, opt_events, scope) {
                    if (opt_markers == null) {
                        opt_markers = {};
                    }
                    this.opt_options = opt_options != null ? opt_options : {};
                    this.opt_events = opt_events;
                    this.scope = scope;
                    this.checkSync = bind(this.checkSync, this);
                    this.isSpiderfied = bind(this.isSpiderfied, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.attachEvents = bind(this.attachEvents, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = SpiderfierMarkerManager.type;
                    this.markerSpiderfier = new MarkerSpiderfier(gMap, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, 'opt_events');
                    this.noDrawOnSingleAddRemoves = true;
                    $log.info(this);
                }
                SpiderfierMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (gMarker.key == null) {
                        msg = 'gMarker.key undefined and it is REQUIRED!!';
                        return $log.error(msg);
                    }
                };
                SpiderfierMarkerManager.prototype.add = function(gMarker) {
                    gMarker.setMap(this.markerSpiderfier.map);
                    this.checkKey(gMarker);
                    this.markerSpiderfier.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                SpiderfierMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                SpiderfierMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach((function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    })(this));
                };
                SpiderfierMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        gMarker.setMap(null);
                        this.markerSpiderfier.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                SpiderfierMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach((function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    })(this));
                };
                SpiderfierMarkerManager.prototype.draw = function() {};
                SpiderfierMarkerManager.prototype.clear = function() {
                    return this.removeMany(this.getGMarkers());
                };
                SpiderfierMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
                        return _.each(options, (function(_this) {
                            return function(eventHandler, eventName) {
                                if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                    $log.info(optionsName + ": Attaching event: " + eventName + " to markerSpiderfier");
                                    return _this.markerSpiderfier.addListener(eventName, function() {
                                        if (eventName === 'spiderfy' || eventName === 'unspiderfy') {
                                            return _this.scope.$evalAsync(options[eventName].apply(options, arguments));
                                        } else {
                                            return _this.scope.$evalAsync(options[eventName].apply(options, [arguments[0], eventName, arguments[0].model, arguments]));
                                        }
                                    });
                                }
                            };
                        })(this));
                    }
                };
                SpiderfierMarkerManager.prototype.clearEvents = function(options, optionsName) {
                    var eventHandler, eventName;
                    if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Clearing event: " + eventName + " to markerSpiderfier");
                                this.markerSpiderfier.clearListeners(eventName);
                            }
                        }
                    }
                };
                SpiderfierMarkerManager.prototype.destroy = function() {
                    this.clearEvents(this.opt_events, 'opt_events');
                    return this.clear();
                };
                SpiderfierMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.markerSpiderfier.map);
                };
                SpiderfierMarkerManager.prototype.getGMarkers = function() {
                    return this.markerSpiderfier.getMarkers();
                };
                SpiderfierMarkerManager.prototype.isSpiderfied = function() {
                    return _.find(this.getGMarkers(), function(gMarker) {
                        return (gMarker != null ? gMarker._omsData : void 0) != null;
                    });
                };
                SpiderfierMarkerManager.prototype.checkSync = function() {};
                return SpiderfierMarkerManager;
            })();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').factory('uiGmapadd-events', ['$timeout', function($timeout) {
            var addEvent, addEvents;
            addEvent = function(target, eventName, handler) {
                return google.maps.event.addListener(target, eventName, function() {
                    handler.apply(this, arguments);
                    return $timeout((function() {}), true);
                });
            };
            addEvents = function(target, eventName, handler) {
                var remove;
                if (handler) {
                    return addEvent(target, eventName, handler);
                }
                remove = [];
                angular.forEach(eventName, function(_handler, key) {
                    return remove.push(addEvent(target, key, _handler));
                });
                return function() {
                    angular.forEach(remove, function(listener) {
                        return google.maps.event.removeListener(listener);
                    });
                    return remove = null;
                };
            };
            return addEvents;
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').factory('uiGmaparray-sync', ['uiGmapadd-events', function(mapEvents) {
            return function(mapArray, scope, pathEval, pathChangedFn) {
                var geojsonArray, geojsonHandlers, geojsonWatcher, isSetFromScope, legacyHandlers, legacyWatcher, mapArrayListener, scopePath, watchListener;
                isSetFromScope = false;
                scopePath = scope.$eval(pathEval);
                if (!scope["static"]) {
                    legacyHandlers = {
                        set_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return scopePath[index] = value;
                            } else {
                                scopePath[index].latitude = value.lat();
                                return scopePath[index].longitude = value.lng();
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return scopePath.splice(index, 0, value);
                            } else {
                                return scopePath.splice(index, 0, {
                                    latitude: value.lat(),
                                    longitude: value.lng()
                                });
                            }
                        },
                        remove_at: function(index) {
                            if (isSetFromScope) {
                                return;
                            }
                            return scopePath.splice(index, 1);
                        }
                    };
                    geojsonArray;
                    if (scopePath.type === 'Polygon') {
                        geojsonArray = scopePath.coordinates[0];
                    } else if (scopePath.type === 'LineString') {
                        geojsonArray = scopePath.coordinates;
                    }
                    geojsonHandlers = {
                        set_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return;
                            }
                            geojsonArray[index][1] = value.lat();
                            return geojsonArray[index][0] = value.lng();
                        },
                        insert_at: function(index) {
                            var value;
                            if (isSetFromScope) {
                                return;
                            }
                            value = mapArray.getAt(index);
                            if (!value) {
                                return;
                            }
                            if (!value.lng || !value.lat) {
                                return;
                            }
                            return geojsonArray.splice(index, 0, [value.lng(), value.lat()]);
                        },
                        remove_at: function(index) {
                            if (isSetFromScope) {
                                return;
                            }
                            return geojsonArray.splice(index, 1);
                        }
                    };
                    mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
                }
                legacyWatcher = function(newPath) {
                    var changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = true;
                    oldArray = mapArray;
                    changed = false;
                    if (newPath) {
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = newPath.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        while (i < l) {
                            oldValue = oldArray.getAt(i);
                            newValue = newPath[i];
                            if (typeof newValue.equals === 'function') {
                                if (!newValue.equals(oldValue)) {
                                    oldArray.setAt(i, newValue);
                                    changed = true;
                                }
                            } else {
                                if ((oldValue.lat() !== newValue.latitude) || (oldValue.lng() !== newValue.longitude)) {
                                    oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
                                    changed = true;
                                }
                            }
                            i++;
                        }
                        while (i < newLength) {
                            newValue = newPath[i];
                            if (typeof newValue.lat === 'function' && typeof newValue.lng === 'function') {
                                oldArray.push(newValue);
                            } else {
                                oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
                            }
                            changed = true;
                            i++;
                        }
                        while (i < oldLength) {
                            oldArray.pop();
                            changed = true;
                            i++;
                        }
                    }
                    isSetFromScope = false;
                    if (changed) {
                        return pathChangedFn(oldArray);
                    }
                };
                geojsonWatcher = function(newPath) {
                    var array, changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = true;
                    oldArray = mapArray;
                    changed = false;
                    if (newPath) {
                        array;
                        if (scopePath.type === 'Polygon') {
                            array = newPath.coordinates[0];
                        } else if (scopePath.type === 'LineString') {
                            array = newPath.coordinates;
                        }
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = array.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        while (i < l) {
                            oldValue = oldArray.getAt(i);
                            newValue = array[i];
                            if ((oldValue.lat() !== newValue[1]) || (oldValue.lng() !== newValue[0])) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
                                changed = true;
                            }
                            i++;
                        }
                        while (i < newLength) {
                            newValue = array[i];
                            oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
                            changed = true;
                            i++;
                        }
                        while (i < oldLength) {
                            oldArray.pop();
                            changed = true;
                            i++;
                        }
                    }
                    isSetFromScope = false;
                    if (changed) {
                        return pathChangedFn(oldArray);
                    }
                };
                watchListener;
                if (!scope["static"]) {
                    if (angular.isUndefined(scopePath.type)) {
                        watchListener = scope.$watchCollection(pathEval, legacyWatcher);
                    } else {
                        watchListener = scope.$watch(pathEval, geojsonWatcher, true);
                    }
                }
                return function() {
                    if (mapArrayListener) {
                        mapArrayListener();
                        mapArrayListener = null;
                    }
                    if (watchListener) {
                        watchListener();
                        return watchListener = null;
                    }
                };
            };
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", ['$timeout', function($timeout) {
            return {
                maybeRepaint: function(el) {
                    if (el) {
                        el.style.opacity = 0.9;
                        return $timeout(function() {
                            return el.style.opacity = 1;
                        });
                    }
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').service('uiGmapObjectIterators', function() {
            var _ignores, _iterators, _slapForEach, _slapMap;
            _ignores = ['length', 'forEach', 'map'];
            _iterators = [];
            _slapForEach = function(object) {
                object.forEach = function(cb) {
                    return _.each(_.omit(object, _ignores), function(val) {
                        if (!_.isFunction(val)) {
                            return cb(val);
                        }
                    });
                };
                return object;
            };
            _iterators.push(_slapForEach);
            _slapMap = function(object) {
                object.map = function(cb) {
                    return _.map(_.omit(object, _ignores), function(val) {
                        if (!_.isFunction(val)) {
                            return cb(val);
                        }
                    });
                };
                return object;
            };
            _iterators.push(_slapMap);
            return {
                slapMap: _slapMap,
                slapForEach: _slapForEach,
                slapAll: function(object) {
                    _iterators.forEach(function(it) {
                        return it(object);
                    });
                    return object;
                }
            };
        });
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.options.builders').service('uiGmapCommonOptionsBuilder', ['uiGmapBaseObject', 'uiGmapLogger', 'uiGmapModelKey', function(BaseObject, $log, ModelKey) {
            var CommonOptionsBuilder;
            return CommonOptionsBuilder = (function(superClass) {
                extend(CommonOptionsBuilder, superClass);

                function CommonOptionsBuilder() {
                    this.watchProps = bind(this.watchProps, this);
                    this.buildOpts = bind(this.buildOpts, this);
                    return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                CommonOptionsBuilder.prototype.props = ['clickable', 'draggable', 'editable', 'visible', {
                    prop: 'stroke',
                    isColl: true
                }];
                CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
                    if (angular.isDefined(scope != null ? scope.model : void 0)) {
                        return scope.model;
                    } else {
                        return scope;
                    }
                };
                CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var model, opts, stroke;
                    if (customOpts == null) {
                        customOpts = {};
                    }
                    if (forEachOpts == null) {
                        forEachOpts = {};
                    }
                    if (!this.scope) {
                        $log.error('this.scope not defined in CommonOptionsBuilder can not buildOpts');
                        return;
                    }
                    if (!this.map) {
                        $log.error('this.map not defined in CommonOptionsBuilder can not buildOpts');
                        return;
                    }
                    model = this.getCorrectModel(this.scope);
                    stroke = this.scopeOrModelVal('stroke', this.scope, model);
                    opts = angular.extend(customOpts, this.DEFAULTS, {
                        map: this.map,
                        strokeColor: stroke != null ? stroke.color : void 0,
                        strokeOpacity: stroke != null ? stroke.opacity : void 0,
                        strokeWeight: stroke != null ? stroke.weight : void 0
                    });
                    angular.forEach(angular.extend(forEachOpts, {
                        clickable: true,
                        draggable: false,
                        editable: false,
                        "static": false,
                        fit: false,
                        visible: true,
                        zIndex: 0,
                        icons: []
                    }), (function(_this) {
                        return function(defaultValue, key) {
                            var val;
                            val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
                            if (angular.isUndefined(val)) {
                                return opts[key] = defaultValue;
                            } else {
                                return opts[key] = model[key];
                            }
                        };
                    })(this));
                    if (opts["static"]) {
                        opts.editable = false;
                    }
                    return opts;
                };
                CommonOptionsBuilder.prototype.watchProps = function(props) {
                    if (props == null) {
                        props = this.props;
                    }
                    return props.forEach((function(_this) {
                        return function(prop) {
                            if ((_this.attrs[prop] != null) || (_this.attrs[prop != null ? prop.prop : void 0] != null)) {
                                if (prop != null ? prop.isColl : void 0) {
                                    return _this.scope.$watchCollection(prop.prop, _this.setMyOptions);
                                } else {
                                    return _this.scope.$watch(prop, _this.setMyOptions);
                                }
                            }
                        };
                    })(this));
                };
                return CommonOptionsBuilder;
            })(ModelKey);
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.options.builders').factory('uiGmapPolylineOptionsBuilder', ['uiGmapCommonOptionsBuilder', function(CommonOptionsBuilder) {
            var PolylineOptionsBuilder;
            return PolylineOptionsBuilder = (function(superClass) {
                extend(PolylineOptionsBuilder, superClass);

                function PolylineOptionsBuilder() {
                    return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolylineOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: false
                    });
                };
                return PolylineOptionsBuilder;
            })(CommonOptionsBuilder);
        }]).factory('uiGmapShapeOptionsBuilder', ['uiGmapCommonOptionsBuilder', function(CommonOptionsBuilder) {
            var ShapeOptionsBuilder;
            return ShapeOptionsBuilder = (function(superClass) {
                extend(ShapeOptionsBuilder, superClass);

                function ShapeOptionsBuilder() {
                    return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var fill, model;
                    model = this.getCorrectModel(this.scope);
                    fill = cachedEval ? cachedEval['fill'] : this.scopeOrModelVal('fill', this.scope, model);
                    customOpts = angular.extend(customOpts, {
                        fillColor: fill != null ? fill.color : void 0,
                        fillOpacity: fill != null ? fill.opacity : void 0
                    });
                    return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
                };
                return ShapeOptionsBuilder;
            })(CommonOptionsBuilder);
        }]).factory('uiGmapPolygonOptionsBuilder', ['uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
            var PolygonOptionsBuilder;
            return PolygonOptionsBuilder = (function(superClass) {
                extend(PolygonOptionsBuilder, superClass);

                function PolygonOptionsBuilder() {
                    return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolygonOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: false
                    });
                };
                return PolygonOptionsBuilder;
            })(ShapeOptionsBuilder);
        }]).factory('uiGmapRectangleOptionsBuilder', ['uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
            var RectangleOptionsBuilder;
            return RectangleOptionsBuilder = (function(superClass) {
                extend(RectangleOptionsBuilder, superClass);

                function RectangleOptionsBuilder() {
                    return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
                    return RectangleOptionsBuilder.__super__.buildOpts.call(this, {
                        bounds: bounds
                    }, cachedEval);
                };
                return RectangleOptionsBuilder;
            })(ShapeOptionsBuilder);
        }]).factory('uiGmapCircleOptionsBuilder', ['uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
            var CircleOptionsBuilder;
            return CircleOptionsBuilder = (function(superClass) {
                extend(CircleOptionsBuilder, superClass);

                function CircleOptionsBuilder() {
                    return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
                    return CircleOptionsBuilder.__super__.buildOpts.call(this, {
                        center: center,
                        radius: radius
                    }, cachedEval);
                };
                return CircleOptionsBuilder;
            })(ShapeOptionsBuilder);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.options').service('uiGmapMarkerOptions', ['uiGmapLogger', 'uiGmapGmapUtil', function($log, GmapUtil) {
            return _.extend(GmapUtil, {
                createOptions: function(coords, icon, defaults, map) {
                    var opts;
                    if (defaults == null) {
                        defaults = {};
                    }
                    opts = angular.extend({}, defaults, {
                        position: defaults.position != null ? defaults.position : GmapUtil.getCoords(coords),
                        visible: defaults.visible != null ? defaults.visible : GmapUtil.validateCoords(coords)
                    });
                    if ((defaults.icon != null) || (icon != null)) {
                        opts = angular.extend(opts, {
                            icon: defaults.icon != null ? defaults.icon : icon
                        });
                    }
                    if (map != null) {
                        opts.map = map;
                    }
                    return opts;
                },
                isLabel: function(options) {
                    if (options == null) {
                        return false;
                    }
                    return (options.labelContent != null) || (options.labelAnchor != null) || (options.labelClass != null) || (options.labelStyle != null) || (options.labelVisible != null);
                }
            });
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapBasePolyChildModel', ['uiGmapLogger', '$timeout', 'uiGmaparray-sync', 'uiGmapGmapUtil', 'uiGmapEventsHelper', function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
            return function(Builder, gFactory) {
                var BasePolyChildModel;
                return BasePolyChildModel = (function(superClass) {
                    extend(BasePolyChildModel, superClass);
                    BasePolyChildModel.include(GmapUtil);

                    function BasePolyChildModel(scope, attrs, map, defaults, model, gObjectChangeCb) {
                        var create;
                        this.scope = scope;
                        this.attrs = attrs;
                        this.map = map;
                        this.defaults = defaults;
                        this.model = model;
                        this.clean = bind(this.clean, this);
                        this.clonedModel = _.clone(this.model, true);
                        this.isDragging = false;
                        this.internalEvents = {
                            dragend: (function(_this) {
                                return function() {
                                    return _.defer(function() {
                                        return _this.isDragging = false;
                                    });
                                };
                            })(this),
                            dragstart: (function(_this) {
                                return function() {
                                    return _this.isDragging = true;
                                };
                            })(this)
                        };
                        create = (function(_this) {
                            return function() {
                                var maybeCachedEval;
                                if (_this.isDragging) {
                                    return;
                                }
                                _this.pathPoints = _this.convertPathPoints(_this.scope.path);
                                if (_this.gObject != null) {
                                    _this.clean();
                                }
                                if (_this.scope.model != null) {
                                    maybeCachedEval = _this.scope;
                                }
                                if (_this.pathPoints.length > 0) {
                                    _this.gObject = gFactory(_this.buildOpts(_this.pathPoints, maybeCachedEval));
                                }
                                if (_this.gObject) {
                                    arraySync(_this.gObject.getPath(), _this.scope, 'path', function(pathPoints) {
                                        _this.pathPoints = pathPoints;
                                        if (gObjectChangeCb != null) {
                                            return gObjectChangeCb();
                                        }
                                    });
                                    if (angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events)) {
                                        _this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope);
                                    }
                                    return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {
                                        events: _this.internalEvents
                                    }, _this.model) : EventsHelper.setEvents(_this.gObject, {
                                        events: _this.internalEvents
                                    }, _this.scope);
                                }
                            };
                        })(this);
                        create();
                        this.scope.$watch('path', (function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue) || !_this.gObject) {
                                    return create();
                                }
                            };
                        })(this), true);
                        if (!this.scope["static"] && angular.isDefined(this.scope.editable)) {
                            this.scope.$watch('editable', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                        return (ref = _this.gObject) != null ? ref.setEditable(newValue) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.draggable)) {
                            this.scope.$watch('draggable', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                        return (ref = _this.gObject) != null ? ref.setDraggable(newValue) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.visible)) {
                            this.scope.$watch('visible', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                    }
                                    return (ref = _this.gObject) != null ? ref.setVisible(newValue) : void 0;
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.geodesic)) {
                            this.scope.$watch('geodesic', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        newValue = !_this.isFalse(newValue);
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight)) {
                            this.scope.$watch('stroke.weight', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color)) {
                            this.scope.$watch('stroke.color', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity)) {
                            this.scope.$watch('stroke.opacity', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        if (angular.isDefined(this.scope.icons)) {
                            this.scope.$watch('icons', (function(_this) {
                                return function(newValue, oldValue) {
                                    var ref;
                                    if (newValue !== oldValue) {
                                        return (ref = _this.gObject) != null ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                    }
                                };
                            })(this), true);
                        }
                        this.scope.$on('$destroy', (function(_this) {
                            return function() {
                                _this.clean();
                                return _this.scope = null;
                            };
                        })(this));
                        if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color)) {
                            this.scope.$watch('fill.color', (function(_this) {
                                return function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                                    }
                                };
                            })(this));
                        }
                        if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity)) {
                            this.scope.$watch('fill.opacity', (function(_this) {
                                return function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                                    }
                                };
                            })(this));
                        }
                        if (angular.isDefined(this.scope.zIndex)) {
                            this.scope.$watch('zIndex', (function(_this) {
                                return function(newValue, oldValue) {
                                    if (newValue !== oldValue) {
                                        return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                                    }
                                };
                            })(this));
                        }
                    }
                    BasePolyChildModel.prototype.clean = function() {
                        var ref;
                        EventsHelper.removeEvents(this.listeners);
                        EventsHelper.removeEvents(this.internalListeners);
                        if ((ref = this.gObject) != null) {
                            ref.setMap(null);
                        }
                        return this.gObject = null;
                    };
                    return BasePolyChildModel;
                })(Builder);
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapDrawFreeHandChildModel', ['uiGmapLogger', '$q', function($log, $q) {
            var drawFreeHand, freeHandMgr;
            drawFreeHand = function(map, polys, done) {
                var move, poly;
                poly = new google.maps.Polyline({
                    map: map,
                    clickable: false
                });
                move = google.maps.event.addListener(map, 'mousemove', function(e) {
                    return poly.getPath().push(e.latLng);
                });
                google.maps.event.addListenerOnce(map, 'mouseup', function(e) {
                    var path;
                    google.maps.event.removeListener(move);
                    path = poly.getPath();
                    poly.setMap(null);
                    polys.push(new google.maps.Polygon({
                        map: map,
                        path: path
                    }));
                    poly = null;
                    google.maps.event.clearListeners(map.getDiv(), 'mousedown');
                    return done();
                });
                return void 0;
            };
            freeHandMgr = function(map1, scope) {
                var disableMap, enableMap;
                this.map = map1;
                disableMap = (function(_this) {
                    return function() {
                        var mapOptions;
                        mapOptions = {
                            draggable: false,
                            disableDefaultUI: true,
                            scrollwheel: false,
                            disableDoubleClickZoom: false
                        };
                        $log.info('disabling map move');
                        return _this.map.setOptions(mapOptions);
                    };
                })(this);
                enableMap = (function(_this) {
                    return function() {
                        var mapOptions, ref;
                        mapOptions = {
                            draggable: true,
                            disableDefaultUI: false,
                            scrollwheel: true,
                            disableDoubleClickZoom: true
                        };
                        if ((ref = _this.deferred) != null) {
                            ref.resolve();
                        }
                        return _.defer(function() {
                            return _this.map.setOptions(_.extend(mapOptions, scope.options));
                        });
                    };
                })(this);
                this.engage = (function(_this) {
                    return function(polys1) {
                        _this.polys = polys1;
                        _this.deferred = $q.defer();
                        disableMap();
                        $log.info('DrawFreeHandChildModel is engaged (drawing).');
                        google.maps.event.addDomListener(_this.map.getDiv(), 'mousedown', function(e) {
                            return drawFreeHand(_this.map, _this.polys, enableMap);
                        });
                        return _this.deferred.promise;
                    };
                })(this);
                return this;
            };
            return freeHandMgr;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapMarkerChildModel', ['uiGmapModelKey', 'uiGmapGmapUtil', 'uiGmapLogger', 'uiGmapEventsHelper', 'uiGmapPropertyAction', 'uiGmapMarkerOptions', 'uiGmapIMarker', 'uiGmapMarkerManager', 'uiGmapPromise', function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
            var MarkerChildModel;
            MarkerChildModel = (function(superClass) {
                var destroy;
                extend(MarkerChildModel, superClass);
                MarkerChildModel.include(GmapUtil);
                MarkerChildModel.include(EventsHelper);
                MarkerChildModel.include(MarkerOptions);
                destroy = function(child) {
                    if ((child != null ? child.gObject : void 0) != null) {
                        child.removeEvents(child.externalListeners);
                        child.removeEvents(child.internalListeners);
                        if (child != null ? child.gObject : void 0) {
                            if (child.removeFromManager) {
                                child.gManager.remove(child.gObject);
                            }
                            child.gObject.setMap(null);
                            return child.gObject = null;
                        }
                    }
                };

                function MarkerChildModel(scope, model1, keys, gMap, defaults, doClick, gManager, doDrawSelf, trackModel, needRedraw) {
                    var action;
                    this.model = model1;
                    this.keys = keys;
                    this.gMap = gMap;
                    this.defaults = defaults;
                    this.doClick = doClick;
                    this.gManager = gManager;
                    this.doDrawSelf = doDrawSelf != null ? doDrawSelf : true;
                    this.trackModel = trackModel != null ? trackModel : true;
                    this.needRedraw = needRedraw != null ? needRedraw : false;
                    this.internalEvents = bind(this.internalEvents, this);
                    this.setLabelOptions = bind(this.setLabelOptions, this);
                    this.setOptions = bind(this.setOptions, this);
                    this.setIcon = bind(this.setIcon, this);
                    this.setCoords = bind(this.setCoords, this);
                    this.isNotValid = bind(this.isNotValid, this);
                    this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
                    this.createMarker = bind(this.createMarker, this);
                    this.setMyScope = bind(this.setMyScope, this);
                    this.updateModel = bind(this.updateModel, this);
                    this.handleModelChanges = bind(this.handleModelChanges, this);
                    this.destroy = bind(this.destroy, this);
                    this.clonedModel = _.clone(this.model, true);
                    this.deferred = uiGmapPromise.defer();
                    _.each(this.keys, (function(_this) {
                        return function(v, k) {
                            var keyValue;
                            keyValue = _this.keys[k];
                            if ((keyValue != null) && !_.isFunction(keyValue) && _.isString(keyValue)) {
                                return _this[k + 'Key'] = keyValue;
                            }
                        };
                    })(this));
                    this.idKey = this.idKeyKey || 'id';
                    if (this.model[this.idKey] != null) {
                        this.id = this.model[this.idKey];
                    }
                    MarkerChildModel.__super__.constructor.call(this, scope);
                    this.scope.getGMarker = (function(_this) {
                        return function() {
                            return _this.gObject;
                        };
                    })(this);
                    this.firstTime = true;
                    if (this.trackModel) {
                        this.scope.model = this.model;
                        this.scope.$watch('model', (function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    return _this.handleModelChanges(newValue, oldValue);
                                }
                            };
                        })(this), true);
                    } else {
                        action = new PropertyAction((function(_this) {
                            return function(calledKey, newVal) {
                                if (!_this.firstTime) {
                                    return _this.setMyScope(calledKey, scope);
                                }
                            };
                        })(this), false);
                        _.each(this.keys, function(v, k) {
                            return scope.$watch(k, action.sic, true);
                        });
                    }
                    this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            return destroy(_this);
                        };
                    })(this));
                    this.createMarker(this.model);
                    $log.info(this);
                }
                MarkerChildModel.prototype.destroy = function(removeFromManager) {
                    if (removeFromManager == null) {
                        removeFromManager = true;
                    }
                    this.removeFromManager = removeFromManager;
                    return this.scope.$destroy();
                };
                MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
                    var changes, ctr, len;
                    changes = this.getChanges(newValue, oldValue, IMarker.keys);
                    if (!this.firstTime) {
                        ctr = 0;
                        len = _.keys(changes).length;
                        return _.each(changes, (function(_this) {
                            return function(v, k) {
                                var doDraw;
                                ctr += 1;
                                doDraw = len === ctr;
                                _this.setMyScope(k, newValue, oldValue, false, true, doDraw);
                                return _this.needRedraw = true;
                            };
                        })(this));
                    }
                };
                MarkerChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.clone(model, true);
                    return this.setMyScope('all', model, this.model);
                };
                MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
                    var coords, isSpiderfied, ref;
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    coords = this.getProp('coords', this.scope, this.model);
                    if (((ref = this.gManager) != null ? ref.isSpiderfied : void 0) != null) {
                        isSpiderfied = this.gManager.isSpiderfied();
                    }
                    if (coords != null) {
                        if (!this.validateCoords(coords)) {
                            $log.debug('MarkerChild does not have coords yet. They may be defined later.');
                            return;
                        }
                        if (validCb != null) {
                            validCb();
                        }
                        if (doDraw && this.gObject) {
                            this.gManager.add(this.gObject);
                        }
                        if (isSpiderfied) {
                            return this.gManager.markerSpiderfier.spiderListener(this.gObject, window.event);
                        }
                    } else {
                        if (doDraw && this.gObject) {
                            return this.gManager.remove(this.gObject);
                        }
                    }
                };
                MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
                    var justCreated;
                    if (oldModel == null) {
                        oldModel = void 0;
                    }
                    if (isInit == null) {
                        isInit = false;
                    }
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (model == null) {
                        model = this.model;
                    } else {
                        this.model = model;
                    }
                    if (!this.gObject) {
                        this.setOptions(this.scope, doDraw);
                        justCreated = true;
                    }
                    switch (thingThatChanged) {
                        case 'all':
                            return _.each(this.keys, (function(_this) {
                                return function(v, k) {
                                    return _this.setMyScope(k, model, oldModel, isInit, doDraw);
                                };
                            })(this));
                        case 'icon':
                            return this.maybeSetScopeValue('icon', model, oldModel, this.iconKey, this.evalModelHandle, isInit, this.setIcon, doDraw);
                        case 'coords':
                            return this.maybeSetScopeValue('coords', model, oldModel, this.coordsKey, this.evalModelHandle, isInit, this.setCoords, doDraw);
                        case 'options':
                            if (!justCreated) {
                                return this.createMarker(model, oldModel, isInit, doDraw);
                            }
                    }
                };
                MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
                    if (oldModel == null) {
                        oldModel = void 0;
                    }
                    if (isInit == null) {
                        isInit = false;
                    }
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    this.maybeSetScopeValue('options', model, oldModel, this.optionsKey, this.evalModelHandle, isInit, this.setOptions, doDraw);
                    return this.firstTime = false;
                };
                MarkerChildModel.prototype.maybeSetScopeValue = function(scopePropName, model, oldModel, modelKey, evaluate, isInit, gSetter, doDraw) {
                    if (gSetter == null) {
                        gSetter = void 0;
                    }
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (gSetter != null) {
                        return gSetter(this.scope, doDraw);
                    }
                };
                if (MarkerChildModel.doDrawSelf && doDraw) {
                    MarkerChildModel.gManager.draw();
                }
                MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
                    var hasIdenticalScopes, hasNoGmarker;
                    if (doCheckGmarker == null) {
                        doCheckGmarker = true;
                    }
                    hasNoGmarker = !doCheckGmarker ? false : this.gObject === void 0;
                    hasIdenticalScopes = !this.trackModel ? scope.$id !== this.scope.$id : false;
                    return hasIdenticalScopes || hasNoGmarker;
                };
                MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (this.isNotValid(scope) || (this.gObject == null)) {
                        return;
                    }
                    return this.renderGMarker(doDraw, (function(_this) {
                        return function() {
                            var newGValue, newModelVal, oldGValue;
                            newModelVal = _this.getProp('coords', scope, _this.model);
                            newGValue = _this.getCoords(newModelVal);
                            oldGValue = _this.gObject.getPosition();
                            if ((oldGValue != null) && (newGValue != null)) {
                                if (newGValue.lng() === oldGValue.lng() && newGValue.lat() === oldGValue.lat()) {
                                    return;
                                }
                            }
                            _this.gObject.setPosition(newGValue);
                            return _this.gObject.setVisible(_this.validateCoords(newModelVal));
                        };
                    })(this));
                };
                MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (this.isNotValid(scope) || (this.gObject == null)) {
                        return;
                    }
                    return this.renderGMarker(doDraw, (function(_this) {
                        return function() {
                            var coords, newValue, oldValue;
                            oldValue = _this.gObject.getIcon();
                            newValue = _this.getProp('icon', scope, _this.model);
                            if (oldValue === newValue) {
                                return;
                            }
                            _this.gObject.setIcon(newValue);
                            coords = _this.getProp('coords', scope, _this.model);
                            _this.gObject.setPosition(_this.getCoords(coords));
                            return _this.gObject.setVisible(_this.validateCoords(coords));
                        };
                    })(this));
                };
                MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
                    var ref;
                    if (doDraw == null) {
                        doDraw = true;
                    }
                    if (this.isNotValid(scope, false)) {
                        return;
                    }
                    this.renderGMarker(doDraw, (function(_this) {
                        return function() {
                            var _options, coords, icon;
                            coords = _this.getProp('coords', scope, _this.model);
                            icon = _this.getProp('icon', scope, _this.model);
                            _options = _this.getProp('options', scope, _this.model);
                            _this.opts = _this.createOptions(coords, icon, _options);
                            if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && (_this.gObject != null)) {
                                _this.gManager.remove(_this.gObject);
                                _this.gObject = void 0;
                            }
                            if (_this.gObject != null) {
                                _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
                            }
                            if (!_this.gObject) {
                                if (_this.isLabel(_this.opts)) {
                                    _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts));
                                } else if (_this.opts.content) {
                                    _this.gObject = new RichMarker(_this.opts);
                                    _this.gObject.getIcon = _this.gObject.getContent;
                                    _this.gObject.setIcon = _this.gObject.setContent;
                                } else {
                                    _this.gObject = new google.maps.Marker(_this.opts);
                                }
                                _.extend(_this.gObject, {
                                    model: _this.model
                                });
                            }
                            if (_this.externalListeners) {
                                _this.removeEvents(_this.externalListeners);
                            }
                            if (_this.internalListeners) {
                                _this.removeEvents(_this.internalListeners);
                            }
                            _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, ['dragend']);
                            _this.internalListeners = _this.setEvents(_this.gObject, {
                                events: _this.internalEvents(),
                                $evalAsync: function() {}
                            }, _this.model);
                            if (_this.id != null) {
                                return _this.gObject.key = _this.id;
                            }
                        };
                    })(this));
                    if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) {
                        this.deferred.resolve(this.gObject);
                    } else {
                        if (!this.gObject) {
                            return this.deferred.reject('gObject is null');
                        }
                        if (!(((ref = this.gObject) != null ? ref.getMap() : void 0) && this.gManager.type === MarkerManager.type)) {
                            $log.debug('gObject has no map yet');
                            this.deferred.resolve(this.gObject);
                        }
                    }
                    if (this.model[this.fitKey]) {
                        return this.gManager.fit();
                    }
                };
                MarkerChildModel.prototype.setLabelOptions = function(opts) {
                    if (opts.labelAnchor) {
                        opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor);
                    }
                    return opts;
                };
                MarkerChildModel.prototype.internalEvents = function() {
                    return {
                        dragend: (function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var events, modelToSet, newCoords;
                                modelToSet = _this.trackModel ? _this.scope.model : _this.model;
                                newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
                                modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
                                events = _this.scope.events;
                                if ((events != null ? events.dragend : void 0) != null) {
                                    events.dragend(marker, eventName, modelToSet, mousearg);
                                }
                                return _this.scope.$apply();
                            };
                        })(this),
                        click: (function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var click;
                                click = _this.getProp('click', _this.scope, _this.model);
                                if (_this.doClick && (click != null)) {
                                    return _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg));
                                }
                            };
                        })(this)
                    };
                };
                return MarkerChildModel;
            })(ModelKey);
            return MarkerChildModel;
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygonChildModel', ['uiGmapBasePolyChildModel', 'uiGmapPolygonOptionsBuilder', function(BaseGen, Builder) {
            var PolygonChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polygon(opts);
            };
            base = new BaseGen(Builder, gFactory);
            return PolygonChildModel = (function(superClass) {
                extend(PolygonChildModel, superClass);

                function PolygonChildModel() {
                    return PolygonChildModel.__super__.constructor.apply(this, arguments);
                }
                return PolygonChildModel;
            })(base);
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolylineChildModel', ['uiGmapBasePolyChildModel', 'uiGmapPolylineOptionsBuilder', function(BaseGen, Builder) {
            var PolylineChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polyline(opts);
            };
            base = BaseGen(Builder, gFactory);
            return PolylineChildModel = (function(superClass) {
                extend(PolylineChildModel, superClass);

                function PolylineChildModel() {
                    return PolylineChildModel.__super__.constructor.apply(this, arguments);
                }
                return PolylineChildModel;
            })(base);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapWindowChildModel', ['uiGmapBaseObject', 'uiGmapGmapUtil', 'uiGmapLogger', '$compile', '$http', '$templateCache', 'uiGmapChromeFixes', 'uiGmapEventsHelper', function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
            var WindowChildModel;
            WindowChildModel = (function(superClass) {
                extend(WindowChildModel, superClass);
                WindowChildModel.include(GmapUtil);
                WindowChildModel.include(EventsHelper);

                function WindowChildModel(model1, scope1, opts, isIconVisibleOnClick, mapCtrl, markerScope, element, needToManualDestroy, markerIsVisibleAfterWindowClose) {
                    var maybeMarker;
                    this.model = model1;
                    this.scope = scope1;
                    this.opts = opts;
                    this.isIconVisibleOnClick = isIconVisibleOnClick;
                    this.mapCtrl = mapCtrl;
                    this.markerScope = markerScope;
                    this.element = element;
                    this.needToManualDestroy = needToManualDestroy != null ? needToManualDestroy : false;
                    this.markerIsVisibleAfterWindowClose = markerIsVisibleAfterWindowClose != null ? markerIsVisibleAfterWindowClose : true;
                    this.updateModel = bind(this.updateModel, this);
                    this.destroy = bind(this.destroy, this);
                    this.remove = bind(this.remove, this);
                    this.getLatestPosition = bind(this.getLatestPosition, this);
                    this.hideWindow = bind(this.hideWindow, this);
                    this.showWindow = bind(this.showWindow, this);
                    this.handleClick = bind(this.handleClick, this);
                    this.watchOptions = bind(this.watchOptions, this);
                    this.watchCoords = bind(this.watchCoords, this);
                    this.createGWin = bind(this.createGWin, this);
                    this.watchElement = bind(this.watchElement, this);
                    this.watchAndDoShow = bind(this.watchAndDoShow, this);
                    this.doShow = bind(this.doShow, this);
                    this.clonedModel = _.clone(this.model, true);
                    this.getGmarker = function() {
                        var ref, ref1;
                        if (((ref = this.markerScope) != null ? ref['getGMarker'] : void 0) != null) {
                            return (ref1 = this.markerScope) != null ? ref1.getGMarker() : void 0;
                        }
                    };
                    this.listeners = [];
                    this.createGWin();
                    maybeMarker = this.getGmarker();
                    if (maybeMarker != null) {
                        maybeMarker.setClickable(true);
                    }
                    this.watchElement();
                    this.watchOptions();
                    this.watchCoords();
                    this.watchAndDoShow();
                    this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            return _this.destroy();
                        };
                    })(this));
                    $log.info(this);
                }
                WindowChildModel.prototype.doShow = function(wasOpen) {
                    if (this.scope.show === true || wasOpen) {
                        return this.showWindow();
                    } else {
                        return this.hideWindow();
                    }
                };
                WindowChildModel.prototype.watchAndDoShow = function() {
                    if (this.model.show != null) {
                        this.scope.show = this.model.show;
                    }
                    this.scope.$watch('show', this.doShow, true);
                    return this.doShow();
                };
                WindowChildModel.prototype.watchElement = function() {
                    return this.scope.$watch((function(_this) {
                        return function() {
                            var ref, wasOpen;
                            if (!(_this.element || _this.html)) {
                                return;
                            }
                            if (_this.html !== _this.element.html() && _this.gObject) {
                                if ((ref = _this.opts) != null) {
                                    ref.content = void 0;
                                }
                                wasOpen = _this.gObject.isOpen();
                                _this.remove();
                                return _this.createGWin(wasOpen);
                            }
                        };
                    })(this));
                };
                WindowChildModel.prototype.createGWin = function(isOpen) {
                    var _opts, defaults, maybeMarker, ref, ref1;
                    if (isOpen == null) {
                        isOpen = false;
                    }
                    maybeMarker = this.getGmarker();
                    defaults = {};
                    if (this.opts != null) {
                        if (this.scope.coords) {
                            this.opts.position = this.getCoords(this.scope.coords);
                        }
                        defaults = this.opts;
                    }
                    if (this.element) {
                        this.html = _.isObject(this.element) ? this.element.html() : this.element;
                    }
                    _opts = this.scope.options ? this.scope.options : defaults;
                    this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
                    if (this.opts != null) {
                        if (!this.gObject) {
                            if (this.opts.boxClass && (window.InfoBox && typeof window.InfoBox === 'function')) {
                                this.gObject = new window.InfoBox(this.opts);
                            } else {
                                this.gObject = new google.maps.InfoWindow(this.opts);
                            }
                            this.listeners.push(google.maps.event.addListener(this.gObject, 'domready', function() {
                                return ChromeFixes.maybeRepaint(this.content);
                            }));
                            this.listeners.push(google.maps.event.addListener(this.gObject, 'closeclick', (function(_this) {
                                return function() {
                                    if (maybeMarker) {
                                        maybeMarker.setAnimation(_this.oldMarkerAnimation);
                                        if (_this.markerIsVisibleAfterWindowClose) {
                                            _.delay(function() {
                                                maybeMarker.setVisible(false);
                                                return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
                                            }, 250);
                                        }
                                    }
                                    _this.gObject.close();
                                    _this.model.show = false;
                                    if (_this.scope.closeClick != null) {
                                        return _this.scope.$evalAsync(_this.scope.closeClick());
                                    } else {
                                        return _this.scope.$evalAsync();
                                    }
                                };
                            })(this)));
                        }
                        this.gObject.setContent(this.opts.content);
                        this.handleClick(((ref = this.scope) != null ? (ref1 = ref.options) != null ? ref1.forceClick : void 0 : void 0) || isOpen);
                        return this.doShow(this.gObject.isOpen());
                    }
                };
                WindowChildModel.prototype.watchCoords = function() {
                    var scope;
                    scope = this.markerScope != null ? this.markerScope : this.scope;
                    return scope.$watch('coords', (function(_this) {
                        return function(newValue, oldValue) {
                            var pos;
                            if (newValue !== oldValue) {
                                if (newValue == null) {
                                    _this.hideWindow();
                                } else if (!_this.validateCoords(newValue)) {
                                    $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + (JSON.stringify(_this.model)));
                                    return;
                                }
                                pos = _this.getCoords(newValue);
                                _this.doShow();
                                _this.gObject.setPosition(pos);
                                if (_this.opts) {
                                    return _this.opts.position = pos;
                                }
                            }
                        };
                    })(this), true);
                };
                WindowChildModel.prototype.watchOptions = function() {
                    return this.scope.$watch('options', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.opts = newValue;
                                if (_this.gObject != null) {
                                    _this.gObject.setOptions(_this.opts);
                                    if ((_this.opts.visible != null) && _this.opts.visible) {
                                        return _this.showWindow();
                                    } else if (_this.opts.visible != null) {
                                        return _this.hideWindow();
                                    }
                                }
                            }
                        };
                    })(this), true);
                };
                WindowChildModel.prototype.handleClick = function(forceClick) {
                    var click, maybeMarker;
                    if (this.gObject == null) {
                        return;
                    }
                    maybeMarker = this.getGmarker();
                    click = (function(_this) {
                        return function() {
                            if (_this.gObject == null) {
                                _this.createGWin();
                            }
                            _this.showWindow();
                            if (maybeMarker != null) {
                                _this.initialMarkerVisibility = maybeMarker.getVisible();
                                _this.oldMarkerAnimation = maybeMarker.getAnimation();
                                return maybeMarker.setVisible(_this.isIconVisibleOnClick);
                            }
                        };
                    })(this);
                    if (forceClick) {
                        click();
                    }
                    if (maybeMarker) {
                        return this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {
                            events: {
                                click: click
                            }
                        }, this.model));
                    }
                };
                WindowChildModel.prototype.showWindow = function() {
                    var compiled, show, templateScope;
                    if (this.gObject != null) {
                        show = (function(_this) {
                            return function() {
                                var isOpen, maybeMarker, pos;
                                if (!_this.gObject.isOpen()) {
                                    maybeMarker = _this.getGmarker();
                                    if ((_this.gObject != null) && (_this.gObject.getPosition != null)) {
                                        pos = _this.gObject.getPosition();
                                    }
                                    if (maybeMarker) {
                                        pos = maybeMarker.getPosition();
                                    }
                                    if (!pos) {
                                        return;
                                    }
                                    _this.gObject.open(_this.mapCtrl, maybeMarker);
                                    isOpen = _this.gObject.isOpen();
                                    if (_this.model.show !== isOpen) {
                                        return _this.model.show = isOpen;
                                    }
                                }
                            };
                        })(this);
                        if (this.scope.templateUrl) {
                            return $http.get(this.scope.templateUrl, {
                                cache: $templateCache
                            }).then((function(_this) {
                                return function(content) {
                                    var compiled, templateScope;
                                    templateScope = _this.scope.$new();
                                    if (angular.isDefined(_this.scope.templateParameter)) {
                                        templateScope.parameter = _this.scope.templateParameter;
                                    }
                                    compiled = $compile(content.data)(templateScope);
                                    _this.gObject.setContent(compiled[0]);
                                    return show();
                                };
                            })(this));
                        } else if (this.scope.template) {
                            templateScope = this.scope.$new();
                            if (angular.isDefined(this.scope.templateParameter)) {
                                templateScope.parameter = this.scope.templateParameter;
                            }
                            compiled = $compile(this.scope.template)(templateScope);
                            this.gObject.setContent(compiled[0]);
                            return show();
                        } else {
                            return show();
                        }
                    }
                };
                WindowChildModel.prototype.hideWindow = function() {
                    if ((this.gObject != null) && this.gObject.isOpen()) {
                        return this.gObject.close();
                    }
                };
                WindowChildModel.prototype.getLatestPosition = function(overridePos) {
                    var maybeMarker;
                    maybeMarker = this.getGmarker();
                    if ((this.gObject != null) && (maybeMarker != null) && !overridePos) {
                        return this.gObject.setPosition(maybeMarker.getPosition());
                    } else {
                        if (overridePos) {
                            return this.gObject.setPosition(overridePos);
                        }
                    }
                };
                WindowChildModel.prototype.remove = function() {
                    this.hideWindow();
                    this.removeEvents(this.listeners);
                    this.listeners.length = 0;
                    delete this.gObject;
                    return delete this.opts;
                };
                WindowChildModel.prototype.destroy = function(manualOverride) {
                    var ref;
                    if (manualOverride == null) {
                        manualOverride = false;
                    }
                    this.remove();
                    if ((this.scope != null) && !((ref = this.scope) != null ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) {
                        return this.scope.$destroy();
                    }
                };
                WindowChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.clone(model, true);
                    return _.extend(this.model, this.clonedModel);
                };
                return WindowChildModel;
            })(BaseObject);
            return WindowChildModel;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapBasePolysParentModel', ['$timeout', 'uiGmapLogger', 'uiGmapModelKey', 'uiGmapModelsWatcher', 'uiGmapPropMap', 'uiGmap_async', 'uiGmapPromise', 'uiGmapFitHelper', function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise, FitHelper) {
            return function(IPoly, PolyChildModel, gObjectName) {
                var BasePolysParentModel;
                return BasePolysParentModel = (function(superClass) {
                    extend(BasePolysParentModel, superClass);
                    BasePolysParentModel.include(ModelsWatcher);

                    function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
                        this.element = element;
                        this.attrs = attrs;
                        this.gMap = gMap1;
                        this.defaults = defaults;
                        this.maybeFit = bind(this.maybeFit, this);
                        this.createChild = bind(this.createChild, this);
                        this.pieceMeal = bind(this.pieceMeal, this);
                        this.createAllNew = bind(this.createAllNew, this);
                        this.watchIdKey = bind(this.watchIdKey, this);
                        this.createChildScopes = bind(this.createChildScopes, this);
                        this.watchDestroy = bind(this.watchDestroy, this);
                        this.onDestroy = bind(this.onDestroy, this);
                        this.rebuildAll = bind(this.rebuildAll, this);
                        this.doINeedToWipe = bind(this.doINeedToWipe, this);
                        this.watchModels = bind(this.watchModels, this);
                        BasePolysParentModel.__super__.constructor.call(this, scope);
                        this["interface"] = IPoly;
                        this.$log = $log;
                        this.plurals = new PropMap();
                        _.each(IPoly.scopeKeys, (function(_this) {
                            return function(name) {
                                return _this[name + 'Key'] = void 0;
                            };
                        })(this));
                        this.models = void 0;
                        this.firstTime = true;
                        this.$log.info(this);
                        this.createChildScopes();
                    }
                    BasePolysParentModel.prototype.watchModels = function(scope) {
                        return scope.$watch('models', (function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    if (_this.doINeedToWipe(newValue) || scope.doRebuildAll) {
                                        return _this.rebuildAll(scope, true, true);
                                    } else {
                                        return _this.createChildScopes(false);
                                    }
                                }
                            };
                        })(this), true);
                    };
                    BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
                        var newValueIsEmpty;
                        newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
                        return this.plurals.length > 0 && newValueIsEmpty;
                    };
                    BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                        return this.onDestroy(doDelete).then((function(_this) {
                            return function() {
                                if (doCreate) {
                                    return _this.createChildScopes();
                                }
                            };
                        })(this));
                    };
                    BasePolysParentModel.prototype.onDestroy = function(scope) {
                        BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
                            return function() {
                                return _async.each(_this.plurals.values(), function(child) {
                                    return child.destroy(true);
                                }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                                    var ref;
                                    return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
                                });
                            };
                        })(this));
                    };
                    BasePolysParentModel.prototype.watchDestroy = function(scope) {
                        return scope.$on('$destroy', (function(_this) {
                            return function() {
                                return _this.rebuildAll(scope, false, true);
                            };
                        })(this));
                    };
                    BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                        if (isCreatingFromScratch == null) {
                            isCreatingFromScratch = true;
                        }
                        if (angular.isUndefined(this.scope.models)) {
                            this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!");
                            return;
                        }
                        if ((this.gMap == null) || (this.scope.models == null)) {
                            return;
                        }
                        this.watchIdKey(this.scope);
                        if (isCreatingFromScratch) {
                            return this.createAllNew(this.scope, false);
                        } else {
                            return this.pieceMeal(this.scope, false);
                        }
                    };
                    BasePolysParentModel.prototype.watchIdKey = function(scope) {
                        this.setIdKey(scope);
                        return scope.$watch('idKey', (function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue && (newValue == null)) {
                                    _this.idKey = newValue;
                                    return _this.rebuildAll(scope, true, true);
                                }
                            };
                        })(this));
                    };
                    BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
                        var maybeCanceled;
                        if (isArray == null) {
                            isArray = false;
                        }
                        this.models = scope.models;
                        if (this.firstTime) {
                            this.watchModels(scope);
                            this.watchDestroy(scope);
                        }
                        if (this.didQueueInitPromise(this, scope)) {
                            return;
                        }
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }), (function(_this) {
                            return function() {
                                return _async.map(scope.models, function(model) {
                                    var child;
                                    child = _this.createChild(model, _this.gMap);
                                    if (maybeCanceled) {
                                        $log.debug('createNew should fall through safely');
                                        child.isEnabled = false;
                                    }
                                    maybeCanceled;
                                    return child.pathPoints.getArray();
                                }, _async.chunkSizeFrom(scope.chunk)).then(function(pathPoints) {
                                    _this.maybeFit(pathPoints);
                                    return _this.firstTime = false;
                                });
                            };
                        })(this));
                    };
                    BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
                        var maybeCanceled, payload;
                        if (isArray == null) {
                            isArray = true;
                        }
                        if (scope.$$destroyed) {
                            return;
                        }
                        maybeCanceled = null;
                        payload = null;
                        this.models = scope.models;
                        if ((scope != null) && this.modelsLength() && this.plurals.length) {
                            return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }), (function(_this) {
                                return function() {
                                    return uiGmapPromise.promise(function() {
                                        return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                    }).then(function(state) {
                                        payload = state;
                                        if (payload.updates.length) {
                                            _async.each(payload.updates, function(obj) {
                                                _.extend(obj.child.scope, obj.model);
                                                return obj.child.model = obj.model;
                                            });
                                        }
                                        return _async.each(payload.removals, function(child) {
                                            if (child != null) {
                                                child.destroy();
                                                _this.plurals.remove(child.model[_this.idKey]);
                                                return maybeCanceled;
                                            }
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    }).then(function() {
                                        return _async.each(payload.adds, function(modelToAdd) {
                                            if (maybeCanceled) {
                                                $log.debug('pieceMeal should fall through safely');
                                            }
                                            _this.createChild(modelToAdd, _this.gMap);
                                            return maybeCanceled;
                                        }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                            return _this.maybeFit();
                                        });
                                    });
                                };
                            })(this));
                        } else {
                            this.inProgress = false;
                            return this.rebuildAll(this.scope, true, true);
                        }
                    };
                    BasePolysParentModel.prototype.createChild = function(model, gMap) {
                        var child, childScope;
                        childScope = this.scope.$new(false);
                        this.setChildScope(IPoly.scopeKeys, childScope, model);
                        childScope.$watch('model', (function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    return _this.setChildScope(childScope, newValue);
                                }
                            };
                        })(this), true);
                        childScope["static"] = this.scope["static"];
                        child = new PolyChildModel(childScope, this.attrs, gMap, this.defaults, model, (function(_this) {
                            return function() {
                                return _this.maybeFit();
                            };
                        })(this));
                        if (model[this.idKey] == null) {
                            this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
                            return;
                        }
                        this.plurals.put(model[this.idKey], child);
                        return child;
                    };
                    BasePolysParentModel.prototype.maybeFit = function(pathPoints) {
                        if (pathPoints == null) {
                            pathPoints = this.plurals.map(function(p) {
                                return p.pathPoints;
                            });
                        }
                        if (this.scope.fit) {
                            pathPoints = _.flatten(pathPoints);
                            return FitHelper.fit(pathPoints, this.gMap);
                        }
                    };
                    return BasePolysParentModel;
                })(ModelKey);
            };
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapCircleParentModel', ['uiGmapLogger', '$timeout', 'uiGmapGmapUtil', 'uiGmapEventsHelper', 'uiGmapCircleOptionsBuilder', function($log, $timeout, GmapUtil, EventsHelper, Builder) {
            var CircleParentModel, _settingFromDirective;
            _settingFromDirective = function(scope, fn) {
                scope.settingFromDirective = true;
                fn();
                return $timeout(function() {
                    return scope.settingFromDirective = false;
                });
            };
            return CircleParentModel = (function(superClass) {
                extend(CircleParentModel, superClass);
                CircleParentModel.include(GmapUtil);
                CircleParentModel.include(EventsHelper);

                function CircleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var clean, gObject, lastRadius;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    this.scope = scope;
                    lastRadius = null;
                    clean = (function(_this) {
                        return function() {
                            lastRadius = null;
                            if (_this.listeners != null) {
                                _this.removeEvents(_this.listeners);
                                return _this.listeners = void 0;
                            }
                        };
                    })(this);
                    gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                    this.setMyOptions = (function(_this) {
                        return function(newVals, oldVals) {
                            if (scope.settingFromDirective) {
                                return;
                            }
                            if (!_.isEqual(newVals, oldVals)) {
                                return gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                            }
                        };
                    })(this);
                    this.props = this.props.concat([{
                        prop: 'center',
                        isColl: true
                    }, {
                        prop: 'fill',
                        isColl: true
                    }, 'radius', 'zIndex']);
                    this.watchProps();
                    if (this.scope.control != null) {
                        this.scope.control.getCircle = function() {
                            return gObject;
                        };
                    }
                    clean();
                    this.listeners = this.setEvents(gObject, scope, scope, ['radius_changed']) || [];
                    this.listeners.push(google.maps.event.addListener(gObject, 'radius_changed', function() {
                        var newRadius, work;
                        newRadius = gObject.getRadius();
                        if (newRadius === lastRadius) {
                            return;
                        }
                        lastRadius = newRadius;
                        work = function() {
                            return _settingFromDirective(scope, function() {
                                var ref, ref1;
                                if (newRadius !== scope.radius) {
                                    scope.radius = newRadius;
                                }
                                if (((ref = scope.events) != null ? ref.radius_changed : void 0) && _.isFunction((ref1 = scope.events) != null ? ref1.radius_changed : void 0)) {
                                    return scope.events.radius_changed(gObject, 'radius_changed', scope, arguments);
                                }
                            });
                        };
                        if (!angular.mock) {
                            return scope.$evalAsync(function() {
                                return work();
                            });
                        } else {
                            return work();
                        }
                    }));
                    this.listeners.push(google.maps.event.addListener(gObject, 'center_changed', function() {
                        return scope.$evalAsync(function() {
                            return _settingFromDirective(scope, function() {
                                if (angular.isDefined(scope.center.type)) {
                                    scope.center.coordinates[1] = gObject.getCenter().lat();
                                    return scope.center.coordinates[0] = gObject.getCenter().lng();
                                } else {
                                    scope.center.latitude = gObject.getCenter().lat();
                                    return scope.center.longitude = gObject.getCenter().lng();
                                }
                            });
                        });
                    }));
                    scope.$on('$destroy', (function(_this) {
                        return function() {
                            clean();
                            return gObject.setMap(null);
                        };
                    })(this));
                    $log.info(this);
                }
                return CircleParentModel;
            })(Builder);
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapDrawingManagerParentModel', ['uiGmapLogger', '$timeout', 'uiGmapBaseObject', 'uiGmapEventsHelper', function($log, $timeout, BaseObject, EventsHelper) {
            var DrawingManagerParentModel;
            return DrawingManagerParentModel = (function(superClass) {
                extend(DrawingManagerParentModel, superClass);
                DrawingManagerParentModel.include(EventsHelper);

                function DrawingManagerParentModel(scope, element, attrs, map) {
                    var gObject, listeners;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    gObject = new google.maps.drawing.DrawingManager(this.scope.options);
                    gObject.setMap(this.map);
                    listeners = void 0;
                    if (this.scope.control != null) {
                        this.scope.control.getDrawingManager = function() {
                            return gObject;
                        };
                    }
                    if (!this.scope["static"] && this.scope.options) {
                        this.scope.$watch('options', function(newValue) {
                            return gObject != null ? gObject.setOptions(newValue) : void 0;
                        }, true);
                    }
                    if (this.scope.events != null) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch('events', (function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    if (listeners != null) {
                                        _this.removeEvents(listeners);
                                    }
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        })(this));
                    }
                    this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            if (listeners != null) {
                                _this.removeEvents(listeners);
                            }
                            gObject.setMap(null);
                            return gObject = null;
                        };
                    })(this));
                }
                return DrawingManagerParentModel;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", ["uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
            var IMarkerParentModel;
            IMarkerParentModel = (function(superClass) {
                extend(IMarkerParentModel, superClass);
                IMarkerParentModel.prototype.DEFAULTS = {};

                function IMarkerParentModel(scope1, element, attrs, map) {
                    this.scope = scope1;
                    this.element = element;
                    this.attrs = attrs;
                    this.map = map;
                    this.onWatch = bind(this.onWatch, this);
                    this.watch = bind(this.watch, this);
                    this.validateScope = bind(this.validateScope, this);
                    IMarkerParentModel.__super__.constructor.call(this, this.scope);
                    this.$log = Logger;
                    if (!this.validateScope(this.scope)) {
                        throw new String("Unable to construct IMarkerParentModel due to invalid scope");
                    }
                    this.doClick = angular.isDefined(this.attrs.click);
                    if (this.scope.options != null) {
                        this.DEFAULTS = this.scope.options;
                    }
                    this.watch('coords', this.scope);
                    this.watch('icon', this.scope);
                    this.watch('options', this.scope);
                    this.scope.$on("$destroy", (function(_this) {
                        return function() {
                            return _this.onDestroy(_this.scope);
                        };
                    })(this));
                }
                IMarkerParentModel.prototype.validateScope = function(scope) {
                    var ret;
                    if (scope == null) {
                        this.$log.error(this.constructor.name + ": invalid scope used");
                        return false;
                    }
                    ret = scope.coords != null;
                    if (!ret) {
                        this.$log.error(this.constructor.name + ": no valid coords attribute found");
                        return false;
                    }
                    return ret;
                };
                IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
                    if (equalityCheck == null) {
                        equalityCheck = true;
                    }
                    return scope.$watch(propNameToWatch, (function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue)) {
                                return _this.onWatch(propNameToWatch, scope, newValue, oldValue);
                            }
                        };
                    })(this), equalityCheck);
                };
                IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
                return IMarkerParentModel;
            })(ModelKey);
            return IMarkerParentModel;
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", ["uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
            var IWindowParentModel;
            return IWindowParentModel = (function(superClass) {
                extend(IWindowParentModel, superClass);
                IWindowParentModel.include(GmapUtil);

                function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
                    IWindowParentModel.__super__.constructor.call(this, scope);
                    this.$log = Logger;
                    this.$timeout = $timeout;
                    this.$compile = $compile;
                    this.$http = $http;
                    this.$templateCache = $templateCache;
                    this.DEFAULTS = {};
                    if (scope.options != null) {
                        this.DEFAULTS = scope.options;
                    }
                }
                IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    if (modelsPropToIterate === 'models') {
                        return scope[modelsPropToIterate][index];
                    }
                    return scope[modelsPropToIterate].get(index);
                };
                return IWindowParentModel;
            })(ModelKey);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapLayerParentModel', ['uiGmapBaseObject', 'uiGmapLogger', '$timeout', function(BaseObject, Logger, $timeout) {
            var LayerParentModel;
            LayerParentModel = (function(superClass) {
                extend(LayerParentModel, superClass);

                function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.onLayerCreated = onLayerCreated != null ? onLayerCreated : void 0;
                    this.$log = $log != null ? $log : Logger;
                    this.createGoogleLayer = bind(this.createGoogleLayer, this);
                    if (this.attrs.type == null) {
                        this.$log.info('type attribute for the layer directive is mandatory. Layer creation aborted!!');
                        return;
                    }
                    this.createGoogleLayer();
                    this.doShow = true;
                    if (angular.isDefined(this.attrs.show)) {
                        this.doShow = this.scope.show;
                    }
                    if (this.doShow && (this.gMap != null)) {
                        this.gObject.setMap(this.gMap);
                    }
                    this.scope.$watch('show', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.doShow = newValue;
                                if (newValue) {
                                    return _this.gObject.setMap(_this.gMap);
                                } else {
                                    return _this.gObject.setMap(null);
                                }
                            }
                        };
                    })(this), true);
                    this.scope.$watch('options', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && _this.doShow) {
                                return _this.gObject.setOptions(newValue);
                            }
                        };
                    })(this), true);
                    this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            return _this.gObject.setMap(null);
                        };
                    })(this));
                }
                LayerParentModel.prototype.createGoogleLayer = function() {
                    var base;
                    if (this.attrs.options == null) {
                        this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]();
                    } else {
                        this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
                    }
                    if ((this.gObject != null) && this.doShow) {
                        this.gObject.setMap(this.gMap);
                    }
                    if ((this.gObject != null) && (this.onLayerCreated != null)) {
                        return typeof(base = this.onLayerCreated(this.scope, this.gObject)) === "function" ? base(this.gObject) : void 0;
                    }
                };
                return LayerParentModel;
            })(BaseObject);
            return LayerParentModel;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapMapTypeParentModel', ['uiGmapBaseObject', 'uiGmapLogger', function(BaseObject, Logger) {
            var MapTypeParentModel;
            MapTypeParentModel = (function(superClass) {
                extend(MapTypeParentModel, superClass);

                function MapTypeParentModel(scope, element, attrs, gMap, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.$log = $log != null ? $log : Logger;
                    this.hideOverlay = bind(this.hideOverlay, this);
                    this.showOverlay = bind(this.showOverlay, this);
                    this.refreshMapType = bind(this.refreshMapType, this);
                    this.createMapType = bind(this.createMapType, this);
                    if (this.attrs.options == null) {
                        this.$log.info('options attribute for the map-type directive is mandatory. Map type creation aborted!!');
                        return;
                    }
                    this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
                    this.doShow = true;
                    this.createMapType();
                    if (angular.isDefined(this.attrs.show)) {
                        this.doShow = this.scope.show;
                    }
                    if (this.doShow && (this.gMap != null)) {
                        this.showOverlay();
                    }
                    this.scope.$watch('show', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.doShow = newValue;
                                if (newValue) {
                                    return _this.showOverlay();
                                } else {
                                    return _this.hideOverlay();
                                }
                            }
                        };
                    })(this), true);
                    this.scope.$watch('options', (function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue)) {
                                return _this.refreshMapType();
                            }
                        };
                    })(this), true);
                    if (angular.isDefined(this.attrs.refresh)) {
                        this.scope.$watch('refresh', (function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    return _this.refreshMapType();
                                }
                            };
                        })(this), true);
                    }
                    this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            _this.hideOverlay();
                            return _this.mapType = null;
                        };
                    })(this));
                }
                MapTypeParentModel.prototype.createMapType = function() {
                    if (this.scope.options.getTile != null) {
                        this.mapType = this.scope.options;
                    } else if (this.scope.options.getTileUrl != null) {
                        this.mapType = new google.maps.ImageMapType(this.scope.options);
                    } else {
                        this.$log.info('options should provide either getTile or getTileUrl methods. Map type creation aborted!!');
                        return;
                    }
                    if (this.attrs.id && this.scope.id) {
                        this.gMap.mapTypes.set(this.scope.id, this.mapType);
                        if (!angular.isDefined(this.attrs.show)) {
                            this.doShow = false;
                        }
                    }
                    return this.mapType.layerId = this.id;
                };
                MapTypeParentModel.prototype.refreshMapType = function() {
                    this.hideOverlay();
                    this.mapType = null;
                    this.createMapType();
                    if (this.doShow && (this.gMap != null)) {
                        return this.showOverlay();
                    }
                };
                MapTypeParentModel.prototype.showOverlay = function() {
                    return this.gMap.overlayMapTypes.push(this.mapType);
                };
                MapTypeParentModel.prototype.hideOverlay = function() {
                    var found;
                    found = false;
                    return this.gMap.overlayMapTypes.forEach((function(_this) {
                        return function(mapType, index) {
                            if (!found && mapType.layerId === _this.id) {
                                found = true;
                                _this.gMap.overlayMapTypes.removeAt(index);
                            }
                        };
                    })(this));
                };
                return MapTypeParentModel;
            })(BaseObject);
            return MapTypeParentModel;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", ["uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapSpiderfierMarkerManager", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log, SpiderfierMarkerManager) {
            var MarkersParentModel, _setPlurals;
            _setPlurals = function(val, objToSet) {
                objToSet.plurals = new PropMap();
                objToSet.scope.plurals = objToSet.plurals;
                return objToSet;
            };
            MarkersParentModel = (function(superClass) {
                extend(MarkersParentModel, superClass);
                MarkersParentModel.include(GmapUtil);
                MarkersParentModel.include(ModelsWatcher);

                function MarkersParentModel(scope, element, attrs, map) {
                    this.maybeExecMappedEvent = bind(this.maybeExecMappedEvent, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.newChildMarker = bind(this.newChildMarker, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.bindToTypeEvents = bind(this.bindToTypeEvents, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.validateScope = bind(this.validateScope, this);
                    this.onWatch = bind(this.onWatch, this);
                    var self;
                    MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
                    this["interface"] = IMarker;
                    self = this;
                    _setPlurals(new PropMap(), this);
                    this.scope.pluralsUpdate = {
                        updateCtr: 0
                    };
                    this.$log.info(this);
                    this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
                    this.setIdKey(this.scope);
                    this.scope.$watch('doRebuildAll', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                return _this.doRebuildAll = newValue;
                            }
                        };
                    })(this));
                    if (!this.modelsLength()) {
                        this.modelsRendered = false;
                    }
                    this.scope.$watch('models', (function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
                                if (newValue.length === 0 && oldValue.length === 0) {
                                    return;
                                }
                                _this.modelsRendered = true;
                                return _this.onWatch('models', _this.scope, newValue, oldValue);
                            }
                        };
                    })(this), !this.isTrue(attrs.modelsbyref));
                    this.watch('doCluster', this.scope);
                    this.watch('type', this.scope);
                    this.watch('clusterOptions', this.scope);
                    this.watch('clusterEvents', this.scope);
                    this.watch('typeOptions', this.scope);
                    this.watch('typeEvents', this.scope);
                    this.watch('fit', this.scope);
                    this.watch('idKey', this.scope);
                    this.gManager = void 0;
                    this.createAllNew(this.scope);
                }
                MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
                    if (propNameToWatch === "idKey" && newValue !== oldValue) {
                        this.idKey = newValue;
                    }
                    if (this.doRebuildAll || (propNameToWatch === 'doCluster' || propNameToWatch === 'type')) {
                        return this.rebuildAll(scope);
                    } else {
                        return this.pieceMeal(scope);
                    }
                };
                MarkersParentModel.prototype.validateScope = function(scope) {
                    var modelsNotDefined;
                    modelsNotDefined = angular.isUndefined(scope.models) || scope.models === void 0;
                    if (modelsNotDefined) {
                        this.$log.error(this.constructor.name + ": no valid models attribute found");
                    }
                    return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
                };
                MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    if ((this.gMap == null) || (this.scope.models == null)) {
                        return;
                    }
                    if (isCreatingFromScratch) {
                        return this.createAllNew(this.scope, false);
                    } else {
                        return this.pieceMeal(this.scope, false);
                    }
                };
                MarkersParentModel.prototype.bindToTypeEvents = function(typeEvents, events) {
                    var internalHandles, self;
                    if (events == null) {
                        events = ['click', 'mouseout', 'mouseover'];
                    }
                    self = this;
                    if (!this.origTypeEvents) {
                        this.origTypeEvents = {};
                        _.each(events, (function(_this) {
                            return function(eventName) {
                                return _this.origTypeEvents[eventName] = typeEvents != null ? typeEvents[eventName] : void 0;
                            };
                        })(this));
                    } else {
                        angular.extend(typeEvents, this.origTypeEvents);
                    }
                    internalHandles = {};
                    _.each(events, (function(_this) {
                        return function(eventName) {
                            return internalHandles[eventName] = function(group) {
                                return self.maybeExecMappedEvent(group, eventName);
                            };
                        };
                    })(this));
                    return angular.extend(typeEvents, internalHandles);
                };
                MarkersParentModel.prototype.createAllNew = function(scope) {
                    var isSpiderfied, maybeCanceled, typeEvents, typeOptions;
                    if (this.gManager != null) {
                        if (this.gManager instanceof SpiderfierMarkerManager) {
                            isSpiderfied = this.gManager.isSpiderfied();
                        }
                        this.gManager.clear();
                        delete this.gManager;
                    }
                    typeEvents = scope.typeEvents || scope.clusterEvents;
                    typeOptions = scope.typeOptions || scope.clusterOptions;
                    if (scope.doCluster || scope.type === 'cluster') {
                        if (typeEvents != null) {
                            this.bindToTypeEvents(typeEvents);
                        }
                        this.gManager = new ClustererMarkerManager(this.map, void 0, typeOptions, typeEvents);
                    } else if (scope.type === 'spider') {
                        if (typeEvents != null) {
                            this.bindToTypeEvents(typeEvents, ['spiderfy', 'unspiderfy']);
                        }
                        this.gManager = new SpiderfierMarkerManager(this.map, void 0, typeOptions, typeEvents, this.scope);
                        if (isSpiderfied) {
                            this.gManager.spiderfy();
                        }
                    } else {
                        this.gManager = new MarkerManager(this.map);
                    }
                    if (this.didQueueInitPromise(this, scope)) {
                        return;
                    }
                    maybeCanceled = null;
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
                        return maybeCanceled = canceledMsg;
                    }), (function(_this) {
                        return function() {
                            return _async.each(scope.models, function(model) {
                                _this.newChildMarker(model, scope);
                                return maybeCanceled;
                            }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                _this.modelsRendered = true;
                                if (scope.fit) {
                                    _this.gManager.fit();
                                }
                                _this.gManager.draw();
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            }, _async.chunkSizeFrom(scope.chunk));
                        };
                    })(this));
                };
                MarkersParentModel.prototype.rebuildAll = function(scope) {
                    var ref;
                    if (!scope.doRebuild && scope.doRebuild !== void 0) {
                        return;
                    }
                    if ((ref = this.scope.plurals) != null ? ref.length : void 0) {
                        return this.onDestroy(scope).then((function(_this) {
                            return function() {
                                return _this.createAllNew(scope);
                            };
                        })(this));
                    } else {
                        return this.createAllNew(scope);
                    }
                };
                MarkersParentModel.prototype.pieceMeal = function(scope) {
                    var maybeCanceled, payload;
                    if (scope.$$destroyed) {
                        return;
                    }
                    maybeCanceled = null;
                    payload = null;
                    if (this.modelsLength() && this.scope.plurals.length) {
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }), (function(_this) {
                            return function() {
                                return uiGmapPromise.promise((function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
                                })).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (child != null) {
                                            if (child.destroy != null) {
                                                child.destroy();
                                            }
                                            _this.scope.plurals.remove(child.id);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        _this.newChildMarker(modelToAdd, scope);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
                                        scope.plurals = _this.scope.plurals;
                                        if (scope.fit) {
                                            _this.gManager.fit();
                                        }
                                        _this.gManager.draw();
                                    }
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                });
                            };
                        })(this));
                    } else {
                        this.inProgress = false;
                        return this.rebuildAll(scope);
                    }
                };
                MarkersParentModel.prototype.newChildMarker = function(model, scope) {
                    var child, childScope, doDrawSelf, keys;
                    if (model[this.idKey] == null) {
                        this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                        return;
                    }
                    this.$log.info('child', child, 'markers', this.scope.markerModels);
                    childScope = scope.$new(false);
                    childScope.events = scope.events;
                    keys = {};
                    IMarker.scopeKeys.forEach(function(k) {
                        return keys[k] = scope[k];
                    });
                    child = new MarkerChildModel(childScope, model, keys, this.map, this.DEFAULTS, this.doClick, this.gManager, doDrawSelf = false);
                    this.scope.plurals.put(model[this.idKey], child);
                    return child;
                };
                MarkersParentModel.prototype.onDestroy = function(scope) {
                    MarkersParentModel.__super__.onDestroy.call(this, scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
                        return function() {
                            return _async.each(_this.scope.plurals.values(), function(model) {
                                if (model != null) {
                                    return model.destroy(false);
                                }
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                                if (_this.gManager != null) {
                                    _this.gManager.destroy();
                                }
                                _this.plurals.removeAll();
                                if (_this.plurals !== _this.scope.plurals) {
                                    console.error('plurals out of sync for MarkersParentModel');
                                }
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            });
                        };
                    })(this));
                };
                MarkersParentModel.prototype.maybeExecMappedEvent = function(group, fnName) {
                    var pair, typeEvents;
                    if (this.scope.$$destroyed) {
                        return;
                    }
                    typeEvents = this.scope.typeEvents || this.scope.clusterEvents;
                    if (_.isFunction(typeEvents != null ? typeEvents[fnName] : void 0)) {
                        pair = this.mapTypeToPlurals(group);
                        if (this.origTypeEvents[fnName]) {
                            return this.origTypeEvents[fnName](pair.group, pair.mapped);
                        }
                    }
                };
                MarkersParentModel.prototype.mapTypeToPlurals = function(group) {
                    var arrayToMap, mapped, ref;
                    if (_.isArray(group)) {
                        arrayToMap = group;
                    } else if (_.isFunction(group.getMarkers)) {
                        arrayToMap = group.getMarkers();
                    }
                    if (arrayToMap == null) {
                        $log.error("Unable to map event as we cannot find the array group to map");
                        return;
                    }
                    if ((ref = this.scope.plurals.values()) != null ? ref.length : void 0) {
                        mapped = arrayToMap.map((function(_this) {
                            return function(g) {
                                return _this.scope.plurals.get(g.key).model;
                            };
                        })(this));
                    } else {
                        mapped = [];
                    }
                    return {
                        cluster: group,
                        mapped: mapped,
                        group: group
                    };
                };
                MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    if (modelsPropToIterate === 'models') {
                        return scope[modelsPropToIterate][index];
                    }
                    return scope[modelsPropToIterate].get(index);
                };
                return MarkersParentModel;
            })(IMarkerParentModel);
            return MarkersParentModel;
        }]);
    }).call(this);;
    (function() {
        ['Polygon', 'Polyline'].forEach(function(name) {
            return angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory("uiGmap" + name + "sParentModel", ['uiGmapBasePolysParentModel', "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
                return BasePolysParentModel(IPoly, ChildModel, name);
            }]);
        });
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapRectangleParentModel', ['uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapEventsHelper', 'uiGmapRectangleOptionsBuilder', function($log, GmapUtil, EventsHelper, Builder) {
            var RectangleParentModel;
            return RectangleParentModel = (function(superClass) {
                extend(RectangleParentModel, superClass);
                RectangleParentModel.include(GmapUtil);
                RectangleParentModel.include(EventsHelper);

                function RectangleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var bounds, clear, createBounds, dragging, fit, gObject, init, listeners, myListeners, settingBoundsFromScope, updateBounds;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    bounds = void 0;
                    dragging = false;
                    myListeners = [];
                    listeners = void 0;
                    fit = (function(_this) {
                        return function() {
                            if (_this.isTrue(_this.attrs.fit)) {
                                return _this.fitMapBounds(_this.map, bounds);
                            }
                        };
                    })(this);
                    createBounds = (function(_this) {
                        return function() {
                            var ref, ref1, ref2;
                            if ((_this.scope.bounds != null) && (((ref = _this.scope.bounds) != null ? ref.sw : void 0) != null) && (((ref1 = _this.scope.bounds) != null ? ref1.ne : void 0) != null) && _this.validateBoundPoints(_this.scope.bounds)) {
                                bounds = _this.convertBoundPoints(_this.scope.bounds);
                                return $log.info("new new bounds created: " + (JSON.stringify(bounds)));
                            } else if ((_this.scope.bounds.getNorthEast != null) && (_this.scope.bounds.getSouthWest != null)) {
                                return bounds = _this.scope.bounds;
                            } else {
                                if (_this.scope.bounds != null) {
                                    return $log.error("Invalid bounds for newValue: " + (JSON.stringify((ref2 = _this.scope) != null ? ref2.bounds : void 0)));
                                }
                            }
                        };
                    })(this);
                    createBounds();
                    gObject = new google.maps.Rectangle(this.buildOpts(bounds));
                    $log.info("gObject (rectangle) created: " + gObject);
                    settingBoundsFromScope = false;
                    updateBounds = (function(_this) {
                        return function() {
                            var b, ne, sw;
                            b = gObject.getBounds();
                            ne = b.getNorthEast();
                            sw = b.getSouthWest();
                            if (settingBoundsFromScope) {
                                return;
                            }
                            return _this.scope.$evalAsync(function(s) {
                                if ((s.bounds != null) && (s.bounds.sw != null) && (s.bounds.ne != null)) {
                                    s.bounds.ne = {
                                        latitude: ne.lat(),
                                        longitude: ne.lng()
                                    };
                                    s.bounds.sw = {
                                        latitude: sw.lat(),
                                        longitude: sw.lng()
                                    };
                                }
                                if ((s.bounds.getNorthEast != null) && (s.bounds.getSouthWest != null)) {
                                    return s.bounds = b;
                                }
                            });
                        };
                    })(this);
                    init = (function(_this) {
                        return function() {
                            fit();
                            _this.removeEvents(myListeners);
                            myListeners.push(google.maps.event.addListener(gObject, 'dragstart', function() {
                                return dragging = true;
                            }));
                            myListeners.push(google.maps.event.addListener(gObject, 'dragend', function() {
                                dragging = false;
                                return updateBounds();
                            }));
                            return myListeners.push(google.maps.event.addListener(gObject, 'bounds_changed', function() {
                                if (dragging) {
                                    return;
                                }
                                return updateBounds();
                            }));
                        };
                    })(this);
                    clear = (function(_this) {
                        return function() {
                            _this.removeEvents(myListeners);
                            if (listeners != null) {
                                _this.removeEvents(listeners);
                            }
                            return gObject.setMap(null);
                        };
                    })(this);
                    if (bounds != null) {
                        init();
                    }
                    this.scope.$watch('bounds', (function(newValue, oldValue) {
                        var isNew;
                        if (_.isEqual(newValue, oldValue) && (bounds != null) || dragging) {
                            return;
                        }
                        settingBoundsFromScope = true;
                        if (newValue == null) {
                            clear();
                            return;
                        }
                        if (bounds == null) {
                            isNew = true;
                        } else {
                            fit();
                        }
                        createBounds();
                        gObject.setBounds(bounds);
                        settingBoundsFromScope = false;
                        if (isNew && (bounds != null)) {
                            return init();
                        }
                    }), true);
                    this.setMyOptions = (function(_this) {
                        return function(newVals, oldVals) {
                            if (!_.isEqual(newVals, oldVals)) {
                                if ((bounds != null) && (newVals != null)) {
                                    return gObject.setOptions(_this.buildOpts(bounds));
                                }
                            }
                        };
                    })(this);
                    this.props.push('bounds');
                    this.watchProps(this.props);
                    if (this.attrs.events != null) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch('events', (function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    if (listeners != null) {
                                        _this.removeEvents(listeners);
                                    }
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        })(this));
                    }
                    this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            return clear();
                        };
                    })(this));
                    $log.info(this);
                }
                return RectangleParentModel;
            })(Builder);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapSearchBoxParentModel', ['uiGmapBaseObject', 'uiGmapLogger', 'uiGmapEventsHelper', '$timeout', '$http', '$templateCache', function(BaseObject, Logger, EventsHelper, $timeout, $http, $templateCache) {
            var SearchBoxParentModel;
            SearchBoxParentModel = (function(superClass) {
                extend(SearchBoxParentModel, superClass);
                SearchBoxParentModel.include(EventsHelper);

                function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
                    var controlDiv;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.ctrlPosition = ctrlPosition;
                    this.template = template;
                    this.$log = $log != null ? $log : Logger;
                    this.setVisibility = bind(this.setVisibility, this);
                    this.getBounds = bind(this.getBounds, this);
                    this.setBounds = bind(this.setBounds, this);
                    this.createSearchBox = bind(this.createSearchBox, this);
                    this.addToParentDiv = bind(this.addToParentDiv, this);
                    this.addAsMapControl = bind(this.addAsMapControl, this);
                    this.init = bind(this.init, this);
                    if (this.attrs.template == null) {
                        this.$log.error('template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!');
                        return;
                    }
                    if (angular.isUndefined(this.scope.options)) {
                        this.scope.options = {};
                        this.scope.options.visible = true;
                    }
                    if (angular.isUndefined(this.scope.options.visible)) {
                        this.scope.options.visible = true;
                    }
                    if (angular.isUndefined(this.scope.options.autocomplete)) {
                        this.scope.options.autocomplete = false;
                    }
                    this.visible = this.scope.options.visible;
                    this.autocomplete = this.scope.options.autocomplete;
                    controlDiv = angular.element('<div></div>');
                    controlDiv.append(this.template);
                    this.input = controlDiv.find('input')[0];
                    this.init();
                }
                SearchBoxParentModel.prototype.init = function() {
                    this.createSearchBox();
                    this.scope.$watch('options', (function(_this) {
                        return function(newValue, oldValue) {
                            if (angular.isObject(newValue)) {
                                if (newValue.bounds != null) {
                                    _this.setBounds(newValue.bounds);
                                }
                                if (newValue.visible != null) {
                                    if (_this.visible !== newValue.visible) {
                                        return _this.setVisibility(newValue.visible);
                                    }
                                }
                            }
                        };
                    })(this), true);
                    if (this.attrs.parentdiv != null) {
                        this.addToParentDiv();
                    } else {
                        this.addAsMapControl();
                    }
                    if (!this.visible) {
                        this.setVisibility(this.visible);
                    }
                    if (this.autocomplete) {
                        this.listener = google.maps.event.addListener(this.gObject, 'place_changed', (function(_this) {
                            return function() {
                                return _this.places = _this.gObject.getPlace();
                            };
                        })(this));
                    } else {
                        this.listener = google.maps.event.addListener(this.gObject, 'places_changed', (function(_this) {
                            return function() {
                                return _this.places = _this.gObject.getPlaces();
                            };
                        })(this));
                    }
                    this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
                    this.$log.info(this);
                    return this.scope.$on('$destroy', (function(_this) {
                        return function() {
                            return _this.gObject = null;
                        };
                    })(this));
                };
                SearchBoxParentModel.prototype.addAsMapControl = function() {
                    return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                };
                SearchBoxParentModel.prototype.addToParentDiv = function() {
                    this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
                    return this.parentDiv.append(this.input);
                };
                SearchBoxParentModel.prototype.createSearchBox = function() {
                    if (this.autocomplete) {
                        return this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options);
                    } else {
                        return this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
                    }
                };
                SearchBoxParentModel.prototype.setBounds = function(bounds) {
                    if (angular.isUndefined(bounds.isEmpty)) {
                        this.$log.error('Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds.');
                    } else {
                        if (bounds.isEmpty() === false) {
                            if (this.gObject != null) {
                                return this.gObject.setBounds(bounds);
                            }
                        }
                    }
                };
                SearchBoxParentModel.prototype.getBounds = function() {
                    return this.gObject.getBounds();
                };
                SearchBoxParentModel.prototype.setVisibility = function(val) {
                    if (this.attrs.parentdiv != null) {
                        if (val === false) {
                            this.parentDiv.addClass("ng-hide");
                        } else {
                            this.parentDiv.removeClass("ng-hide");
                        }
                    } else {
                        if (val === false) {
                            this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear();
                        } else {
                            this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                        }
                    }
                    return this.visible = val;
                };
                return SearchBoxParentModel;
            })(BaseObject);
            return SearchBoxParentModel;
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapWindowsParentModel', ['uiGmapIWindowParentModel', 'uiGmapModelsWatcher', 'uiGmapPropMap', 'uiGmapWindowChildModel', 'uiGmapLinked', 'uiGmap_async', 'uiGmapLogger', '$timeout', '$compile', '$http', '$templateCache', '$interpolate', 'uiGmapPromise', 'uiGmapIWindow', 'uiGmapGmapUtil', function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
            var WindowsParentModel;
            WindowsParentModel = (function(superClass) {
                extend(WindowsParentModel, superClass);
                WindowsParentModel.include(ModelsWatcher);

                function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
                    this.gMap = gMap1;
                    this.markersScope = markersScope;
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    this.interpolateContent = bind(this.interpolateContent, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.createWindow = bind(this.createWindow, this);
                    this.setContentKeys = bind(this.setContentKeys, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.watchIdKey = bind(this.watchIdKey, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.watchOurScope = bind(this.watchOurScope, this);
                    this.watchDestroy = bind(this.watchDestroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.doINeedToWipe = bind(this.doINeedToWipe, this);
                    this.watchModels = bind(this.watchModels, this);
                    this.go = bind(this.go, this);
                    WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
                    this["interface"] = IWindow;
                    this.plurals = new PropMap();
                    _.each(IWindow.scopeKeys, (function(_this) {
                        return function(name) {
                            return _this[name + 'Key'] = void 0;
                        };
                    })(this));
                    this.linked = new Linked(scope, element, attrs, ctrls);
                    this.contentKeys = void 0;
                    this.isIconVisibleOnClick = void 0;
                    this.firstTime = true;
                    this.firstWatchModels = true;
                    this.$log.info(self);
                    this.parentScope = void 0;
                    this.go(scope);
                }
                WindowsParentModel.prototype.go = function(scope) {
                    this.watchOurScope(scope);
                    this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
                    scope.$watch('doRebuildAll', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                return _this.doRebuildAll = newValue;
                            }
                        };
                    })(this));
                    return this.createChildScopes();
                };
                WindowsParentModel.prototype.watchModels = function(scope) {
                    var itemToWatch;
                    itemToWatch = this.markersScope != null ? 'pluralsUpdate' : 'models';
                    return scope.$watch(itemToWatch, (function(_this) {
                        return function(newValue, oldValue) {
                            var doScratch;
                            if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
                                _this.firstWatchModels = false;
                                if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) {
                                    return _this.rebuildAll(scope, true, true);
                                } else {
                                    doScratch = _this.plurals.length === 0;
                                    if (_this.existingPieces != null) {
                                        return _.last(_this.existingPieces._content).then(function() {
                                            return _this.createChildScopes(doScratch);
                                        });
                                    } else {
                                        return _this.createChildScopes(doScratch);
                                    }
                                }
                            }
                        };
                    })(this), true);
                };
                WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
                    var newValueIsEmpty;
                    newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
                    return this.plurals.length > 0 && newValueIsEmpty;
                };
                WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                    return this.onDestroy(doDelete).then((function(_this) {
                        return function() {
                            if (doCreate) {
                                return _this.createChildScopes();
                            }
                        };
                    })(this));
                };
                WindowsParentModel.prototype.onDestroy = function(scope) {
                    WindowsParentModel.__super__.onDestroy.call(this, this.scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
                        return function() {
                            return _async.each(_this.plurals.values(), function(child) {
                                return child.destroy();
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
                                var ref;
                                return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
                            });
                        };
                    })(this));
                };
                WindowsParentModel.prototype.watchDestroy = function(scope) {
                    return scope.$on('$destroy', (function(_this) {
                        return function() {
                            _this.firstWatchModels = true;
                            _this.firstTime = true;
                            return _this.rebuildAll(scope, false, true);
                        };
                    })(this));
                };
                WindowsParentModel.prototype.watchOurScope = function(scope) {
                    return _.each(IWindow.scopeKeys, (function(_this) {
                        return function(name) {
                            var nameKey;
                            nameKey = name + 'Key';
                            return _this[nameKey] = typeof scope[name] === 'function' ? scope[name]() : scope[name];
                        };
                    })(this));
                };
                WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    var modelsNotDefined, ref, ref1;
                    if (isCreatingFromScratch == null) {
                        isCreatingFromScratch = true;
                    }
                    this.isIconVisibleOnClick = true;
                    if (angular.isDefined(this.linked.attrs.isiconvisibleonclick)) {
                        this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick;
                    }
                    modelsNotDefined = angular.isUndefined(this.linked.scope.models);
                    if (modelsNotDefined && (this.markersScope === void 0 || (((ref = this.markersScope) != null ? ref.plurals : void 0) === void 0 || ((ref1 = this.markersScope) != null ? ref1.models : void 0) === void 0))) {
                        this.$log.error('No models to create windows from! Need direct models or models derived from markers!');
                        return;
                    }
                    if (this.gMap != null) {
                        if (this.linked.scope.models != null) {
                            this.watchIdKey(this.linked.scope);
                            if (isCreatingFromScratch) {
                                return this.createAllNew(this.linked.scope, false);
                            } else {
                                return this.pieceMeal(this.linked.scope, false);
                            }
                        } else {
                            this.parentScope = this.markersScope;
                            this.watchIdKey(this.parentScope);
                            if (isCreatingFromScratch) {
                                return this.createAllNew(this.markersScope, true, 'plurals', false);
                            } else {
                                return this.pieceMeal(this.markersScope, true, 'plurals', false);
                            }
                        }
                    }
                };
                WindowsParentModel.prototype.watchIdKey = function(scope) {
                    this.setIdKey(scope);
                    return scope.$watch('idKey', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && (newValue == null)) {
                                _this.idKey = newValue;
                                return _this.rebuildAll(scope, true, true);
                            }
                        };
                    })(this));
                };
                WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled;
                    if (modelsPropToIterate == null) {
                        modelsPropToIterate = 'models';
                    }
                    if (isArray == null) {
                        isArray = false;
                    }
                    if (this.firstTime) {
                        this.watchModels(scope);
                        this.watchDestroy(scope);
                    }
                    this.setContentKeys(scope.models);
                    if (this.didQueueInitPromise(this, scope)) {
                        return;
                    }
                    maybeCanceled = null;
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
                        return maybeCanceled = canceledMsg;
                    }), (function(_this) {
                        return function() {
                            return _async.each(scope.models, function(model) {
                                var gMarker, ref;
                                gMarker = hasGMarker ? (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) != null ? ref.gObject : void 0 : void 0;
                                if (!maybeCanceled) {
                                    if (!gMarker && _this.markersScope) {
                                        $log.error('Unable to get gMarker from markersScope!');
                                    }
                                    _this.createWindow(model, gMarker, _this.gMap);
                                }
                                return maybeCanceled;
                            }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                return _this.firstTime = false;
                            });
                        };
                    })(this));
                };
                WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled, payload;
                    if (modelsPropToIterate == null) {
                        modelsPropToIterate = 'models';
                    }
                    if (isArray == null) {
                        isArray = true;
                    }
                    if (scope.$$destroyed) {
                        return;
                    }
                    maybeCanceled = null;
                    payload = null;
                    if ((scope != null) && this.modelsLength() && this.plurals.length) {
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }), (function(_this) {
                            return function() {
                                return uiGmapPromise.promise((function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                })).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (child != null) {
                                            _this.plurals.remove(child.id);
                                            if (child.destroy != null) {
                                                child.destroy(true);
                                            }
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        var gMarker, ref;
                                        gMarker = (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) != null ? ref.gObject : void 0;
                                        if (!gMarker) {
                                            throw 'Gmarker undefined';
                                        }
                                        _this.createWindow(modelToAdd, gMarker, _this.gMap);
                                        return maybeCanceled;
                                    });
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                });
                            };
                        })(this));
                    } else {
                        $log.debug('pieceMeal: rebuildAll');
                        return this.rebuildAll(this.scope, true, true);
                    }
                };
                WindowsParentModel.prototype.setContentKeys = function(models) {
                    if (this.modelsLength(models)) {
                        return this.contentKeys = Object.keys(models[0]);
                    }
                };
                WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
                    var child, childScope, fakeElement, opts, ref, ref1;
                    childScope = this.linked.scope.$new(false);
                    this.setChildScope(childScope, model);
                    childScope.$watch('model', (function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                return _this.setChildScope(childScope, newValue);
                            }
                        };
                    })(this), true);
                    fakeElement = {
                        html: (function(_this) {
                            return function() {
                                return _this.interpolateContent(_this.linked.element.html(), model);
                            };
                        })(this)
                    };
                    this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
                    opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
                    child = new WindowChildModel(model, childScope, opts, this.isIconVisibleOnClick, gMap, (ref = this.markersScope) != null ? (ref1 = ref.plurals.get(model[this.idKey])) != null ? ref1.scope : void 0 : void 0, fakeElement, false, true);
                    if (model[this.idKey] == null) {
                        this.$log.error('Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.');
                        return;
                    }
                    this.plurals.put(model[this.idKey], child);
                    return child;
                };
                WindowsParentModel.prototype.setChildScope = function(childScope, model) {
                    _.each(IWindow.scopeKeys, (function(_this) {
                        return function(name) {
                            var nameKey, newValue;
                            nameKey = name + 'Key';
                            newValue = _this[nameKey] === 'self' ? model : model[_this[nameKey]];
                            if (newValue !== childScope[name]) {
                                return childScope[name] = newValue;
                            }
                        };
                    })(this));
                    return childScope.model = model;
                };
                WindowsParentModel.prototype.interpolateContent = function(content, model) {
                    var exp, i, interpModel, key, len, ref;
                    if (this.contentKeys === void 0 || this.contentKeys.length === 0) {
                        return;
                    }
                    exp = $interpolate(content);
                    interpModel = {};
                    ref = this.contentKeys;
                    for (i = 0, len = ref.length; i < len; i++) {
                        key = ref[i];
                        interpModel[key] = model[key];
                    }
                    return exp(interpModel);
                };
                WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
                    var isEqual, scope;
                    scope = this.scope.coords != null ? this.scope : this.parentScope;
                    if (scope == null) {
                        throw 'No scope or parentScope set!';
                    }
                    isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                    if (!isEqual) {
                        return isEqual;
                    }
                    isEqual = _.every(_.without(this["interface"].scopeKeys, 'coords'), (function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    })(this));
                    return isEqual;
                };
                return WindowsParentModel;
            })(IWindowParentModel);
            return WindowsParentModel;
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", ["uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
            return _.extend(ICircle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then((function(_this) {
                        return function(map) {
                            return new CircleParentModel(scope, element, attrs, map);
                        };
                    })(this));
                }
            });
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", ["uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", 'uiGmapGoogleMapApi', function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
            var Control;
            return Control = (function(superClass) {
                extend(Control, superClass);

                function Control() {
                    this.link = bind(this.link, this);
                    Control.__super__.constructor.call(this);
                }
                Control.prototype.link = function(scope, element, attrs, ctrl) {
                    return GoogleMapApi.then((function(_this) {
                        return function(maps) {
                            var index, position;
                            if (angular.isUndefined(scope.template)) {
                                _this.$log.error('mapControl: could not find a valid template property');
                                return;
                            }
                            index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
                            position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, '_') : 'TOP_CENTER';
                            if (!maps.ControlPosition[position]) {
                                _this.$log.error('mapControl: invalid position property');
                                return;
                            }
                            return IControl.mapPromise(scope, ctrl).then(function(map) {
                                var control, controlDiv;
                                control = void 0;
                                controlDiv = angular.element('<div></div>');
                                return $http.get(scope.template, {
                                    cache: $templateCache
                                }).success(function(template) {
                                    var templateCtrl, templateScope;
                                    templateScope = scope.$new();
                                    controlDiv.append(template);
                                    if (angular.isDefined(scope.controller)) {
                                        templateCtrl = $controller(scope.controller, {
                                            $scope: templateScope
                                        });
                                        controlDiv.children().data('$ngControllerController', templateCtrl);
                                    }
                                    control = $compile(controlDiv.children())(templateScope);
                                    if (index) {
                                        return control[0].index = index;
                                    }
                                }).error(function(error) {
                                    return _this.$log.error('mapControl: template could not be found');
                                }).then(function() {
                                    return map.controls[google.maps.ControlPosition[position]].push(control[0]);
                                });
                            });
                        };
                    })(this));
                };
                return Control;
            })(IControl);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapDragZoom', ['uiGmapCtrlHandle', 'uiGmapPropertyAction', function(CtrlHandle, PropertyAction) {
            return {
                restrict: 'EMA',
                transclude: true,
                template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
                require: '^' + 'uiGmapGoogleMap',
                scope: {
                    keyboardkey: '=',
                    options: '=',
                    spec: '='
                },
                controller: ['$scope', '$element', function($scope, $element) {
                    $scope.ctrlType = 'uiGmapDragZoom';
                    return _.extend(this, CtrlHandle.handle($scope, $element));
                }],
                link: function(scope, element, attrs, ctrl) {
                    return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
                        var enableKeyDragZoom, setKeyAction, setOptionsAction;
                        enableKeyDragZoom = function(opts) {
                            map.enableKeyDragZoom(opts);
                            if (scope.spec) {
                                return scope.spec.enableKeyDragZoom(opts);
                            }
                        };
                        setKeyAction = new PropertyAction(function(key, newVal) {
                            if (newVal) {
                                return enableKeyDragZoom({
                                    key: newVal
                                });
                            } else {
                                return enableKeyDragZoom();
                            }
                        });
                        setOptionsAction = new PropertyAction(function(key, newVal) {
                            if (newVal) {
                                return enableKeyDragZoom(newVal);
                            }
                        });
                        scope.$watch('keyboardkey', setKeyAction.sic);
                        setKeyAction.sic(scope.keyboardkey);
                        scope.$watch('options', setOptionsAction.sic);
                        return setOptionsAction.sic(scope.options);
                    });
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", ["uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
            return _.extend(IDrawingManager, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(map) {
                        return new DrawingManagerParentModel(scope, element, attrs, map);
                    });
                }
            });
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapApiFreeDrawPolygons', ['uiGmapLogger', 'uiGmapBaseObject', 'uiGmapCtrlHandle', 'uiGmapDrawFreeHandChildModel', 'uiGmapLodash', function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
            var FreeDrawPolygons;
            return FreeDrawPolygons = (function(superClass) {
                extend(FreeDrawPolygons, superClass);

                function FreeDrawPolygons() {
                    this.link = bind(this.link, this);
                    return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
                }
                FreeDrawPolygons.include(CtrlHandle);
                FreeDrawPolygons.prototype.restrict = 'EMA';
                FreeDrawPolygons.prototype.replace = true;
                FreeDrawPolygons.prototype.require = '^' + 'uiGmapGoogleMap';
                FreeDrawPolygons.prototype.scope = {
                    polygons: '=',
                    draw: '='
                };
                FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
                    return this.mapPromise(scope, ctrl).then((function(_this) {
                        return function(map) {
                            var freeHand, listener;
                            if (!scope.polygons) {
                                return $log.error('No polygons to bind to!');
                            }
                            if (!_.isArray(scope.polygons)) {
                                return $log.error('Free Draw Polygons must be of type Array!');
                            }
                            freeHand = new DrawFreeHandChildModel(map, ctrl.getScope());
                            listener = void 0;
                            return scope.draw = function() {
                                if (typeof listener === "function") {
                                    listener();
                                }
                                return freeHand.engage(scope.polygons).then(function() {
                                    var firstTime;
                                    firstTime = true;
                                    return listener = scope.$watchCollection('polygons', function(newValue, oldValue) {
                                        var removals;
                                        if (firstTime || newValue === oldValue) {
                                            firstTime = false;
                                            return;
                                        }
                                        removals = uiGmapLodash.differenceObjects(oldValue, newValue);
                                        return removals.forEach(function(p) {
                                            return p.setMap(null);
                                        });
                                    });
                                });
                            };
                        };
                    })(this));
                };
                return FreeDrawPolygons;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EA",
                replace: true,
                require: '^' + 'uiGmapGoogleMap',
                scope: {
                    center: "=center",
                    radius: "=radius",
                    stroke: "=stroke",
                    fill: "=fill",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=icons",
                    visible: "=",
                    events: "=",
                    control: "=",
                    zIndex: "=zindex"
                }
            };
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", ["uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
            var IControl;
            return IControl = (function(superClass) {
                extend(IControl, superClass);
                IControl.extend(CtrlHandle);

                function IControl() {
                    this.restrict = 'EA';
                    this.replace = true;
                    this.require = '^' + 'uiGmapGoogleMap';
                    this.scope = {
                        template: '@template',
                        position: '@position',
                        controller: '@controller',
                        index: '@index'
                    };
                    this.$log = Logger;
                }
                IControl.prototype.link = function(scope, element, attrs, ctrl) {
                    throw new Exception("Not implemented!!");
                };
                return IControl;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapIDrawingManager', [function() {
            return {
                restrict: 'EA',
                replace: true,
                require: '^' + 'uiGmapGoogleMap',
                scope: {
                    "static": '@',
                    control: '=',
                    options: '=',
                    events: '='
                }
            };
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIMarker', ['uiGmapBaseObject', 'uiGmapCtrlHandle', function(BaseObject, CtrlHandle) {
            var IMarker;
            return IMarker = (function(superClass) {
                extend(IMarker, superClass);
                IMarker.scope = {
                    coords: '=coords',
                    icon: '=icon',
                    click: '&click',
                    options: '=options',
                    events: '=events',
                    fit: '=fit',
                    idKey: '=idkey',
                    control: '=control'
                };
                IMarker.scopeKeys = _.keys(IMarker.scope);
                IMarker.keys = IMarker.scopeKeys;
                IMarker.extend(CtrlHandle);

                function IMarker() {
                    this.restrict = 'EMA';
                    this.require = '^' + 'uiGmapGoogleMap';
                    this.priority = -1;
                    this.transclude = true;
                    this.replace = true;
                    this.scope = _.extend(this.scope || {}, IMarker.scope);
                }
                return IMarker;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIPolygon', ['uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapCtrlHandle', function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolygon;
            return IPolygon = (function(superClass) {
                extend(IPolygon, superClass);
                IPolygon.scope = {
                    path: '=path',
                    stroke: '=stroke',
                    clickable: '=',
                    draggable: '=',
                    editable: '=',
                    geodesic: '=',
                    fill: '=',
                    icons: '=icons',
                    visible: '=',
                    "static": '=',
                    events: '=',
                    zIndex: '=zindex',
                    fit: '=',
                    control: '=control'
                };
                IPolygon.scopeKeys = _.keys(IPolygon.scope);
                IPolygon.include(GmapUtil);
                IPolygon.extend(CtrlHandle);

                function IPolygon() {}
                IPolygon.prototype.restrict = 'EMA';
                IPolygon.prototype.replace = true;
                IPolygon.prototype.require = '^' + 'uiGmapGoogleMap';
                IPolygon.prototype.scope = IPolygon.scope;
                IPolygon.prototype.DEFAULTS = {};
                IPolygon.prototype.$log = Logger;
                return IPolygon;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIPolyline', ['uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapCtrlHandle', function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolyline;
            return IPolyline = (function(superClass) {
                extend(IPolyline, superClass);
                IPolyline.scope = {
                    path: '=',
                    stroke: '=',
                    clickable: '=',
                    draggable: '=',
                    editable: '=',
                    geodesic: '=',
                    icons: '=',
                    visible: '=',
                    "static": '=',
                    fit: '=',
                    events: '=',
                    zIndex: '=zindex'
                };
                IPolyline.scopeKeys = _.keys(IPolyline.scope);
                IPolyline.include(GmapUtil);
                IPolyline.extend(CtrlHandle);

                function IPolyline() {}
                IPolyline.prototype.restrict = 'EMA';
                IPolyline.prototype.replace = true;
                IPolyline.prototype.require = '^' + 'uiGmapGoogleMap';
                IPolyline.prototype.scope = IPolyline.scope;
                IPolyline.prototype.DEFAULTS = {};
                IPolyline.prototype.$log = Logger;
                return IPolyline;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapIRectangle', [function() {
            'use strict';
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: 'EMA',
                require: '^' + 'uiGmapGoogleMap',
                replace: true,
                scope: {
                    bounds: '=',
                    stroke: '=',
                    clickable: '=',
                    draggable: '=',
                    editable: '=',
                    fill: '=',
                    visible: '=',
                    events: '='
                }
            };
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIWindow', ['uiGmapBaseObject', 'uiGmapChildEvents', 'uiGmapCtrlHandle', function(BaseObject, ChildEvents, CtrlHandle) {
            var IWindow;
            return IWindow = (function(superClass) {
                extend(IWindow, superClass);
                IWindow.scope = {
                    coords: '=coords',
                    template: '=template',
                    templateUrl: '=templateurl',
                    templateParameter: '=templateparameter',
                    isIconVisibleOnClick: '=isiconvisibleonclick',
                    closeClick: '&closeclick',
                    options: '=options',
                    control: '=control',
                    show: '=show'
                };
                IWindow.scopeKeys = _.keys(IWindow.scope);
                IWindow.include(ChildEvents);
                IWindow.extend(CtrlHandle);

                function IWindow() {
                    this.restrict = 'EMA';
                    this.template = void 0;
                    this.transclude = true;
                    this.priority = -100;
                    this.require = '^' + 'uiGmapGoogleMap';
                    this.replace = true;
                    this.scope = _.extend(this.scope || {}, IWindow.scope);
                }
                return IWindow;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapMap', ['$timeout', '$q', 'uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapCtrlHandle', 'uiGmapIsReady', 'uiGmapuuid', 'uiGmapExtendGWin', 'uiGmapExtendMarkerClusterer', 'uiGmapGoogleMapsUtilV3', 'uiGmapGoogleMapApi', 'uiGmapEventsHelper', function($timeout, $q, $log, GmapUtil, BaseObject, CtrlHandle, IsReady, uuid, ExtendGWin, ExtendMarkerClusterer, GoogleMapsUtilV3, GoogleMapApi, EventsHelper) {
            'use strict';
            var DEFAULTS, Map, initializeItems;
            DEFAULTS = void 0;
            initializeItems = [GoogleMapsUtilV3, ExtendGWin, ExtendMarkerClusterer];
            return Map = (function(superClass) {
                extend(Map, superClass);
                Map.include(GmapUtil);

                function Map() {
                    this.link = bind(this.link, this);
                    var ctrlFn, self;
                    ctrlFn = function($scope) {
                        var ctrlObj, retCtrl;
                        retCtrl = void 0;
                        $scope.$on('$destroy', function() {
                            return IsReady.decrement();
                        });
                        ctrlObj = CtrlHandle.handle($scope);
                        $scope.ctrlType = 'Map';
                        $scope.deferred.promise.then(function() {
                            return initializeItems.forEach(function(i) {
                                return i.init();
                            });
                        });
                        ctrlObj.getMap = function() {
                            return $scope.map;
                        };
                        retCtrl = _.extend(this, ctrlObj);
                        return retCtrl;
                    };
                    this.controller = ['$scope', ctrlFn];
                    self = this;
                }
                Map.prototype.restrict = 'EMA';
                Map.prototype.transclude = true;
                Map.prototype.replace = false;
                Map.prototype.template = "<div class=\"angular-google-map\"><div class=\"angular-google-map-container\">\n</div><div ng-transclude style=\"display: none\"></div></div>";
                Map.prototype.scope = {
                    center: '=',
                    zoom: '=',
                    dragging: '=',
                    control: '=',
                    options: '=',
                    events: '=',
                    eventOpts: '=',
                    styles: '=',
                    bounds: '=',
                    update: '='
                };
                Map.prototype.link = function(scope, element, attrs) {
                    var listeners, unbindCenterWatch;
                    listeners = [];
                    scope.$on('$destroy', function() {
                        return EventsHelper.removeEvents(listeners);
                    });
                    scope.idleAndZoomChanged = false;
                    if (scope.center == null) {
                        unbindCenterWatch = scope.$watch('center', (function(_this) {
                            return function() {
                                if (!scope.center) {
                                    return;
                                }
                                unbindCenterWatch();
                                return _this.link(scope, element, attrs);
                            };
                        })(this));
                        return;
                    }
                    return GoogleMapApi.then((function(_this) {
                        return function(maps) {
                            var _gMap, customListeners, disabledEvents, dragging, el, eventName, getEventHandler, mapOptions, maybeHookToEvent, opts, ref, resolveSpawned, settingFromDirective, spawned, type, updateCenter, zoomPromise;
                            DEFAULTS = {
                                mapTypeId: maps.MapTypeId.ROADMAP
                            };
                            spawned = IsReady.spawn();
                            resolveSpawned = function() {
                                return spawned.deferred.resolve({
                                    instance: spawned.instance,
                                    map: _gMap
                                });
                            };
                            if (!_this.validateCoords(scope.center)) {
                                $log.error('angular-google-maps: could not find a valid center property');
                                return;
                            }
                            if (!angular.isDefined(scope.zoom)) {
                                $log.error('angular-google-maps: map zoom property not set');
                                return;
                            }
                            el = angular.element(element);
                            el.addClass('angular-google-map');
                            opts = {
                                options: {}
                            };
                            if (attrs.options) {
                                opts.options = scope.options;
                            }
                            if (attrs.styles) {
                                opts.styles = scope.styles;
                            }
                            if (attrs.type) {
                                type = attrs.type.toUpperCase();
                                if (google.maps.MapTypeId.hasOwnProperty(type)) {
                                    opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()];
                                } else {
                                    $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
                                }
                            }
                            mapOptions = angular.extend({}, DEFAULTS, opts, {
                                center: _this.getCoords(scope.center),
                                zoom: scope.zoom,
                                bounds: scope.bounds
                            });
                            _gMap = new google.maps.Map(el.find('div')[1], mapOptions);
                            _gMap['uiGmap_id'] = uuid.generate();
                            dragging = false;
                            listeners.push(google.maps.event.addListenerOnce(_gMap, 'idle', function() {
                                scope.deferred.resolve(_gMap);
                                return resolveSpawned();
                            }));
                            disabledEvents = attrs.events && (((ref = scope.events) != null ? ref.blacklist : void 0) != null) ? scope.events.blacklist : [];
                            if (_.isString(disabledEvents)) {
                                disabledEvents = [disabledEvents];
                            }
                            maybeHookToEvent = function(eventName, fn, prefn) {
                                if (!_.contains(disabledEvents, eventName)) {
                                    if (prefn) {
                                        prefn();
                                    }
                                    return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
                                        var ref1;
                                        if (!((ref1 = scope.update) != null ? ref1.lazy : void 0)) {
                                            return fn();
                                        }
                                    }));
                                }
                            };
                            if (!_.contains(disabledEvents, 'all')) {
                                maybeHookToEvent('dragstart', function() {
                                    dragging = true;
                                    return scope.$evalAsync(function(s) {
                                        if (s.dragging != null) {
                                            return s.dragging = dragging;
                                        }
                                    });
                                });
                                maybeHookToEvent('dragend', function() {
                                    dragging = false;
                                    return scope.$evalAsync(function(s) {
                                        if (s.dragging != null) {
                                            return s.dragging = dragging;
                                        }
                                    });
                                });
                                updateCenter = function(c, s) {
                                    if (c == null) {
                                        c = _gMap.center;
                                    }
                                    if (s == null) {
                                        s = scope;
                                    }
                                    if (_.contains(disabledEvents, 'center')) {
                                        return;
                                    }
                                    if (angular.isDefined(s.center.type)) {
                                        if (s.center.coordinates[1] !== c.lat()) {
                                            s.center.coordinates[1] = c.lat();
                                        }
                                        if (s.center.coordinates[0] !== c.lng()) {
                                            return s.center.coordinates[0] = c.lng();
                                        }
                                    } else {
                                        if (s.center.latitude !== c.lat()) {
                                            s.center.latitude = c.lat();
                                        }
                                        if (s.center.longitude !== c.lng()) {
                                            return s.center.longitude = c.lng();
                                        }
                                    }
                                };
                                settingFromDirective = false;
                                maybeHookToEvent('idle', function() {
                                    var b, ne, sw;
                                    b = _gMap.getBounds();
                                    ne = b.getNorthEast();
                                    sw = b.getSouthWest();
                                    settingFromDirective = true;
                                    return scope.$evalAsync(function(s) {
                                        updateCenter();
                                        if (!_.isUndefined(s.bounds) && !_.contains(disabledEvents, 'bounds')) {
                                            s.bounds.northeast = {
                                                latitude: ne.lat(),
                                                longitude: ne.lng()
                                            };
                                            s.bounds.southwest = {
                                                latitude: sw.lat(),
                                                longitude: sw.lng()
                                            };
                                        }
                                        if (!_.contains(disabledEvents, 'zoom')) {
                                            s.zoom = _gMap.zoom;
                                            scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
                                        }
                                        return settingFromDirective = false;
                                    });
                                });
                            }
                            if (angular.isDefined(scope.events) && scope.events !== null && angular.isObject(scope.events)) {
                                getEventHandler = function(eventName) {
                                    return function() {
                                        return scope.events[eventName].apply(scope, [_gMap, eventName, arguments]);
                                    };
                                };
                                customListeners = [];
                                for (eventName in scope.events) {
                                    if (scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName])) {
                                        customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
                                    }
                                }
                                listeners.concat(customListeners);
                            }
                            _gMap.getOptions = function() {
                                return mapOptions;
                            };
                            scope.map = _gMap;
                            if ((attrs.control != null) && (scope.control != null)) {
                                scope.control.refresh = function(maybeCoords) {
                                    var coords, ref1, ref2;
                                    if (_gMap == null) {
                                        return;
                                    }
                                    if (((typeof google !== "undefined" && google !== null ? (ref1 = google.maps) != null ? (ref2 = ref1.event) != null ? ref2.trigger : void 0 : void 0 : void 0) != null) && (_gMap != null)) {
                                        google.maps.event.trigger(_gMap, 'resize');
                                    }
                                    if (((maybeCoords != null ? maybeCoords.latitude : void 0) != null) && ((maybeCoords != null ? maybeCoords.longitude : void 0) != null)) {
                                        coords = _this.getCoords(maybeCoords);
                                        if (_this.isTrue(attrs.pan)) {
                                            return _gMap.panTo(coords);
                                        } else {
                                            return _gMap.setCenter(coords);
                                        }
                                    }
                                };
                                scope.control.getGMap = function() {
                                    return _gMap;
                                };
                                scope.control.getMapOptions = function() {
                                    return mapOptions;
                                };
                                scope.control.getCustomEventListeners = function() {
                                    return customListeners;
                                };
                                scope.control.removeEvents = function(yourListeners) {
                                    return EventsHelper.removeEvents(yourListeners);
                                };
                            }
                            scope.$watch('center', function(newValue, oldValue) {
                                var coords, settingCenterFromScope;
                                if (newValue === oldValue || settingFromDirective) {
                                    return;
                                }
                                coords = _this.getCoords(scope.center);
                                if (coords.lat() === _gMap.center.lat() && coords.lng() === _gMap.center.lng()) {
                                    return;
                                }
                                settingCenterFromScope = true;
                                if (!dragging) {
                                    if (!_this.validateCoords(newValue)) {
                                        $log.error("Invalid center for newValue: " + (JSON.stringify(newValue)));
                                    }
                                    if (_this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom) {
                                        _gMap.panTo(coords);
                                    } else {
                                        _gMap.setCenter(coords);
                                    }
                                }
                                return settingCenterFromScope = false;
                            }, true);
                            zoomPromise = null;
                            scope.$watch('zoom', function(newValue, oldValue) {
                                var ref1, ref2, settingZoomFromScope;
                                if (newValue == null) {
                                    return;
                                }
                                if (_.isEqual(newValue, oldValue) || (_gMap != null ? _gMap.getZoom() : void 0) === (scope != null ? scope.zoom : void 0) || settingFromDirective) {
                                    return;
                                }
                                settingZoomFromScope = true;
                                if (zoomPromise != null) {
                                    $timeout.cancel(zoomPromise);
                                }
                                return zoomPromise = $timeout(function() {
                                    _gMap.setZoom(newValue);
                                    return settingZoomFromScope = false;
                                }, ((ref1 = scope.eventOpts) != null ? (ref2 = ref1.debounce) != null ? ref2.zoomMs : void 0 : void 0) + 20, false);
                            });
                            scope.$watch('bounds', function(newValue, oldValue) {
                                var bounds, ne, ref1, ref2, ref3, ref4, sw;
                                if (newValue === oldValue) {
                                    return;
                                }
                                if (((newValue != null ? (ref1 = newValue.northeast) != null ? ref1.latitude : void 0 : void 0) == null) || ((newValue != null ? (ref2 = newValue.northeast) != null ? ref2.longitude : void 0 : void 0) == null) || ((newValue != null ? (ref3 = newValue.southwest) != null ? ref3.latitude : void 0 : void 0) == null) || ((newValue != null ? (ref4 = newValue.southwest) != null ? ref4.longitude : void 0 : void 0) == null)) {
                                    $log.error("Invalid map bounds for new value: " + (JSON.stringify(newValue)));
                                    return;
                                }
                                ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
                                sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
                                bounds = new google.maps.LatLngBounds(sw, ne);
                                return _gMap.fitBounds(bounds);
                            });
                            return ['options', 'styles'].forEach(function(toWatch) {
                                return scope.$watch(toWatch, function(newValue, oldValue) {
                                    var watchItem;
                                    watchItem = this.exp;
                                    if (_.isEqual(newValue, oldValue)) {
                                        return;
                                    }
                                    if (watchItem === 'options') {
                                        opts.options = newValue;
                                    } else {
                                        opts.options[watchItem] = newValue;
                                    }
                                    if (_gMap != null) {
                                        return _gMap.setOptions(opts);
                                    }
                                }, true);
                            });
                        };
                    })(this));
                };
                return Map;
            })(BaseObject);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", ["uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
            var Marker;
            return Marker = (function(superClass) {
                extend(Marker, superClass);

                function Marker() {
                    this.link = bind(this.link, this);
                    Marker.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
                    $log.info(this);
                }
                Marker.prototype.controller = ['$scope', '$element', function($scope, $element) {
                    $scope.ctrlType = 'Marker';
                    return _.extend(this, IMarker.handle($scope, $element));
                }];
                Marker.prototype.link = function(scope, element, attrs, ctrl) {
                    var mapPromise;
                    mapPromise = IMarker.mapPromise(scope, ctrl);
                    mapPromise.then((function(_this) {
                        return function(map) {
                            var doClick, doDrawSelf, gManager, keys, m, trackModel;
                            gManager = new MarkerManager(map);
                            keys = _.object(IMarker.keys, IMarker.keys);
                            m = new MarkerChildModel(scope, scope, keys, map, {}, doClick = true, gManager, doDrawSelf = false, trackModel = false);
                            m.deferred.promise.then(function(gMarker) {
                                return scope.deferred.resolve(gMarker);
                            });
                            if (scope.control != null) {
                                return scope.control.getGMarkers = gManager.getGMarkers;
                            }
                        };
                    })(this));
                    return scope.$on('$destroy', (function(_this) {
                        return function() {
                            var gManager;
                            if (typeof gManager !== "undefined" && gManager !== null) {
                                gManager.clear();
                            }
                            return gManager = null;
                        };
                    })(this));
                };
                return Marker;
            })(IMarker);
        }]);
    }).call(this);;
    (function() {
        var extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", ["uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
            var Markers;
            return Markers = (function(superClass) {
                extend(Markers, superClass);

                function Markers() {
                    Markers.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
                    Plural.extend(this, {
                        doCluster: '=?docluster',
                        clusterOptions: '=clusteroptions',
                        clusterEvents: '=clusterevents',
                        modelsByRef: '=modelsbyref',
                        type: '=?type',
                        typeOptions: '=?typeoptions',
                        typeEvents: '=?typeevents'
                    });
                    $log.info(this);
                }
                Markers.prototype.controller = ['$scope', '$element', function($scope, $element) {
                    $scope.ctrlType = 'Markers';
                    return _.extend(this, IMarker.handle($scope, $element));
                }];
                Markers.prototype.link = function(scope, element, attrs, ctrl) {
                    var parentModel, ready;
                    parentModel = void 0;
                    ready = function() {
                        return scope.deferred.resolve();
                    };
                    return IMarker.mapPromise(scope, ctrl).then(function(map) {
                        var mapScope;
                        mapScope = ctrl.getScope();
                        mapScope.$watch('idleAndZoomChanged', function() {
                            return _.defer(parentModel.gManager.draw);
                        });
                        parentModel = new MarkersParentModel(scope, element, attrs, map);
                        Plural.link(scope, parentModel);
                        if (scope.control != null) {
                            scope.control.getGMarkers = function() {
                                var ref;
                                return (ref = parentModel.gManager) != null ? ref.getGMarkers() : void 0;
                            };
                            scope.control.getChildMarkers = function() {
                                return parentModel.plurals;
                            };
                        }
                        return _.last(parentModel.existingPieces._content).then(function() {
                            return ready();
                        });
                    });
                };
                return Markers;
            })(IMarker);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapPlural', [function() {
            var _initControl;
            _initControl = function(scope, parent) {
                if (scope.control == null) {
                    return;
                }
                scope.control.updateModels = function(models) {
                    scope.models = models;
                    return parent.createChildScopes(false);
                };
                scope.control.newModels = function(models) {
                    scope.models = models;
                    return parent.rebuildAll(scope, true, true);
                };
                scope.control.clean = function() {
                    return parent.rebuildAll(scope, false, true);
                };
                scope.control.getPlurals = function() {
                    return parent.plurals;
                };
                scope.control.getManager = function() {
                    return parent.gManager;
                };
                scope.control.hasManager = function() {
                    return (parent.gManager != null) === true;
                };
                return scope.control.managerDraw = function() {
                    var ref;
                    if (scope.control.hasManager()) {
                        return (ref = scope.control.getManager()) != null ? ref.draw() : void 0;
                    }
                };
            };
            return {
                extend: function(obj, obj2) {
                    return _.extend(obj.scope || {}, obj2 || {}, {
                        idKey: '=idkey',
                        doRebuildAll: '=dorebuildall',
                        models: '=models',
                        chunk: '=chunk',
                        cleanchunk: '=cleanchunk',
                        control: '=control'
                    });
                },
                link: function(scope, parent) {
                    return _initControl(scope, parent);
                }
            };
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygon', ['uiGmapIPolygon', '$timeout', 'uiGmapPolygonChildModel', function(IPolygon, $timeout, PolygonChild) {
            var Polygon;
            return Polygon = (function(superClass) {
                extend(Polygon, superClass);

                function Polygon() {
                    this.link = bind(this.link, this);
                    return Polygon.__super__.constructor.apply(this, arguments);
                }
                Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
                    var children, promise;
                    children = [];
                    promise = IPolygon.mapPromise(scope, mapCtrl);
                    if (scope.control != null) {
                        scope.control.getInstance = this;
                        scope.control.polygons = children;
                        scope.control.promise = promise;
                    }
                    return promise.then((function(_this) {
                        return function(map) {
                            return children.push(new PolygonChild(scope, attrs, map, _this.DEFAULTS));
                        };
                    })(this));
                };
                return Polygon;
            })(IPolygon);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygons', ['uiGmapIPolygon', '$timeout', 'uiGmapPolygonsParentModel', 'uiGmapPlural', function(Interface, $timeout, ParentModel, Plural) {
            var Polygons;
            return Polygons = (function(superClass) {
                extend(Polygons, superClass);

                function Polygons() {
                    this.link = bind(this.link, this);
                    Polygons.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then((function(_this) {
                        return function(map) {
                            if (angular.isUndefined(scope.path) || scope.path === null) {
                                _this.$log.warn('polygons: no valid path attribute found');
                            }
                            if (!scope.models) {
                                _this.$log.warn('polygons: no models found to create from');
                            }
                            return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    })(this));
                };
                return Polygons;
            })(Interface);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolyline', ['uiGmapIPolyline', '$timeout', 'uiGmapPolylineChildModel', function(IPolyline, $timeout, PolylineChildModel) {
            var Polyline;
            return Polyline = (function(superClass) {
                extend(Polyline, superClass);

                function Polyline() {
                    this.link = bind(this.link, this);
                    return Polyline.__super__.constructor.apply(this, arguments);
                }
                Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return IPolyline.mapPromise(scope, mapCtrl).then((function(_this) {
                        return function(map) {
                            if (angular.isUndefined(scope.path) || scope.path === null || !_this.validatePath(scope.path)) {
                                _this.$log.warn('polyline: no valid path attribute found');
                            }
                            return new PolylineChildModel(scope, attrs, map, _this.DEFAULTS);
                        };
                    })(this));
                };
                return Polyline;
            })(IPolyline);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolylines', ['uiGmapIPolyline', '$timeout', 'uiGmapPolylinesParentModel', 'uiGmapPlural', function(IPolyline, $timeout, PolylinesParentModel, Plural) {
            var Polylines;
            return Polylines = (function(superClass) {
                extend(Polylines, superClass);

                function Polylines() {
                    this.link = bind(this.link, this);
                    Polylines.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then((function(_this) {
                        return function(map) {
                            if (angular.isUndefined(scope.path) || scope.path === null) {
                                _this.$log.warn('polylines: no valid path attribute found');
                            }
                            if (!scope.models) {
                                _this.$log.warn('polylines: no models found to create from');
                            }
                            return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    })(this));
                };
                return Polylines;
            })(IPolyline);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapRectangle', ['uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapIRectangle', 'uiGmapRectangleParentModel', function($log, GmapUtil, IRectangle, RectangleParentModel) {
            return _.extend(IRectangle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then((function(_this) {
                        return function(map) {
                            return new RectangleParentModel(scope, element, attrs, map);
                        };
                    })(this));
                }
            });
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapWindow', ['uiGmapIWindow', 'uiGmapGmapUtil', 'uiGmapWindowChildModel', 'uiGmapLodash', 'uiGmapLogger', function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
            var Window;
            return Window = (function(superClass) {
                extend(Window, superClass);
                Window.include(GmapUtil);

                function Window() {
                    this.link = bind(this.link, this);
                    Window.__super__.constructor.call(this);
                    this.require = ['^' + 'uiGmapGoogleMap', '^?' + 'uiGmapMarker'];
                    this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
                    $log.debug(this);
                    this.childWindows = [];
                }
                Window.prototype.link = function(scope, element, attrs, ctrls) {
                    var markerCtrl, markerScope;
                    markerCtrl = ctrls.length > 1 && (ctrls[1] != null) ? ctrls[1] : void 0;
                    markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
                    this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
                    return this.mapPromise.then((function(_this) {
                        return function(mapCtrl) {
                            var isIconVisibleOnClick;
                            isIconVisibleOnClick = true;
                            if (angular.isDefined(attrs.isiconvisibleonclick)) {
                                isIconVisibleOnClick = scope.isIconVisibleOnClick;
                            }
                            if (!markerCtrl) {
                                _this.init(scope, element, isIconVisibleOnClick, mapCtrl);
                                return;
                            }
                            return markerScope.deferred.promise.then(function(gMarker) {
                                return _this.init(scope, element, isIconVisibleOnClick, mapCtrl, markerScope);
                            });
                        };
                    })(this));
                };
                Window.prototype.init = function(scope, element, isIconVisibleOnClick, mapCtrl, markerScope) {
                    var childWindow, defaults, gMarker, hasScopeCoords, opts;
                    defaults = scope.options != null ? scope.options : {};
                    hasScopeCoords = (scope != null) && this.validateCoords(scope.coords);
                    if ((markerScope != null ? markerScope['getGMarker'] : void 0) != null) {
                        gMarker = markerScope.getGMarker();
                    }
                    opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
                    if (mapCtrl != null) {
                        childWindow = new WindowChildModel({}, scope, opts, isIconVisibleOnClick, mapCtrl, markerScope, element);
                        this.childWindows.push(childWindow);
                        scope.$on('$destroy', (function(_this) {
                            return function() {
                                _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [childWindow], function(child1, child2) {
                                    return child1.scope.$id === child2.scope.$id;
                                });
                                return _this.childWindows.length = 0;
                            };
                        })(this));
                    }
                    if (scope.control != null) {
                        scope.control.getGWindows = (function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        })(this);
                        scope.control.getChildWindows = (function(_this) {
                            return function() {
                                return _this.childWindows;
                            };
                        })(this);
                        scope.control.getPlurals = scope.control.getChildWindows;
                        scope.control.showWindow = (function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.showWindow();
                                });
                            };
                        })(this);
                        scope.control.hideWindow = (function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.hideWindow();
                                });
                            };
                        })(this);
                    }
                    if ((this.onChildCreation != null) && (childWindow != null)) {
                        return this.onChildCreation(childWindow);
                    }
                };
                return Window;
            })(IWindow);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            },
            extend = function(child, parent) {
                for (var key in parent) {
                    if (hasProp.call(parent, key)) child[key] = parent[key];
                }

                function ctor() {
                    this.constructor = child;
                }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
                child.__super__ = parent.prototype;
                return child;
            },
            hasProp = {}.hasOwnProperty;
        angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapWindows', ['uiGmapIWindow', 'uiGmapPlural', 'uiGmapWindowsParentModel', 'uiGmapPromise', 'uiGmapLogger', function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
            var Windows;
            return Windows = (function(superClass) {
                extend(Windows, superClass);

                function Windows() {
                    this.init = bind(this.init, this);
                    this.link = bind(this.link, this);
                    Windows.__super__.constructor.call(this);
                    this.require = ['^' + 'uiGmapGoogleMap', '^?' + 'uiGmapMarkers'];
                    this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
                    Plural.extend(this);
                    $log.debug(this);
                }
                Windows.prototype.link = function(scope, element, attrs, ctrls) {
                    var mapScope, markerCtrl, markerScope;
                    mapScope = ctrls[0].getScope();
                    markerCtrl = ctrls.length > 1 && (ctrls[1] != null) ? ctrls[1] : void 0;
                    markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
                    return mapScope.deferred.promise.then((function(_this) {
                        return function(map) {
                            var promise, ref;
                            promise = (markerScope != null ? (ref = markerScope.deferred) != null ? ref.promise : void 0 : void 0) || uiGmapPromise.resolve();
                            return promise.then(function() {
                                var pieces, ref1;
                                pieces = (ref1 = _this.parentModel) != null ? ref1.existingPieces : void 0;
                                if (pieces) {
                                    return pieces.then(function() {
                                        return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                    });
                                } else {
                                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                }
                            });
                        };
                    })(this));
                };
                Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
                    var parentModel;
                    parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
                    Plural.link(scope, parentModel);
                    if (scope.control != null) {
                        scope.control.getGWindows = (function(_this) {
                            return function() {
                                return parentModel.plurals.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        })(this);
                        return scope.control.getChildWindows = (function(_this) {
                            return function() {
                                return parentModel.plurals;
                            };
                        })(this);
                    }
                };
                return Windows;
            })(IWindow);
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", ["uiGmapMap", function(Map) {
            return new Map();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapMarker', ['$timeout', 'uiGmapMarker', function($timeout, Marker) {
            return new Marker($timeout);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapMarkers', ['$timeout', 'uiGmapMarkers', function($timeout, Markers) {
            return new Markers($timeout);
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapPolygon', ['uiGmapPolygon', function(Polygon) {
            return new Polygon();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive("uiGmapCircle", ["uiGmapCircle", function(Circle) {
            return Circle;
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", ["uiGmapPolyline", function(Polyline) {
            return new Polyline();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapPolylines', ['uiGmapPolylines', function(Polylines) {
            return new Polylines();
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", ["uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
            return Rectangle;
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", ["$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
            return new Window($timeout, $compile, $http, $templateCache);
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", ["$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
            return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module('uiGmapgoogle-maps').directive('uiGmapLayer', ['$timeout', 'uiGmapLogger', 'uiGmapLayerParentModel', function($timeout, Logger, LayerParentModel) {
            var Layer;
            Layer = (function() {
                function Layer() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = 'EMA';
                    this.require = '^' + 'uiGmapGoogleMap';
                    this.priority = -1;
                    this.transclude = true;
                    this.template = '<span class=\'angular-google-map-layer\' ng-transclude></span>';
                    this.replace = true;
                    this.scope = {
                        show: '=show',
                        type: '=type',
                        namespace: '=namespace',
                        options: '=options',
                        onCreated: '&oncreated'
                    };
                }
                Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then((function(_this) {
                        return function(map) {
                            if (scope.onCreated != null) {
                                return new LayerParentModel(scope, element, attrs, map, scope.onCreated);
                            } else {
                                return new LayerParentModel(scope, element, attrs, map);
                            }
                        };
                    })(this));
                };
                return Layer;
            })();
            return new Layer();
        }]);
    }).call(this);;
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", ["uiGmapControl", function(Control) {
            return new Control();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapDragZoom', ['uiGmapDragZoom', function(DragZoom) {
            return DragZoom;
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive("uiGmapDrawingManager", ["uiGmapDrawingManager", function(DrawingManager) {
            return DrawingManager;
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapFreeDrawPolygons', ['uiGmapApiFreeDrawPolygons', function(FreeDrawPolygons) {
            return new FreeDrawPolygons();
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", ["$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
            var MapType;
            MapType = (function() {
                function MapType() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = '^' + 'uiGmapGoogleMap';
                    this.priority = -1;
                    this.transclude = true;
                    this.template = '<span class=\"angular-google-map-layer\" ng-transclude></span>';
                    this.replace = true;
                    this.scope = {
                        show: "=show",
                        options: '=options',
                        refresh: '=refresh',
                        id: '@'
                    };
                }
                MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then((function(_this) {
                        return function(map) {
                            return new MapTypeParentModel(scope, element, attrs, map);
                        };
                    })(this));
                };
                return MapType;
            })();
            return new MapType();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapPolygons', ['uiGmapPolygons', function(Polygons) {
            return new Polygons();
        }]);
    }).call(this);;
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module('uiGmapgoogle-maps').directive('uiGmapSearchBox', ['uiGmapGoogleMapApi', 'uiGmapLogger', 'uiGmapSearchBoxParentModel', '$http', '$templateCache', '$compile', function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
            var SearchBox;
            SearchBox = (function() {
                SearchBox.prototype.require = 'ngModel';

                function SearchBox() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = 'EMA';
                    this.require = '^' + 'uiGmapGoogleMap';
                    this.priority = -1;
                    this.transclude = true;
                    this.template = '<span class=\'angular-google-map-search\' ng-transclude></span>';
                    this.replace = true;
                    this.scope = {
                        template: '=template',
                        events: '=events',
                        position: '=?position',
                        options: '=?options',
                        parentdiv: '=?parentdiv',
                        ngModel: "=?"
                    };
                }
                SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return GoogleMapApi.then((function(_this) {
                        return function(maps) {
                            if (scope.template == null) {
                                $templateCache.put('uigmap-searchbox-default.tpl.html', '<input type="text">');
                                scope.template = 'uigmap-searchbox-default.tpl.html';
                            }
                            return $http.get(scope.template, {
                                cache: $templateCache
                            }).success(function(template) {
                                if (angular.isUndefined(scope.events)) {
                                    _this.$log.error('searchBox: the events property is required');
                                    return;
                                }
                                return mapCtrl.getScope().deferred.promise.then(function(map) {
                                    var ctrlPosition;
                                    ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, '_') : 'TOP_LEFT';
                                    if (!maps.ControlPosition[ctrlPosition]) {
                                        _this.$log.error('searchBox: invalid position property');
                                        return;
                                    }
                                    return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
                                });
                            });
                        };
                    })(this));
                };
                return SearchBox;
            })();
            return new SearchBox();
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapShow', ['$animate', 'uiGmapLogger', function($animate, $log) {
            return {
                scope: {
                    'uiGmapShow': '=',
                    'uiGmapAfterShow': '&',
                    'uiGmapAfterHide': '&'
                },
                link: function(scope, element) {
                    var angular_post_1_3_handle, angular_pre_1_3_handle, handle;
                    angular_post_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, 'ng-hide').then(function() {
                            return cb();
                        });
                    };
                    angular_pre_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, 'ng-hide', cb);
                    };
                    handle = function(animateAction, cb) {
                        if (angular.version.major > 1) {
                            return $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + "\"");
                        }
                        if (angular.version.major === 1 && angular.version.minor < 3) {
                            return angular_pre_1_3_handle(animateAction, cb);
                        }
                        return angular_post_1_3_handle(animateAction, cb);
                    };
                    return scope.$watch('uiGmapShow', function(show) {
                        if (show) {
                            handle('removeClass', scope.uiGmapAfterShow);
                        }
                        if (!show) {
                            return handle('addClass', scope.uiGmapAfterHide);
                        }
                    });
                }
            };
        }]);
    }).call(this);;
    (function() {
        angular.module('uiGmapgoogle-maps').directive('uiGmapStreetViewPanorama', ['uiGmapGoogleMapApi', 'uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapEventsHelper', function(GoogleMapApi, $log, GmapUtil, EventsHelper) {
            var name;
            name = 'uiGmapStreetViewPanorama';
            return {
                restrict: 'EMA',
                template: '<div class="angular-google-map-street-view-panorama"></div>',
                replace: true,
                scope: {
                    focalcoord: '=',
                    radius: '=?',
                    events: '=?',
                    options: '=?',
                    control: '=?',
                    povoptions: '=?',
                    imagestatus: '='
                },
                link: function(scope, element, attrs) {
                    return GoogleMapApi.then((function(_this) {
                        return function(maps) {
                            var clean, create, didCreateOptionsFromDirective, firstTime, handleSettings, listeners, opts, pano, povOpts, sv;
                            pano = void 0;
                            sv = void 0;
                            didCreateOptionsFromDirective = false;
                            listeners = void 0;
                            opts = null;
                            povOpts = null;
                            clean = function() {
                                EventsHelper.removeEvents(listeners);
                                if (pano != null) {
                                    pano.unbind('position');
                                    pano.setVisible(false);
                                }
                                if (sv != null) {
                                    if ((sv != null ? sv.setVisible : void 0) != null) {
                                        sv.setVisible(false);
                                    }
                                    return sv = void 0;
                                }
                            };
                            handleSettings = function(perspectivePoint, focalPoint) {
                                var heading;
                                heading = google.maps.geometry.spherical.computeHeading(perspectivePoint, focalPoint);
                                didCreateOptionsFromDirective = true;
                                scope.radius = scope.radius || 50;
                                povOpts = angular.extend({
                                    heading: heading,
                                    zoom: 1,
                                    pitch: 0
                                }, scope.povoptions || {});
                                opts = opts = angular.extend({
                                    navigationControl: false,
                                    addressControl: false,
                                    linksControl: false,
                                    position: perspectivePoint,
                                    pov: povOpts,
                                    visible: true
                                }, scope.options || {});
                                return didCreateOptionsFromDirective = false;
                            };
                            create = function() {
                                var focalPoint;
                                if (!scope.focalcoord) {
                                    $log.error(name + ": focalCoord needs to be defined");
                                    return;
                                }
                                if (!scope.radius) {
                                    $log.error(name + ": needs a radius to set the camera view from its focal target.");
                                    return;
                                }
                                clean();
                                if (sv == null) {
                                    sv = new google.maps.StreetViewService();
                                }
                                if (scope.events) {
                                    listeners = EventsHelper.setEvents(sv, scope, scope);
                                }
                                focalPoint = GmapUtil.getCoords(scope.focalcoord);
                                return sv.getPanoramaByLocation(focalPoint, scope.radius, function(streetViewPanoramaData, status) {
                                    var ele, perspectivePoint, ref;
                                    if (scope.imagestatus != null) {
                                        scope.imagestatus = status;
                                    }
                                    if (((ref = scope.events) != null ? ref.image_status_changed : void 0) != null) {
                                        scope.events.image_status_changed(sv, 'image_status_changed', scope, status);
                                    }
                                    if (status === "OK") {
                                        perspectivePoint = streetViewPanoramaData.location.latLng;
                                        handleSettings(perspectivePoint, focalPoint);
                                        ele = element[0];
                                        return pano = new google.maps.StreetViewPanorama(ele, opts);
                                    }
                                });
                            };
                            if (scope.control != null) {
                                scope.control.getOptions = function() {
                                    return opts;
                                };
                                scope.control.getPovOptions = function() {
                                    return povOpts;
                                };
                                scope.control.getGObject = function() {
                                    return sv;
                                };
                                scope.control.getGPano = function() {
                                    return pano;
                                };
                            }
                            scope.$watch('options', function(newValue, oldValue) {
                                if (newValue === oldValue || newValue === opts || didCreateOptionsFromDirective) {
                                    return;
                                }
                                return create();
                            });
                            firstTime = true;
                            scope.$watch('focalcoord', function(newValue, oldValue) {
                                if (newValue === oldValue && !firstTime) {
                                    return;
                                }
                                if (newValue == null) {
                                    return;
                                }
                                firstTime = false;
                                return create();
                            });
                            return scope.$on('$destroy', function() {
                                return clean();
                            });
                        };
                    })(this));
                }
            };
        }]);
    }).call(this);;
    angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapuuid', function() {
        function UUID() {}
        UUID.generate = function() {
            var a = UUID._gri,
                b = UUID._ha;
            return b(a(32), 8) + "-" + b(a(16), 4) + "-" + b(16384 | a(12), 4) + "-" + b(32768 | a(14), 4) + "-" + b(a(48), 12)
        };
        UUID._gri = function(a) {
            return 0 > a ? NaN : 30 >= a ? 0 | Math.random() * (1 << a) : 53 >= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 << a - 30)) : NaN
        };
        UUID._ha = function(a, b) {
            for (var c = a.toString(16), d = b - c.length, e = "0"; 0 < d; d >>>= 1, e += e) d & 1 && (c = e + c);
            return c
        };
        return UUID;
    });;
    angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapGoogleMapsUtilV3', function() {
        return {
            init: _.once(function() {
                function InfoBox(opt_opts) {
                    opt_opts = opt_opts || {};
                    google.maps.OverlayView.apply(this, arguments);
                    this.content_ = opt_opts.content || "";
                    this.disableAutoPan_ = opt_opts.disableAutoPan || false;
                    this.maxWidth_ = opt_opts.maxWidth || 0;
                    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
                    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
                    this.zIndex_ = opt_opts.zIndex || null;
                    this.boxClass_ = opt_opts.boxClass || "infoBox";
                    this.boxStyle_ = opt_opts.boxStyle || {};
                    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
                    this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
                    if (opt_opts.closeBoxURL === "") {
                        this.closeBoxURL_ = "";
                    }
                    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
                    if (typeof opt_opts.visible === "undefined") {
                        if (typeof opt_opts.isHidden === "undefined") {
                            opt_opts.visible = true;
                        } else {
                            opt_opts.visible = !opt_opts.isHidden;
                        }
                    }
                    this.isHidden_ = !opt_opts.visible;
                    this.alignBottom_ = opt_opts.alignBottom || false;
                    this.pane_ = opt_opts.pane || "floatPane";
                    this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;
                    this.div_ = null;
                    this.closeListener_ = null;
                    this.moveListener_ = null;
                    this.contextListener_ = null;
                    this.eventListeners_ = null;
                    this.fixedWidthSet_ = null;
                }
                InfoBox.prototype = new google.maps.OverlayView();
                InfoBox.prototype.createInfoBoxDiv_ = function() {
                    var i;
                    var events;
                    var bw;
                    var me = this;
                    var cancelHandler = function(e) {
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                    };
                    var ignoreHandler = function(e) {
                        e.returnValue = false;
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (!me.enableEventPropagation_) {
                            cancelHandler(e);
                        }
                    };
                    if (!this.div_) {
                        this.div_ = document.createElement("div");
                        this.setBoxStyle_();
                        if (typeof this.content_.nodeType === "undefined") {
                            this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
                        } else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(this.content_);
                        }
                        this.getPanes()[this.pane_].appendChild(this.div_);
                        this.addClickHandler_();
                        if (this.div_.style.width) {
                            this.fixedWidthSet_ = true;
                        } else {
                            if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {
                                this.div_.style.width = this.maxWidth_;
                                this.div_.style.overflow = "auto";
                                this.fixedWidthSet_ = true;
                            } else {
                                bw = this.getBoxWidths_();
                                this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
                                this.fixedWidthSet_ = false;
                            }
                        }
                        this.panBox_(this.disableAutoPan_);
                        if (!this.enableEventPropagation_) {
                            this.eventListeners_ = [];
                            events = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"];
                            for (i = 0; i < events.length; i++) {
                                this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
                            }
                            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function(e) {
                                this.style.cursor = "default";
                            }));
                        }
                        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
                        google.maps.event.trigger(this, "domready");
                    }
                };
                InfoBox.prototype.getCloseBoxImg_ = function() {
                    var img = "";
                    if (this.closeBoxURL_ !== "") {
                        img = "<img";
                        img += " src='" + this.closeBoxURL_ + "'";
                        img += " align=right";
                        img += " style='";
                        img += " position: relative;";
                        img += " cursor: pointer;";
                        img += " margin: " + this.closeBoxMargin_ + ";";
                        img += "'>";
                    }
                    return img;
                };
                InfoBox.prototype.addClickHandler_ = function() {
                    var closeBox;
                    if (this.closeBoxURL_ !== "") {
                        closeBox = this.div_.firstChild;
                        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
                    } else {
                        this.closeListener_ = null;
                    }
                };
                InfoBox.prototype.getCloseClickHandler_ = function() {
                    var me = this;
                    return function(e) {
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                        google.maps.event.trigger(me, "closeclick");
                        me.close();
                    };
                };
                InfoBox.prototype.panBox_ = function(disablePan) {
                    var map;
                    var bounds;
                    var xOffset = 0,
                        yOffset = 0;
                    if (!disablePan) {
                        map = this.getMap();
                        if (map instanceof google.maps.Map) {
                            if (!map.getBounds().contains(this.position_)) {
                                map.setCenter(this.position_);
                            }
                            bounds = map.getBounds();
                            var mapDiv = map.getDiv();
                            var mapWidth = mapDiv.offsetWidth;
                            var mapHeight = mapDiv.offsetHeight;
                            var iwOffsetX = this.pixelOffset_.width;
                            var iwOffsetY = this.pixelOffset_.height;
                            var iwWidth = this.div_.offsetWidth;
                            var iwHeight = this.div_.offsetHeight;
                            var padX = this.infoBoxClearance_.width;
                            var padY = this.infoBoxClearance_.height;
                            var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
                            if (pixPosition.x < (-iwOffsetX + padX)) {
                                xOffset = pixPosition.x + iwOffsetX - padX;
                            } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
                                xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
                            }
                            if (this.alignBottom_) {
                                if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
                                    yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
                                } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
                                    yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
                                }
                            } else {
                                if (pixPosition.y < (-iwOffsetY + padY)) {
                                    yOffset = pixPosition.y + iwOffsetY - padY;
                                } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
                                    yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
                                }
                            }
                            if (!(xOffset === 0 && yOffset === 0)) {
                                var c = map.getCenter();
                                map.panBy(xOffset, yOffset);
                            }
                        }
                    }
                };
                InfoBox.prototype.setBoxStyle_ = function() {
                    var i, boxStyle;
                    if (this.div_) {
                        this.div_.className = this.boxClass_;
                        this.div_.style.cssText = "";
                        boxStyle = this.boxStyle_;
                        for (i in boxStyle) {
                            if (boxStyle.hasOwnProperty(i)) {
                                this.div_.style[i] = boxStyle[i];
                            }
                        }
                        this.div_.style.WebkitTransform = "translateZ(0)";
                        if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {
                            this.div_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + (this.div_.style.opacity * 100) + ")\"";
                            this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
                        }
                        this.div_.style.position = "absolute";
                        this.div_.style.visibility = 'hidden';
                        if (this.zIndex_ !== null) {
                            this.div_.style.zIndex = this.zIndex_;
                        }
                    }
                };
                InfoBox.prototype.getBoxWidths_ = function() {
                    var computedStyle;
                    var bw = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0
                    };
                    var box = this.div_;
                    if (document.defaultView && document.defaultView.getComputedStyle) {
                        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
                        if (computedStyle) {
                            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                        }
                    } else if (document.documentElement.currentStyle) {
                        if (box.currentStyle) {
                            bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
                        }
                    }
                    return bw;
                };
                InfoBox.prototype.onRemove = function() {
                    if (this.div_) {
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                InfoBox.prototype.draw = function() {
                    this.createInfoBoxDiv_();
                    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
                    this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";
                    if (this.alignBottom_) {
                        this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
                    } else {
                        this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
                    }
                    if (this.isHidden_) {
                        this.div_.style.visibility = "hidden";
                    } else {
                        this.div_.style.visibility = "visible";
                    }
                };
                InfoBox.prototype.setOptions = function(opt_opts) {
                    if (typeof opt_opts.boxClass !== "undefined") {
                        this.boxClass_ = opt_opts.boxClass;
                        this.setBoxStyle_();
                    }
                    if (typeof opt_opts.boxStyle !== "undefined") {
                        this.boxStyle_ = opt_opts.boxStyle;
                        this.setBoxStyle_();
                    }
                    if (typeof opt_opts.content !== "undefined") {
                        this.setContent(opt_opts.content);
                    }
                    if (typeof opt_opts.disableAutoPan !== "undefined") {
                        this.disableAutoPan_ = opt_opts.disableAutoPan;
                    }
                    if (typeof opt_opts.maxWidth !== "undefined") {
                        this.maxWidth_ = opt_opts.maxWidth;
                    }
                    if (typeof opt_opts.pixelOffset !== "undefined") {
                        this.pixelOffset_ = opt_opts.pixelOffset;
                    }
                    if (typeof opt_opts.alignBottom !== "undefined") {
                        this.alignBottom_ = opt_opts.alignBottom;
                    }
                    if (typeof opt_opts.position !== "undefined") {
                        this.setPosition(opt_opts.position);
                    }
                    if (typeof opt_opts.zIndex !== "undefined") {
                        this.setZIndex(opt_opts.zIndex);
                    }
                    if (typeof opt_opts.closeBoxMargin !== "undefined") {
                        this.closeBoxMargin_ = opt_opts.closeBoxMargin;
                    }
                    if (typeof opt_opts.closeBoxURL !== "undefined") {
                        this.closeBoxURL_ = opt_opts.closeBoxURL;
                    }
                    if (typeof opt_opts.infoBoxClearance !== "undefined") {
                        this.infoBoxClearance_ = opt_opts.infoBoxClearance;
                    }
                    if (typeof opt_opts.isHidden !== "undefined") {
                        this.isHidden_ = opt_opts.isHidden;
                    }
                    if (typeof opt_opts.visible !== "undefined") {
                        this.isHidden_ = !opt_opts.visible;
                    }
                    if (typeof opt_opts.enableEventPropagation !== "undefined") {
                        this.enableEventPropagation_ = opt_opts.enableEventPropagation;
                    }
                    if (this.div_) {
                        this.draw();
                    }
                };
                InfoBox.prototype.setContent = function(content) {
                    this.content_ = content;
                    if (this.div_) {
                        if (this.closeListener_) {
                            google.maps.event.removeListener(this.closeListener_);
                            this.closeListener_ = null;
                        }
                        if (!this.fixedWidthSet_) {
                            this.div_.style.width = "";
                        }
                        if (typeof content.nodeType === "undefined") {
                            this.div_.innerHTML = this.getCloseBoxImg_() + content;
                        } else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(content);
                        }
                        if (!this.fixedWidthSet_) {
                            this.div_.style.width = this.div_.offsetWidth + "px";
                            if (typeof content.nodeType === "undefined") {
                                this.div_.innerHTML = this.getCloseBoxImg_() + content;
                            } else {
                                this.div_.innerHTML = this.getCloseBoxImg_();
                                this.div_.appendChild(content);
                            }
                        }
                        this.addClickHandler_();
                    }
                    google.maps.event.trigger(this, "content_changed");
                };
                InfoBox.prototype.setPosition = function(latlng) {
                    this.position_ = latlng;
                    if (this.div_) {
                        this.draw();
                    }
                    google.maps.event.trigger(this, "position_changed");
                };
                InfoBox.prototype.setZIndex = function(index) {
                    this.zIndex_ = index;
                    if (this.div_) {
                        this.div_.style.zIndex = index;
                    }
                    google.maps.event.trigger(this, "zindex_changed");
                };
                InfoBox.prototype.setVisible = function(isVisible) {
                    this.isHidden_ = !isVisible;
                    if (this.div_) {
                        this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
                    }
                };
                InfoBox.prototype.getContent = function() {
                    return this.content_;
                };
                InfoBox.prototype.getPosition = function() {
                    return this.position_;
                };
                InfoBox.prototype.getZIndex = function() {
                    return this.zIndex_;
                };
                InfoBox.prototype.getVisible = function() {
                    var isVisible;
                    if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
                        isVisible = false;
                    } else {
                        isVisible = !this.isHidden_;
                    }
                    return isVisible;
                };
                InfoBox.prototype.show = function() {
                    this.isHidden_ = false;
                    if (this.div_) {
                        this.div_.style.visibility = "visible";
                    }
                };
                InfoBox.prototype.hide = function() {
                    this.isHidden_ = true;
                    if (this.div_) {
                        this.div_.style.visibility = "hidden";
                    }
                };
                InfoBox.prototype.open = function(map, anchor) {
                    var me = this;
                    if (anchor) {
                        this.position_ = anchor.getPosition();
                        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function() {
                            me.setPosition(this.getPosition());
                        });
                    }
                    this.setMap(map);
                    if (this.div_) {
                        this.panBox_();
                    }
                };
                InfoBox.prototype.close = function() {
                    var i;
                    if (this.closeListener_) {
                        google.maps.event.removeListener(this.closeListener_);
                        this.closeListener_ = null;
                    }
                    if (this.eventListeners_) {
                        for (i = 0; i < this.eventListeners_.length; i++) {
                            google.maps.event.removeListener(this.eventListeners_[i]);
                        }
                        this.eventListeners_ = null;
                    }
                    if (this.moveListener_) {
                        google.maps.event.removeListener(this.moveListener_);
                        this.moveListener_ = null;
                    }
                    if (this.contextListener_) {
                        google.maps.event.removeListener(this.contextListener_);
                        this.contextListener_ = null;
                    }
                    this.setMap(null);
                };
                (function() {
                    var toPixels = function(widthValue) {
                        var px;
                        switch (widthValue) {
                            case "thin":
                                px = "2px";
                                break;
                            case "medium":
                                px = "4px";
                                break;
                            case "thick":
                                px = "6px";
                                break;
                            default:
                                px = widthValue;
                        }
                        return px;
                    };
                    var getBorderWidths = function(h) {
                        var computedStyle;
                        var bw = {};
                        if (document.defaultView && document.defaultView.getComputedStyle) {
                            computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
                            if (computedStyle) {
                                bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                                bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                                bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                                bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                                return bw;
                            }
                        } else if (document.documentElement.currentStyle) {
                            if (h.currentStyle) {
                                bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
                                bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
                                bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
                                bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
                                return bw;
                            }
                        }
                        bw.top = parseInt(h.style["border-top-width"], 10) || 0;
                        bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
                        bw.left = parseInt(h.style["border-left-width"], 10) || 0;
                        bw.right = parseInt(h.style["border-right-width"], 10) || 0;
                        return bw;
                    };
                    var scroll = {
                        x: 0,
                        y: 0
                    };
                    var getScrollValue = function(e) {
                        scroll.x = (typeof document.documentElement.scrollLeft !== "undefined" ? document.documentElement.scrollLeft : document.body.scrollLeft);
                        scroll.y = (typeof document.documentElement.scrollTop !== "undefined" ? document.documentElement.scrollTop : document.body.scrollTop);
                    };
                    getScrollValue();
                    var getMousePosition = function(e) {
                        var posX = 0,
                            posY = 0;
                        e = e || window.event;
                        if (typeof e.pageX !== "undefined") {
                            posX = e.pageX;
                            posY = e.pageY;
                        } else if (typeof e.clientX !== "undefined") {
                            posX = e.clientX + scroll.x;
                            posY = e.clientY + scroll.y;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    };
                    var getElementPosition = function(h) {
                        var posX = h.offsetLeft;
                        var posY = h.offsetTop;
                        var parent = h.offsetParent;
                        while (parent !== null) {
                            if (parent !== document.body && parent !== document.documentElement) {
                                posX -= parent.scrollLeft;
                                posY -= parent.scrollTop;
                            }
                            var m = parent;
                            var moffx = m.offsetLeft;
                            var moffy = m.offsetTop;
                            if (!moffx && !moffy && window.getComputedStyle) {
                                var matrix = document.defaultView.getComputedStyle(m, null).MozTransform || document.defaultView.getComputedStyle(m, null).WebkitTransform;
                                if (matrix) {
                                    if (typeof matrix === "string") {
                                        var parms = matrix.split(",");
                                        moffx += parseInt(parms[4], 10) || 0;
                                        moffy += parseInt(parms[5], 10) || 0;
                                    }
                                }
                            }
                            posX += moffx;
                            posY += moffy;
                            parent = parent.offsetParent;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    };
                    var setVals = function(obj, vals) {
                        if (obj && vals) {
                            for (var x in vals) {
                                if (vals.hasOwnProperty(x)) {
                                    obj[x] = vals[x];
                                }
                            }
                        }
                        return obj;
                    };
                    var setOpacity = function(h, op) {
                        if (typeof op !== "undefined") {
                            h.style.opacity = op;
                        }
                        if (typeof h.style.opacity !== "undefined" && h.style.opacity !== "") {
                            h.style.filter = "alpha(opacity=" + (h.style.opacity * 100) + ")";
                        }
                    };

                    function DragZoom(map, opt_zoomOpts) {
                        var me = this;
                        var ov = new google.maps.OverlayView();
                        ov.onAdd = function() {
                            me.init_(map, opt_zoomOpts);
                        };
                        ov.draw = function() {};
                        ov.onRemove = function() {};
                        ov.setMap(map);
                        this.prjov_ = ov;
                    }
                    DragZoom.prototype.init_ = function(map, opt_zoomOpts) {
                        var i;
                        var me = this;
                        this.map_ = map;
                        opt_zoomOpts = opt_zoomOpts || {};
                        this.key_ = opt_zoomOpts.key || "shift";
                        this.key_ = this.key_.toLowerCase();
                        this.borderWidths_ = getBorderWidths(this.map_.getDiv());
                        this.veilDiv_ = [];
                        for (i = 0; i < 4; i++) {
                            this.veilDiv_[i] = document.createElement("div");
                            this.veilDiv_[i].onselectstart = function() {
                                return false;
                            };
                            setVals(this.veilDiv_[i].style, {
                                backgroundColor: "gray",
                                opacity: 0.25,
                                cursor: "crosshair"
                            });
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle);
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle);
                            setVals(this.veilDiv_[i].style, {
                                position: "absolute",
                                overflow: "hidden",
                                display: "none"
                            });
                            if (this.key_ === "shift") {
                                this.veilDiv_[i].style.MozUserSelect = "none";
                            }
                            setOpacity(this.veilDiv_[i]);
                            if (this.veilDiv_[i].style.backgroundColor === "transparent") {
                                this.veilDiv_[i].style.backgroundColor = "white";
                                setOpacity(this.veilDiv_[i], 0);
                            }
                            this.map_.getDiv().appendChild(this.veilDiv_[i]);
                        }
                        this.noZoom_ = opt_zoomOpts.noZoom || false;
                        this.visualEnabled_ = opt_zoomOpts.visualEnabled || false;
                        this.visualClass_ = opt_zoomOpts.visualClass || "";
                        this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
                        this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
                        this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
                        this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
                        this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
                        this.visualTips_ = opt_zoomOpts.visualTips || {};
                        this.visualTips_.off = this.visualTips_.off || "Turn on drag zoom mode";
                        this.visualTips_.on = this.visualTips_.on || "Turn off drag zoom mode";
                        this.boxDiv_ = document.createElement("div");
                        setVals(this.boxDiv_.style, {
                            border: "4px solid #736AFF"
                        });
                        setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
                        setVals(this.boxDiv_.style, {
                            position: "absolute",
                            display: "none"
                        });
                        setOpacity(this.boxDiv_);
                        this.map_.getDiv().appendChild(this.boxDiv_);
                        this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
                        this.listeners_ = [google.maps.event.addDomListener(document, "keydown", function(e) {
                            me.onKeyDown_(e);
                        }), google.maps.event.addDomListener(document, "keyup", function(e) {
                            me.onKeyUp_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(document, "mousedown", function(e) {
                            me.onMouseDownDocument_(e);
                        }), google.maps.event.addDomListener(document, "mousemove", function(e) {
                            me.onMouseMove_(e);
                        }), google.maps.event.addDomListener(document, "mouseup", function(e) {
                            me.onMouseUp_(e);
                        }), google.maps.event.addDomListener(window, "scroll", getScrollValue)];
                        this.hotKeyDown_ = false;
                        this.mouseDown_ = false;
                        this.dragging_ = false;
                        this.startPt_ = null;
                        this.endPt_ = null;
                        this.mapWidth_ = null;
                        this.mapHeight_ = null;
                        this.mousePosn_ = null;
                        this.mapPosn_ = null;
                        if (this.visualEnabled_) {
                            this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
                            if (this.visualPositionIndex_ !== null) {
                                this.buttonDiv_.index = this.visualPositionIndex_;
                            }
                            this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
                            this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
                        }
                    };
                    DragZoom.prototype.initControl_ = function(offset) {
                        var control;
                        var image;
                        var me = this;
                        control = document.createElement("div");
                        control.className = this.visualClass_;
                        control.style.position = "relative";
                        control.style.overflow = "hidden";
                        control.style.height = this.visualSize_.height + "px";
                        control.style.width = this.visualSize_.width + "px";
                        control.title = this.visualTips_.off;
                        image = document.createElement("img");
                        image.src = this.visualSprite_;
                        image.style.position = "absolute";
                        image.style.left = -(this.visualSize_.width * 2) + "px";
                        image.style.top = 0 + "px";
                        control.appendChild(image);
                        control.onclick = function(e) {
                            me.hotKeyDown_ = !me.hotKeyDown_;
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                                me.activatedByControl_ = true;
                                google.maps.event.trigger(me, "activate");
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                                google.maps.event.trigger(me, "deactivate");
                            }
                            me.onMouseMove_(e);
                        };
                        control.onmouseover = function() {
                            me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 1) + "px";
                        };
                        control.onmouseout = function() {
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                            }
                        };
                        control.ondragstart = function() {
                            return false;
                        };
                        setVals(control.style, {
                            cursor: "pointer",
                            marginTop: offset.height + "px",
                            marginLeft: offset.width + "px"
                        });
                        return control;
                    };
                    DragZoom.prototype.isHotKeyDown_ = function(e) {
                        var isHot;
                        e = e || window.event;
                        isHot = (e.shiftKey && this.key_ === "shift") || (e.altKey && this.key_ === "alt") || (e.ctrlKey && this.key_ === "ctrl");
                        if (!isHot) {
                            switch (e.keyCode) {
                                case 16:
                                    if (this.key_ === "shift") {
                                        isHot = true;
                                    }
                                    break;
                                case 17:
                                    if (this.key_ === "ctrl") {
                                        isHot = true;
                                    }
                                    break;
                                case 18:
                                    if (this.key_ === "alt") {
                                        isHot = true;
                                    }
                                    break;
                            }
                        }
                        return isHot;
                    };
                    DragZoom.prototype.isMouseOnMap_ = function() {
                        var mousePosn = this.mousePosn_;
                        if (mousePosn) {
                            var mapPosn = this.mapPosn_;
                            var mapDiv = this.map_.getDiv();
                            return mousePosn.left > mapPosn.left && mousePosn.left < (mapPosn.left + mapDiv.offsetWidth) && mousePosn.top > mapPosn.top && mousePosn.top < (mapPosn.top + mapDiv.offsetHeight);
                        } else {
                            return false;
                        }
                    };
                    DragZoom.prototype.setVeilVisibility_ = function() {
                        var i;
                        if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
                            var mapDiv = this.map_.getDiv();
                            this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
                            this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
                            if (this.activatedByControl_) {
                                var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width;
                                var top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height;
                                var width = this.visualSize_.width;
                                var height = this.visualSize_.height;
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.width = left + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                this.veilDiv_[1].style.top = "0px";
                                this.veilDiv_[1].style.left = (left + width) + "px";
                                this.veilDiv_[1].style.width = (this.mapWidth_ - (left + width)) + "px";
                                this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                                this.veilDiv_[2].style.top = "0px";
                                this.veilDiv_[2].style.left = left + "px";
                                this.veilDiv_[2].style.width = width + "px";
                                this.veilDiv_[2].style.height = top + "px";
                                this.veilDiv_[3].style.top = (top + height) + "px";
                                this.veilDiv_[3].style.left = left + "px";
                                this.veilDiv_[3].style.width = width + "px";
                                this.veilDiv_[3].style.height = (this.mapHeight_ - (top + height)) + "px";
                                for (i = 0; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.display = "block";
                                }
                            } else {
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.width = this.mapWidth_ + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                for (i = 1; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.width = "0px";
                                    this.veilDiv_[i].style.height = "0px";
                                }
                                for (i = 0; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.display = "block";
                                }
                            }
                        } else {
                            for (i = 0; i < this.veilDiv_.length; i++) {
                                this.veilDiv_[i].style.display = "none";
                            }
                        }
                    };
                    DragZoom.prototype.onKeyDown_ = function(e) {
                        if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.hotKeyDown_ = true;
                            this.activatedByControl_ = false;
                            this.setVeilVisibility_();
                            google.maps.event.trigger(this, "activate");
                        }
                    };
                    DragZoom.prototype.getMousePoint_ = function(e) {
                        var mousePosn = getMousePosition(e);
                        var p = new google.maps.Point();
                        p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
                        p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
                        p.x = Math.min(p.x, this.mapWidth_);
                        p.y = Math.min(p.y, this.mapHeight_);
                        p.x = Math.max(p.x, 0);
                        p.y = Math.max(p.y, 0);
                        return p;
                    };
                    DragZoom.prototype.onMouseDown_ = function(e) {
                        if (this.map_ && this.hotKeyDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.dragging_ = true;
                            this.startPt_ = this.endPt_ = this.getMousePoint_(e);
                            this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
                            var prj = this.prjov_.getProjection();
                            var latlng = prj.fromContainerPixelToLatLng(this.startPt_);
                            google.maps.event.trigger(this, "dragstart", latlng);
                        }
                    };
                    DragZoom.prototype.onMouseDownDocument_ = function(e) {
                        this.mouseDown_ = true;
                    };
                    DragZoom.prototype.onMouseMove_ = function(e) {
                        this.mousePosn_ = getMousePosition(e);
                        if (this.dragging_) {
                            this.endPt_ = this.getMousePoint_(e);
                            var left = Math.min(this.startPt_.x, this.endPt_.x);
                            var top = Math.min(this.startPt_.y, this.endPt_.y);
                            var width = Math.abs(this.startPt_.x - this.endPt_.x);
                            var height = Math.abs(this.startPt_.y - this.endPt_.y);
                            var boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right));
                            var boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
                            this.veilDiv_[0].style.top = "0px";
                            this.veilDiv_[0].style.left = "0px";
                            this.veilDiv_[0].style.width = left + "px";
                            this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                            this.veilDiv_[1].style.top = "0px";
                            this.veilDiv_[1].style.left = (left + width) + "px";
                            this.veilDiv_[1].style.width = (this.mapWidth_ - (left + width)) + "px";
                            this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                            this.veilDiv_[2].style.top = "0px";
                            this.veilDiv_[2].style.left = left + "px";
                            this.veilDiv_[2].style.width = width + "px";
                            this.veilDiv_[2].style.height = top + "px";
                            this.veilDiv_[3].style.top = (top + height) + "px";
                            this.veilDiv_[3].style.left = left + "px";
                            this.veilDiv_[3].style.width = width + "px";
                            this.veilDiv_[3].style.height = (this.mapHeight_ - (top + height)) + "px";
                            this.boxDiv_.style.top = top + "px";
                            this.boxDiv_.style.left = left + "px";
                            this.boxDiv_.style.width = boxWidth + "px";
                            this.boxDiv_.style.height = boxHeight + "px";
                            this.boxDiv_.style.display = "block";
                            google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
                        } else if (!this.mouseDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.setVeilVisibility_();
                        }
                    };
                    DragZoom.prototype.onMouseUp_ = function(e) {
                        var z;
                        var me = this;
                        this.mouseDown_ = false;
                        if (this.dragging_) {
                            if ((this.getMousePoint_(e).x === this.startPt_.x) && (this.getMousePoint_(e).y === this.startPt_.y)) {
                                this.onKeyUp_(e);
                                return;
                            }
                            var left = Math.min(this.startPt_.x, this.endPt_.x);
                            var top = Math.min(this.startPt_.y, this.endPt_.y);
                            var width = Math.abs(this.startPt_.x - this.endPt_.x);
                            var height = Math.abs(this.startPt_.y - this.endPt_.y);
                            var kGoogleCenteringBug = true;
                            if (kGoogleCenteringBug) {
                                left += this.borderWidths_.left;
                                top += this.borderWidths_.top;
                            }
                            var prj = this.prjov_.getProjection();
                            var sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                            var ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                            var bnds = new google.maps.LatLngBounds(sw, ne);
                            if (this.noZoom_) {
                                this.boxDiv_.style.display = "none";
                            } else {
                                z = this.map_.getZoom();
                                this.map_.fitBounds(bnds);
                                if (this.map_.getZoom() < z) {
                                    this.map_.setZoom(z);
                                }
                                var swPt = prj.fromLatLngToContainerPixel(sw);
                                var nePt = prj.fromLatLngToContainerPixel(ne);
                                if (kGoogleCenteringBug) {
                                    swPt.x -= this.borderWidths_.left;
                                    swPt.y -= this.borderWidths_.top;
                                    nePt.x -= this.borderWidths_.left;
                                    nePt.y -= this.borderWidths_.top;
                                }
                                this.boxDiv_.style.left = swPt.x + "px";
                                this.boxDiv_.style.top = nePt.y + "px";
                                this.boxDiv_.style.width = (Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right)) + "px";
                                this.boxDiv_.style.height = (Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom)) + "px";
                                setTimeout(function() {
                                    me.boxDiv_.style.display = "none";
                                }, 1000);
                            }
                            this.dragging_ = false;
                            this.onMouseMove_(e);
                            google.maps.event.trigger(this, "dragend", bnds);
                            if (!this.isHotKeyDown_(e)) {
                                this.onKeyUp_(e);
                            }
                        }
                    };
                    DragZoom.prototype.onKeyUp_ = function(e) {
                        var i;
                        var left, top, width, height, prj, sw, ne;
                        var bnds = null;
                        if (this.map_ && this.hotKeyDown_) {
                            this.hotKeyDown_ = false;
                            if (this.dragging_) {
                                this.boxDiv_.style.display = "none";
                                this.dragging_ = false;
                                left = Math.min(this.startPt_.x, this.endPt_.x);
                                top = Math.min(this.startPt_.y, this.endPt_.y);
                                width = Math.abs(this.startPt_.x - this.endPt_.x);
                                height = Math.abs(this.startPt_.y - this.endPt_.y);
                                prj = this.prjov_.getProjection();
                                sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                                ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                                bnds = new google.maps.LatLngBounds(sw, ne);
                            }
                            for (i = 0; i < this.veilDiv_.length; i++) {
                                this.veilDiv_[i].style.display = "none";
                            }
                            if (this.visualEnabled_) {
                                this.buttonDiv_.firstChild.style.left = -(this.visualSize_.width * 2) + "px";
                                this.buttonDiv_.title = this.visualTips_.off;
                                this.buttonDiv_.style.display = "";
                            }
                            google.maps.event.trigger(this, "deactivate", bnds);
                        }
                    };
                    google.maps.Map.prototype.enableKeyDragZoom = function(opt_zoomOpts) {
                        this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
                    };
                    google.maps.Map.prototype.disableKeyDragZoom = function() {
                        var i;
                        var d = this.dragZoom_;
                        if (d) {
                            for (i = 0; i < d.listeners_.length; ++i) {
                                google.maps.event.removeListener(d.listeners_[i]);
                            }
                            this.getDiv().removeChild(d.boxDiv_);
                            for (i = 0; i < d.veilDiv_.length; i++) {
                                this.getDiv().removeChild(d.veilDiv_[i]);
                            }
                            if (d.visualEnabled_) {
                                this.controls[d.visualPosition_].removeAt(d.controlIndex_);
                            }
                            d.prjov_.setMap(null);
                            this.dragZoom_ = null;
                        }
                    };
                    google.maps.Map.prototype.keyDragZoomEnabled = function() {
                        return this.dragZoom_ !== null;
                    };
                    google.maps.Map.prototype.getDragZoomObject = function() {
                        return this.dragZoom_;
                    };
                })();

                function ClusterIcon(cluster, styles) {
                    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);
                    this.cluster_ = cluster;
                    this.className_ = cluster.getMarkerClusterer().getClusterClass();
                    this.styles_ = styles;
                    this.center_ = null;
                    this.div_ = null;
                    this.sums_ = null;
                    this.visible_ = false;
                    this.setMap(cluster.getMap());
                }
                ClusterIcon.prototype.onAdd = function() {
                    var cClusterIcon = this;
                    var cMouseDownInCluster;
                    var cDraggingMapByCluster;
                    this.div_ = document.createElement("div");
                    this.div_.className = this.className_;
                    if (this.visible_) {
                        this.show();
                    }
                    this.getPanes().overlayMouseTarget.appendChild(this.div_);
                    this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
                        cDraggingMapByCluster = cMouseDownInCluster;
                    });
                    google.maps.event.addDomListener(this.div_, "mousedown", function() {
                        cMouseDownInCluster = true;
                        cDraggingMapByCluster = false;
                    });
                    google.maps.event.addDomListener(this.div_, "click", function(e) {
                        cMouseDownInCluster = false;
                        if (!cDraggingMapByCluster) {
                            var theBounds;
                            var mz;
                            var mc = cClusterIcon.cluster_.getMarkerClusterer();
                            google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
                            google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_);
                            if (mc.getZoomOnClick()) {
                                mz = mc.getMaxZoom();
                                theBounds = cClusterIcon.cluster_.getBounds();
                                mc.getMap().fitBounds(theBounds);
                                setTimeout(function() {
                                    mc.getMap().fitBounds(theBounds);
                                    if (mz !== null && (mc.getMap().getZoom() > mz)) {
                                        mc.getMap().setZoom(mz + 1);
                                    }
                                }, 100);
                            }
                            e.cancelBubble = true;
                            if (e.stopPropagation) {
                                e.stopPropagation();
                            }
                        }
                    });
                    google.maps.event.addDomListener(this.div_, "mouseover", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
                    });
                    google.maps.event.addDomListener(this.div_, "mouseout", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
                    });
                };
                ClusterIcon.prototype.onRemove = function() {
                    if (this.div_ && this.div_.parentNode) {
                        this.hide();
                        google.maps.event.removeListener(this.boundsChangedListener_);
                        google.maps.event.clearInstanceListeners(this.div_);
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                ClusterIcon.prototype.draw = function() {
                    if (this.visible_) {
                        var pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.top = pos.y + "px";
                        this.div_.style.left = pos.x + "px";
                    }
                };
                ClusterIcon.prototype.hide = function() {
                    if (this.div_) {
                        this.div_.style.display = "none";
                    }
                    this.visible_ = false;
                };
                ClusterIcon.prototype.show = function() {
                    if (this.div_) {
                        var img = "";
                        var bp = this.backgroundPosition_.split(" ");
                        var spriteH = parseInt(bp[0].trim(), 10);
                        var spriteV = parseInt(bp[1].trim(), 10);
                        var pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.cssText = this.createCss(pos);
                        img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                        if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
                            img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " + ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
                        }
                        img += "'>";
                        this.div_.innerHTML = img + "<div style='" + "position: absolute;" + "top: " + this.anchorText_[0] + "px;" + "left: " + this.anchorText_[1] + "px;" + "color: " + this.textColor_ + ";" + "font-size: " + this.textSize_ + "px;" + "font-family: " + this.fontFamily_ + ";" + "font-weight: " + this.fontWeight_ + ";" + "font-style: " + this.fontStyle_ + ";" + "text-decoration: " + this.textDecoration_ + ";" + "text-align: center;" + "width: " + this.width_ + "px;" + "line-height:" + this.height_ + "px;" + "'>" + this.sums_.text + "</div>";
                        if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
                            this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
                        } else {
                            this.div_.title = this.sums_.title;
                        }
                        this.div_.style.display = "";
                    }
                    this.visible_ = true;
                };
                ClusterIcon.prototype.useStyle = function(sums) {
                    this.sums_ = sums;
                    var index = Math.max(0, sums.index - 1);
                    index = Math.min(this.styles_.length - 1, index);
                    var style = this.styles_[index];
                    this.url_ = style.url;
                    this.height_ = style.height;
                    this.width_ = style.width;
                    this.anchorText_ = style.anchorText || [0, 0];
                    this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
                    this.textColor_ = style.textColor || "black";
                    this.textSize_ = style.textSize || 11;
                    this.textDecoration_ = style.textDecoration || "none";
                    this.fontWeight_ = style.fontWeight || "bold";
                    this.fontStyle_ = style.fontStyle || "normal";
                    this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
                    this.backgroundPosition_ = style.backgroundPosition || "0 0";
                };
                ClusterIcon.prototype.setCenter = function(center) {
                    this.center_ = center;
                };
                ClusterIcon.prototype.createCss = function(pos) {
                    var style = [];
                    style.push("cursor: pointer;");
                    style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
                    style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
                    return style.join("");
                };
                ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
                    var pos = this.getProjection().fromLatLngToDivPixel(latlng);
                    pos.x -= this.anchorIcon_[1];
                    pos.y -= this.anchorIcon_[0];
                    pos.x = parseInt(pos.x, 10);
                    pos.y = parseInt(pos.y, 10);
                    return pos;
                };

                function Cluster(mc) {
                    this.markerClusterer_ = mc;
                    this.map_ = mc.getMap();
                    this.gridSize_ = mc.getGridSize();
                    this.minClusterSize_ = mc.getMinimumClusterSize();
                    this.averageCenter_ = mc.getAverageCenter();
                    this.markers_ = [];
                    this.center_ = null;
                    this.bounds_ = null;
                    this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
                }
                Cluster.prototype.getSize = function() {
                    return this.markers_.length;
                };
                Cluster.prototype.getMarkers = function() {
                    return this.markers_;
                };
                Cluster.prototype.getCenter = function() {
                    return this.center_;
                };
                Cluster.prototype.getMap = function() {
                    return this.map_;
                };
                Cluster.prototype.getMarkerClusterer = function() {
                    return this.markerClusterer_;
                };
                Cluster.prototype.getBounds = function() {
                    var i;
                    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                    var markers = this.getMarkers();
                    for (i = 0; i < markers.length; i++) {
                        bounds.extend(markers[i].getPosition());
                    }
                    return bounds;
                };
                Cluster.prototype.remove = function() {
                    this.clusterIcon_.setMap(null);
                    this.markers_ = [];
                    delete this.markers_;
                };
                Cluster.prototype.addMarker = function(marker) {
                    var i;
                    var mCount;
                    var mz;
                    if (this.isMarkerAlreadyAdded_(marker)) {
                        return false;
                    }
                    if (!this.center_) {
                        this.center_ = marker.getPosition();
                        this.calculateBounds_();
                    } else {
                        if (this.averageCenter_) {
                            var l = this.markers_.length + 1;
                            var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                            var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                            this.center_ = new google.maps.LatLng(lat, lng);
                            this.calculateBounds_();
                        }
                    }
                    marker.isAdded = true;
                    this.markers_.push(marker);
                    mCount = this.markers_.length;
                    mz = this.markerClusterer_.getMaxZoom();
                    if (mz !== null && this.map_.getZoom() > mz) {
                        if (marker.getMap() !== this.map_) {
                            marker.setMap(this.map_);
                        }
                    } else if (mCount < this.minClusterSize_) {
                        if (marker.getMap() !== this.map_) {
                            marker.setMap(this.map_);
                        }
                    } else if (mCount === this.minClusterSize_) {
                        for (i = 0; i < mCount; i++) {
                            this.markers_[i].setMap(null);
                        }
                    } else {
                        marker.setMap(null);
                    }
                    this.updateIcon_();
                    return true;
                };
                Cluster.prototype.isMarkerInClusterBounds = function(marker) {
                    return this.bounds_.contains(marker.getPosition());
                };
                Cluster.prototype.calculateBounds_ = function() {
                    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
                };
                Cluster.prototype.updateIcon_ = function() {
                    var mCount = this.markers_.length;
                    var mz = this.markerClusterer_.getMaxZoom();
                    if (mz !== null && this.map_.getZoom() > mz) {
                        this.clusterIcon_.hide();
                        return;
                    }
                    if (mCount < this.minClusterSize_) {
                        this.clusterIcon_.hide();
                        return;
                    }
                    var numStyles = this.markerClusterer_.getStyles().length;
                    var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
                    this.clusterIcon_.setCenter(this.center_);
                    this.clusterIcon_.useStyle(sums);
                    this.clusterIcon_.show();
                };
                Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                    var i;
                    if (this.markers_.indexOf) {
                        return this.markers_.indexOf(marker) !== -1;
                    } else {
                        for (i = 0; i < this.markers_.length; i++) {
                            if (marker === this.markers_[i]) {
                                return true;
                            }
                        }
                    }
                    return false;
                };

                function MarkerClusterer(map, opt_markers, opt_options) {
                    this.extend(MarkerClusterer, google.maps.OverlayView);
                    opt_markers = opt_markers || [];
                    opt_options = opt_options || {};
                    this.markers_ = [];
                    this.clusters_ = [];
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = false;
                    this.gridSize_ = opt_options.gridSize || 60;
                    this.minClusterSize_ = opt_options.minimumClusterSize || 2;
                    this.maxZoom_ = opt_options.maxZoom || null;
                    this.styles_ = opt_options.styles || [];
                    this.title_ = opt_options.title || "";
                    this.zoomOnClick_ = true;
                    if (opt_options.zoomOnClick !== undefined) {
                        this.zoomOnClick_ = opt_options.zoomOnClick;
                    }
                    this.averageCenter_ = false;
                    if (opt_options.averageCenter !== undefined) {
                        this.averageCenter_ = opt_options.averageCenter;
                    }
                    this.ignoreHidden_ = false;
                    if (opt_options.ignoreHidden !== undefined) {
                        this.ignoreHidden_ = opt_options.ignoreHidden;
                    }
                    this.enableRetinaIcons_ = false;
                    if (opt_options.enableRetinaIcons !== undefined) {
                        this.enableRetinaIcons_ = opt_options.enableRetinaIcons;
                    }
                    this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
                    this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
                    this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
                    this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
                    this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
                    this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
                    this.clusterClass_ = opt_options.clusterClass || "cluster";
                    if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
                        this.batchSize_ = this.batchSizeIE_;
                    }
                    this.setupStyles_();
                    this.addMarkers(opt_markers, true);
                    this.setMap(map);
                }
                MarkerClusterer.prototype.onAdd = function() {
                    var cMarkerClusterer = this;
                    this.activeMap_ = this.getMap();
                    this.ready_ = true;
                    this.repaint();
                    this.listeners_ = [google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
                        cMarkerClusterer.resetViewport_(false);
                        if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
                            google.maps.event.trigger(this, "idle");
                        }
                    }), google.maps.event.addListener(this.getMap(), "idle", function() {
                        cMarkerClusterer.redraw_();
                    })];
                };
                MarkerClusterer.prototype.onRemove = function() {
                    var i;
                    for (i = 0; i < this.markers_.length; i++) {
                        if (this.markers_[i].getMap() !== this.activeMap_) {
                            this.markers_[i].setMap(this.activeMap_);
                        }
                    }
                    for (i = 0; i < this.clusters_.length; i++) {
                        this.clusters_[i].remove();
                    }
                    this.clusters_ = [];
                    for (i = 0; i < this.listeners_.length; i++) {
                        google.maps.event.removeListener(this.listeners_[i]);
                    }
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = false;
                };
                MarkerClusterer.prototype.draw = function() {};
                MarkerClusterer.prototype.setupStyles_ = function() {
                    var i, size;
                    if (this.styles_.length > 0) {
                        return;
                    }
                    for (i = 0; i < this.imageSizes_.length; i++) {
                        size = this.imageSizes_[i];
                        this.styles_.push({
                            url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                            height: size,
                            width: size
                        });
                    }
                };
                MarkerClusterer.prototype.fitMapToMarkers = function() {
                    var i;
                    var markers = this.getMarkers();
                    var bounds = new google.maps.LatLngBounds();
                    for (i = 0; i < markers.length; i++) {
                        bounds.extend(markers[i].getPosition());
                    }
                    this.getMap().fitBounds(bounds);
                };
                MarkerClusterer.prototype.getGridSize = function() {
                    return this.gridSize_;
                };
                MarkerClusterer.prototype.setGridSize = function(gridSize) {
                    this.gridSize_ = gridSize;
                };
                MarkerClusterer.prototype.getMinimumClusterSize = function() {
                    return this.minClusterSize_;
                };
                MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
                    this.minClusterSize_ = minimumClusterSize;
                };
                MarkerClusterer.prototype.getMaxZoom = function() {
                    return this.maxZoom_;
                };
                MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
                    this.maxZoom_ = maxZoom;
                };
                MarkerClusterer.prototype.getStyles = function() {
                    return this.styles_;
                };
                MarkerClusterer.prototype.setStyles = function(styles) {
                    this.styles_ = styles;
                };
                MarkerClusterer.prototype.getTitle = function() {
                    return this.title_;
                };
                MarkerClusterer.prototype.setTitle = function(title) {
                    this.title_ = title;
                };
                MarkerClusterer.prototype.getZoomOnClick = function() {
                    return this.zoomOnClick_;
                };
                MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
                    this.zoomOnClick_ = zoomOnClick;
                };
                MarkerClusterer.prototype.getAverageCenter = function() {
                    return this.averageCenter_;
                };
                MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
                    this.averageCenter_ = averageCenter;
                };
                MarkerClusterer.prototype.getIgnoreHidden = function() {
                    return this.ignoreHidden_;
                };
                MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
                    this.ignoreHidden_ = ignoreHidden;
                };
                MarkerClusterer.prototype.getEnableRetinaIcons = function() {
                    return this.enableRetinaIcons_;
                };
                MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
                    this.enableRetinaIcons_ = enableRetinaIcons;
                };
                MarkerClusterer.prototype.getImageExtension = function() {
                    return this.imageExtension_;
                };
                MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
                    this.imageExtension_ = imageExtension;
                };
                MarkerClusterer.prototype.getImagePath = function() {
                    return this.imagePath_;
                };
                MarkerClusterer.prototype.setImagePath = function(imagePath) {
                    this.imagePath_ = imagePath;
                };
                MarkerClusterer.prototype.getImageSizes = function() {
                    return this.imageSizes_;
                };
                MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
                    this.imageSizes_ = imageSizes;
                };
                MarkerClusterer.prototype.getCalculator = function() {
                    return this.calculator_;
                };
                MarkerClusterer.prototype.setCalculator = function(calculator) {
                    this.calculator_ = calculator;
                };
                MarkerClusterer.prototype.getBatchSizeIE = function() {
                    return this.batchSizeIE_;
                };
                MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
                    this.batchSizeIE_ = batchSizeIE;
                };
                MarkerClusterer.prototype.getClusterClass = function() {
                    return this.clusterClass_;
                };
                MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
                    this.clusterClass_ = clusterClass;
                };
                MarkerClusterer.prototype.getMarkers = function() {
                    return this.markers_;
                };
                MarkerClusterer.prototype.getTotalMarkers = function() {
                    return this.markers_.length;
                };
                MarkerClusterer.prototype.getClusters = function() {
                    return this.clusters_;
                };
                MarkerClusterer.prototype.getTotalClusters = function() {
                    return this.clusters_.length;
                };
                MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
                    this.pushMarkerTo_(marker);
                    if (!opt_nodraw) {
                        this.redraw_();
                    }
                };
                MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
                    var key;
                    for (key in markers) {
                        if (markers.hasOwnProperty(key)) {
                            this.pushMarkerTo_(markers[key]);
                        }
                    }
                    if (!opt_nodraw) {
                        this.redraw_();
                    }
                };
                MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
                    if (marker.getDraggable()) {
                        var cMarkerClusterer = this;
                        google.maps.event.addListener(marker, "dragend", function() {
                            if (cMarkerClusterer.ready_) {
                                this.isAdded = false;
                                cMarkerClusterer.repaint();
                            }
                        });
                    }
                    marker.isAdded = false;
                    this.markers_.push(marker);
                };
                MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
                    var removed = this.removeMarker_(marker);
                    if (!opt_nodraw && removed) {
                        this.repaint();
                    }
                    return removed;
                };
                MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
                    var i, r;
                    var removed = false;
                    for (i = 0; i < markers.length; i++) {
                        r = this.removeMarker_(markers[i]);
                        removed = removed || r;
                    }
                    if (!opt_nodraw && removed) {
                        this.repaint();
                    }
                    return removed;
                };
                MarkerClusterer.prototype.removeMarker_ = function(marker) {
                    var i;
                    var index = -1;
                    if (this.markers_.indexOf) {
                        index = this.markers_.indexOf(marker);
                    } else {
                        for (i = 0; i < this.markers_.length; i++) {
                            if (marker === this.markers_[i]) {
                                index = i;
                                break;
                            }
                        }
                    }
                    if (index === -1) {
                        return false;
                    }
                    marker.setMap(null);
                    this.markers_.splice(index, 1);
                    return true;
                };
                MarkerClusterer.prototype.clearMarkers = function() {
                    this.resetViewport_(true);
                    this.markers_ = [];
                };
                MarkerClusterer.prototype.repaint = function() {
                    var oldClusters = this.clusters_.slice();
                    this.clusters_ = [];
                    this.resetViewport_(false);
                    this.redraw_();
                    setTimeout(function() {
                        var i;
                        for (i = 0; i < oldClusters.length; i++) {
                            oldClusters[i].remove();
                        }
                    }, 0);
                };
                MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
                    var projection = this.getProjection();
                    var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());
                    var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());
                    var trPix = projection.fromLatLngToDivPixel(tr);
                    trPix.x += this.gridSize_;
                    trPix.y -= this.gridSize_;
                    var blPix = projection.fromLatLngToDivPixel(bl);
                    blPix.x -= this.gridSize_;
                    blPix.y += this.gridSize_;
                    var ne = projection.fromDivPixelToLatLng(trPix);
                    var sw = projection.fromDivPixelToLatLng(blPix);
                    bounds.extend(ne);
                    bounds.extend(sw);
                    return bounds;
                };
                MarkerClusterer.prototype.redraw_ = function() {
                    this.createClusters_(0);
                };
                MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                    var i, marker;
                    for (i = 0; i < this.clusters_.length; i++) {
                        this.clusters_[i].remove();
                    }
                    this.clusters_ = [];
                    for (i = 0; i < this.markers_.length; i++) {
                        marker = this.markers_[i];
                        marker.isAdded = false;
                        if (opt_hide) {
                            marker.setMap(null);
                        }
                    }
                };
                MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
                    var R = 6371;
                    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
                    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
                    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
                    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    var d = R * c;
                    return d;
                };
                MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
                    return bounds.contains(marker.getPosition());
                };
                MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                    var i, d, cluster, center;
                    var distance = 40000;
                    var clusterToAddTo = null;
                    for (i = 0; i < this.clusters_.length; i++) {
                        cluster = this.clusters_[i];
                        center = cluster.getCenter();
                        if (center) {
                            d = this.distanceBetweenPoints_(center, marker.getPosition());
                            if (d < distance) {
                                distance = d;
                                clusterToAddTo = cluster;
                            }
                        }
                    }
                    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
                        clusterToAddTo.addMarker(marker);
                    } else {
                        cluster = new Cluster(this);
                        cluster.addMarker(marker);
                        this.clusters_.push(cluster);
                    }
                };
                MarkerClusterer.prototype.createClusters_ = function(iFirst) {
                    var i, marker;
                    var mapBounds;
                    var cMarkerClusterer = this;
                    if (!this.ready_) {
                        return;
                    }
                    if (iFirst === 0) {
                        google.maps.event.trigger(this, "clusteringbegin", this);
                        if (typeof this.timerRefStatic !== "undefined") {
                            clearTimeout(this.timerRefStatic);
                            delete this.timerRefStatic;
                        }
                    }
                    if (this.getMap().getZoom() > 3) {
                        mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());
                    } else {
                        mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                    }
                    var bounds = this.getExtendedBounds(mapBounds);
                    var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                    for (i = iFirst; i < iLast; i++) {
                        marker = this.markers_[i];
                        if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
                            if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
                                this.addToClosestCluster_(marker);
                            }
                        }
                    }
                    if (iLast < this.markers_.length) {
                        this.timerRefStatic = setTimeout(function() {
                            cMarkerClusterer.createClusters_(iLast);
                        }, 0);
                    } else {
                        delete this.timerRefStatic;
                        google.maps.event.trigger(this, "clusteringend", this);
                    }
                };
                MarkerClusterer.prototype.extend = function(obj1, obj2) {
                    return (function(object) {
                        var property;
                        for (property in object.prototype) {
                            this.prototype[property] = object.prototype[property];
                        }
                        return this;
                    }).apply(obj1, [obj2]);
                };
                MarkerClusterer.CALCULATOR = function(markers, numStyles) {
                    var index = 0;
                    var title = "";
                    var count = markers.length.toString();
                    var dv = count;
                    while (dv !== 0) {
                        dv = parseInt(dv / 10, 10);
                        index++;
                    }
                    index = Math.min(index, numStyles);
                    return {
                        text: count,
                        index: index,
                        title: title
                    };
                };
                MarkerClusterer.BATCH_SIZE = 2000;
                MarkerClusterer.BATCH_SIZE_IE = 500;
                MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";
                MarkerClusterer.IMAGE_EXTENSION = "png";
                MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];

                function inherits(childCtor, parentCtor) {
                    function tempCtor() {}
                    tempCtor.prototype = parentCtor.prototype;
                    childCtor.superClass_ = parentCtor.prototype;
                    childCtor.prototype = new tempCtor();
                    childCtor.prototype.constructor = childCtor;
                }

                function MarkerLabel_(marker, crossURL, handCursorURL) {
                    this.marker_ = marker;
                    this.handCursorURL_ = marker.handCursorURL;
                    this.labelDiv_ = document.createElement("div");
                    this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
                    this.eventDiv_ = document.createElement("div");
                    this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
                    this.eventDiv_.setAttribute("onselectstart", "return false;");
                    this.eventDiv_.setAttribute("ondragstart", "return false;");
                    this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
                }
                inherits(MarkerLabel_, google.maps.OverlayView);
                MarkerLabel_.getSharedCross = function(crossURL) {
                    var div;
                    if (typeof MarkerLabel_.getSharedCross.crossDiv === "undefined") {
                        div = document.createElement("img");
                        div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
                        div.style.marginLeft = "-8px";
                        div.style.marginTop = "-9px";
                        div.src = crossURL;
                        MarkerLabel_.getSharedCross.crossDiv = div;
                    }
                    return MarkerLabel_.getSharedCross.crossDiv;
                };
                MarkerLabel_.prototype.onAdd = function() {
                    var me = this;
                    var cMouseIsDown = false;
                    var cDraggingLabel = false;
                    var cSavedZIndex;
                    var cLatOffset, cLngOffset;
                    var cIgnoreClick;
                    var cRaiseEnabled;
                    var cStartPosition;
                    var cStartCenter;
                    var cRaiseOffset = 20;
                    var cDraggingCursor = "url(" + this.handCursorURL_ + ")";
                    var cAbortEvent = function(e) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        e.cancelBubble = true;
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                    };
                    var cStopBounce = function() {
                        me.marker_.setAnimation(null);
                    };
                    this.getPanes().overlayImage.appendChild(this.labelDiv_);
                    this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
                    if (typeof MarkerLabel_.getSharedCross.processed === "undefined") {
                        this.getPanes().overlayImage.appendChild(this.crossDiv_);
                        MarkerLabel_.getSharedCross.processed = true;
                    }
                    this.listeners_ = [google.maps.event.addDomListener(this.eventDiv_, "mouseover", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            this.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseover", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mouseout", function(e) {
                        if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
                            this.style.cursor = me.marker_.getCursor();
                            google.maps.event.trigger(me.marker_, "mouseout", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mousedown", function(e) {
                        cDraggingLabel = false;
                        if (me.marker_.getDraggable()) {
                            cMouseIsDown = true;
                            this.style.cursor = cDraggingCursor;
                        }
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "mousedown", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addDomListener(document, "mouseup", function(mEvent) {
                        var position;
                        if (cMouseIsDown) {
                            cMouseIsDown = false;
                            me.eventDiv_.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseup", mEvent);
                        }
                        if (cDraggingLabel) {
                            if (cRaiseEnabled) {
                                position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
                                position.y += cRaiseOffset;
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                try {
                                    me.marker_.setAnimation(google.maps.Animation.BOUNCE);
                                    setTimeout(cStopBounce, 1406);
                                } catch (e) {}
                            }
                            me.crossDiv_.style.display = "none";
                            me.marker_.setZIndex(cSavedZIndex);
                            cIgnoreClick = true;
                            cDraggingLabel = false;
                            mEvent.latLng = me.marker_.getPosition();
                            google.maps.event.trigger(me.marker_, "dragend", mEvent);
                        }
                    }), google.maps.event.addListener(me.marker_.getMap(), "mousemove", function(mEvent) {
                        var position;
                        if (cMouseIsDown) {
                            if (cDraggingLabel) {
                                mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
                                position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
                                if (cRaiseEnabled) {
                                    me.crossDiv_.style.left = position.x + "px";
                                    me.crossDiv_.style.top = position.y + "px";
                                    me.crossDiv_.style.display = "";
                                    position.y -= cRaiseOffset;
                                }
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                if (cRaiseEnabled) {
                                    me.eventDiv_.style.top = (position.y + cRaiseOffset) + "px";
                                }
                                google.maps.event.trigger(me.marker_, "drag", mEvent);
                            } else {
                                cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
                                cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
                                cSavedZIndex = me.marker_.getZIndex();
                                cStartPosition = me.marker_.getPosition();
                                cStartCenter = me.marker_.getMap().getCenter();
                                cRaiseEnabled = me.marker_.get("raiseOnDrag");
                                cDraggingLabel = true;
                                me.marker_.setZIndex(1000000);
                                mEvent.latLng = me.marker_.getPosition();
                                google.maps.event.trigger(me.marker_, "dragstart", mEvent);
                            }
                        }
                    }), google.maps.event.addDomListener(document, "keydown", function(e) {
                        if (cDraggingLabel) {
                            if (e.keyCode === 27) {
                                cRaiseEnabled = false;
                                me.marker_.setPosition(cStartPosition);
                                me.marker_.getMap().setCenter(cStartCenter);
                                google.maps.event.trigger(document, "mouseup", e);
                            }
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "click", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            if (cIgnoreClick) {
                                cIgnoreClick = false;
                            } else {
                                google.maps.event.trigger(me.marker_, "click", e);
                                cAbortEvent(e);
                            }
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "dblclick", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "dblclick", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addListener(this.marker_, "dragstart", function(mEvent) {
                        if (!cDraggingLabel) {
                            cRaiseEnabled = this.get("raiseOnDrag");
                        }
                    }), google.maps.event.addListener(this.marker_, "drag", function(mEvent) {
                        if (!cDraggingLabel) {
                            if (cRaiseEnabled) {
                                me.setPosition(cRaiseOffset);
                                me.labelDiv_.style.zIndex = 1000000 + (this.get("labelInBackground") ? -1 : +1);
                            }
                        }
                    }), google.maps.event.addListener(this.marker_, "dragend", function(mEvent) {
                        if (!cDraggingLabel) {
                            if (cRaiseEnabled) {
                                me.setPosition(0);
                            }
                        }
                    }), google.maps.event.addListener(this.marker_, "position_changed", function() {
                        me.setPosition();
                    }), google.maps.event.addListener(this.marker_, "zindex_changed", function() {
                        me.setZIndex();
                    }), google.maps.event.addListener(this.marker_, "visible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "labelvisible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "title_changed", function() {
                        me.setTitle();
                    }), google.maps.event.addListener(this.marker_, "labelcontent_changed", function() {
                        me.setContent();
                    }), google.maps.event.addListener(this.marker_, "labelanchor_changed", function() {
                        me.setAnchor();
                    }), google.maps.event.addListener(this.marker_, "labelclass_changed", function() {
                        me.setStyles();
                    }), google.maps.event.addListener(this.marker_, "labelstyle_changed", function() {
                        me.setStyles();
                    })];
                };
                MarkerLabel_.prototype.onRemove = function() {
                    var i;
                    this.labelDiv_.parentNode.removeChild(this.labelDiv_);
                    this.eventDiv_.parentNode.removeChild(this.eventDiv_);
                    for (i = 0; i < this.listeners_.length; i++) {
                        google.maps.event.removeListener(this.listeners_[i]);
                    }
                };
                MarkerLabel_.prototype.draw = function() {
                    this.setContent();
                    this.setTitle();
                    this.setStyles();
                };
                MarkerLabel_.prototype.setContent = function() {
                    var content = this.marker_.get("labelContent");
                    if (typeof content.nodeType === "undefined") {
                        this.labelDiv_.innerHTML = content;
                        this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                    } else {
                        this.labelDiv_.innerHTML = "";
                        this.labelDiv_.appendChild(content);
                        content = content.cloneNode(true);
                        this.eventDiv_.innerHTML = "";
                        this.eventDiv_.appendChild(content);
                    }
                };
                MarkerLabel_.prototype.setTitle = function() {
                    this.eventDiv_.title = this.marker_.getTitle() || "";
                };
                MarkerLabel_.prototype.setStyles = function() {
                    var i, labelStyle;
                    this.labelDiv_.className = this.marker_.get("labelClass");
                    this.eventDiv_.className = this.labelDiv_.className;
                    this.labelDiv_.style.cssText = "";
                    this.eventDiv_.style.cssText = "";
                    labelStyle = this.marker_.get("labelStyle");
                    for (i in labelStyle) {
                        if (labelStyle.hasOwnProperty(i)) {
                            this.labelDiv_.style[i] = labelStyle[i];
                            this.eventDiv_.style[i] = labelStyle[i];
                        }
                    }
                    this.setMandatoryStyles();
                };
                MarkerLabel_.prototype.setMandatoryStyles = function() {
                    this.labelDiv_.style.position = "absolute";
                    this.labelDiv_.style.overflow = "hidden";
                    if (typeof this.labelDiv_.style.opacity !== "undefined" && this.labelDiv_.style.opacity !== "") {
                        this.labelDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")\"";
                        this.labelDiv_.style.filter = "alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")";
                    }
                    this.eventDiv_.style.position = this.labelDiv_.style.position;
                    this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
                    this.eventDiv_.style.opacity = 0.01;
                    this.eventDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=1)\"";
                    this.eventDiv_.style.filter = "alpha(opacity=1)";
                    this.setAnchor();
                    this.setPosition();
                    this.setVisible();
                };
                MarkerLabel_.prototype.setAnchor = function() {
                    var anchor = this.marker_.get("labelAnchor");
                    this.labelDiv_.style.marginLeft = -anchor.x + "px";
                    this.labelDiv_.style.marginTop = -anchor.y + "px";
                    this.eventDiv_.style.marginLeft = -anchor.x + "px";
                    this.eventDiv_.style.marginTop = -anchor.y + "px";
                };
                MarkerLabel_.prototype.setPosition = function(yOffset) {
                    var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
                    if (typeof yOffset === "undefined") {
                        yOffset = 0;
                    }
                    this.labelDiv_.style.left = Math.round(position.x) + "px";
                    this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
                    this.eventDiv_.style.left = this.labelDiv_.style.left;
                    this.eventDiv_.style.top = this.labelDiv_.style.top;
                    this.setZIndex();
                };
                MarkerLabel_.prototype.setZIndex = function() {
                    var zAdjust = (this.marker_.get("labelInBackground") ? -1 : +1);
                    if (typeof this.marker_.getZIndex() === "undefined") {
                        this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    } else {
                        this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    }
                };
                MarkerLabel_.prototype.setVisible = function() {
                    if (this.marker_.get("labelVisible")) {
                        this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none";
                    } else {
                        this.labelDiv_.style.display = "none";
                    }
                    this.eventDiv_.style.display = this.labelDiv_.style.display;
                };

                function MarkerWithLabel(opt_options) {
                    opt_options = opt_options || {};
                    opt_options.labelContent = opt_options.labelContent || "";
                    opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
                    opt_options.labelClass = opt_options.labelClass || "markerLabels";
                    opt_options.labelStyle = opt_options.labelStyle || {};
                    opt_options.labelInBackground = opt_options.labelInBackground || false;
                    if (typeof opt_options.labelVisible === "undefined") {
                        opt_options.labelVisible = true;
                    }
                    if (typeof opt_options.raiseOnDrag === "undefined") {
                        opt_options.raiseOnDrag = true;
                    }
                    if (typeof opt_options.clickable === "undefined") {
                        opt_options.clickable = true;
                    }
                    if (typeof opt_options.draggable === "undefined") {
                        opt_options.draggable = false;
                    }
                    if (typeof opt_options.optimized === "undefined") {
                        opt_options.optimized = false;
                    }
                    opt_options.crossImage = opt_options.crossImage || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
                    opt_options.handCursor = opt_options.handCursor || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
                    opt_options.optimized = false;
                    this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor);
                    google.maps.Marker.apply(this, arguments);
                }
                inherits(MarkerWithLabel, google.maps.Marker);
                MarkerWithLabel.prototype.setMap = function(theMap) {
                    google.maps.Marker.prototype.setMap.apply(this, arguments);
                    this.label.setMap(theMap);
                };

                function RichMarker(opt_options) {
                    var options = opt_options || {};
                    this.ready_ = false;
                    this.dragging_ = false;
                    if (opt_options['visible'] == undefined) {
                        opt_options['visible'] = true;
                    }
                    if (opt_options['shadow'] == undefined) {
                        opt_options['shadow'] = '7px -3px 5px rgba(88,88,88,0.7)';
                    }
                    if (opt_options['anchor'] == undefined) {
                        opt_options['anchor'] = RichMarkerPosition['BOTTOM'];
                    }
                    this.setValues(options);
                }
                RichMarker.prototype = new google.maps.OverlayView();
                window['RichMarker'] = RichMarker;
                RichMarker.prototype.getVisible = function() {
                    return (this.get('visible'));
                };
                RichMarker.prototype['getVisible'] = RichMarker.prototype.getVisible;
                RichMarker.prototype.setVisible = function(visible) {
                    this.set('visible', visible);
                };
                RichMarker.prototype['setVisible'] = RichMarker.prototype.setVisible;
                RichMarker.prototype.visible_changed = function() {
                    if (this.ready_) {
                        this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';
                        this.draw();
                    }
                };
                RichMarker.prototype['visible_changed'] = RichMarker.prototype.visible_changed;
                RichMarker.prototype.setFlat = function(flat) {
                    this.set('flat', !!flat);
                };
                RichMarker.prototype['setFlat'] = RichMarker.prototype.setFlat;
                RichMarker.prototype.getFlat = function() {
                    return (this.get('flat'));
                };
                RichMarker.prototype['getFlat'] = RichMarker.prototype.getFlat;
                RichMarker.prototype.getWidth = function() {
                    return (this.get('width'));
                };
                RichMarker.prototype['getWidth'] = RichMarker.prototype.getWidth;
                RichMarker.prototype.getHeight = function() {
                    return (this.get('height'));
                };
                RichMarker.prototype['getHeight'] = RichMarker.prototype.getHeight;
                RichMarker.prototype.setShadow = function(shadow) {
                    this.set('shadow', shadow);
                    this.flat_changed();
                };
                RichMarker.prototype['setShadow'] = RichMarker.prototype.setShadow;
                RichMarker.prototype.getShadow = function() {
                    return (this.get('shadow'));
                };
                RichMarker.prototype['getShadow'] = RichMarker.prototype.getShadow;
                RichMarker.prototype.flat_changed = function() {
                    if (!this.ready_) {
                        return;
                    }
                    this.markerWrapper_.style['boxShadow'] = this.markerWrapper_.style['webkitBoxShadow'] = this.markerWrapper_.style['MozBoxShadow'] = this.getFlat() ? '' : this.getShadow();
                };
                RichMarker.prototype['flat_changed'] = RichMarker.prototype.flat_changed;
                RichMarker.prototype.setZIndex = function(index) {
                    this.set('zIndex', index);
                };
                RichMarker.prototype['setZIndex'] = RichMarker.prototype.setZIndex;
                RichMarker.prototype.getZIndex = function() {
                    return (this.get('zIndex'));
                };
                RichMarker.prototype['getZIndex'] = RichMarker.prototype.getZIndex;
                RichMarker.prototype.zIndex_changed = function() {
                    if (this.getZIndex() && this.ready_) {
                        this.markerWrapper_.style.zIndex = this.getZIndex();
                    }
                };
                RichMarker.prototype['zIndex_changed'] = RichMarker.prototype.zIndex_changed;
                RichMarker.prototype.getDraggable = function() {
                    return (this.get('draggable'));
                };
                RichMarker.prototype['getDraggable'] = RichMarker.prototype.getDraggable;
                RichMarker.prototype.setDraggable = function(draggable) {
                    this.set('draggable', !!draggable);
                };
                RichMarker.prototype['setDraggable'] = RichMarker.prototype.setDraggable;
                RichMarker.prototype.draggable_changed = function() {
                    if (this.ready_) {
                        if (this.getDraggable()) {
                            this.addDragging_(this.markerWrapper_);
                        } else {
                            this.removeDragListeners_();
                        }
                    }
                };
                RichMarker.prototype['draggable_changed'] = RichMarker.prototype.draggable_changed;
                RichMarker.prototype.getPosition = function() {
                    return (this.get('position'));
                };
                RichMarker.prototype['getPosition'] = RichMarker.prototype.getPosition;
                RichMarker.prototype.setPosition = function(position) {
                    this.set('position', position);
                };
                RichMarker.prototype['setPosition'] = RichMarker.prototype.setPosition;
                RichMarker.prototype.position_changed = function() {
                    this.draw();
                };
                RichMarker.prototype['position_changed'] = RichMarker.prototype.position_changed;
                RichMarker.prototype.getAnchor = function() {
                    return (this.get('anchor'));
                };
                RichMarker.prototype['getAnchor'] = RichMarker.prototype.getAnchor;
                RichMarker.prototype.setAnchor = function(anchor) {
                    this.set('anchor', anchor);
                };
                RichMarker.prototype['setAnchor'] = RichMarker.prototype.setAnchor;
                RichMarker.prototype.anchor_changed = function() {
                    this.draw();
                };
                RichMarker.prototype['anchor_changed'] = RichMarker.prototype.anchor_changed;
                RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
                    var tempDiv = document.createElement('DIV');
                    tempDiv.innerHTML = htmlString;
                    if (tempDiv.childNodes.length == 1) {
                        return (tempDiv.removeChild(tempDiv.firstChild));
                    } else {
                        var fragment = document.createDocumentFragment();
                        while (tempDiv.firstChild) {
                            fragment.appendChild(tempDiv.firstChild);
                        }
                        return fragment;
                    }
                };
                RichMarker.prototype.removeChildren_ = function(node) {
                    if (!node) {
                        return;
                    }
                    var child;
                    while (child = node.firstChild) {
                        node.removeChild(child);
                    }
                };
                RichMarker.prototype.setContent = function(content) {
                    this.set('content', content);
                };
                RichMarker.prototype['setContent'] = RichMarker.prototype.setContent;
                RichMarker.prototype.getContent = function() {
                    return (this.get('content'));
                };
                RichMarker.prototype['getContent'] = RichMarker.prototype.getContent;
                RichMarker.prototype.content_changed = function() {
                    if (!this.markerContent_) {
                        return;
                    }
                    this.removeChildren_(this.markerContent_);
                    var content = this.getContent();
                    if (content) {
                        if (typeof content == 'string') {
                            content = content.replace(/^\s*([\S\s]*)\b\s*$/, '$1');
                            content = this.htmlToDocumentFragment_(content);
                        }
                        this.markerContent_.appendChild(content);
                        var that = this;
                        var images = this.markerContent_.getElementsByTagName('IMG');
                        for (var i = 0, image; image = images[i]; i++) {
                            google.maps.event.addDomListener(image, 'mousedown', function(e) {
                                if (that.getDraggable()) {
                                    if (e.preventDefault) {
                                        e.preventDefault();
                                    }
                                    e.returnValue = false;
                                }
                            });
                            google.maps.event.addDomListener(image, 'load', function() {
                                that.draw();
                            });
                        }
                        google.maps.event.trigger(this, 'domready');
                    }
                    if (this.ready_) {
                        this.draw();
                    }
                };
                RichMarker.prototype['content_changed'] = RichMarker.prototype.content_changed;
                RichMarker.prototype.setCursor_ = function(whichCursor) {
                    if (!this.ready_) {
                        return;
                    }
                    var cursor = '';
                    if (navigator.userAgent.indexOf('Gecko/') !== -1) {
                        if (whichCursor == 'dragging') {
                            cursor = '-moz-grabbing';
                        }
                        if (whichCursor == 'dragready') {
                            cursor = '-moz-grab';
                        }
                        if (whichCursor == 'draggable') {
                            cursor = 'pointer';
                        }
                    } else {
                        if (whichCursor == 'dragging' || whichCursor == 'dragready') {
                            cursor = 'move';
                        }
                        if (whichCursor == 'draggable') {
                            cursor = 'pointer';
                        }
                    }
                    if (this.markerWrapper_.style.cursor != cursor) {
                        this.markerWrapper_.style.cursor = cursor;
                    }
                };
                RichMarker.prototype.startDrag = function(e) {
                    if (!this.getDraggable()) {
                        return;
                    }
                    if (!this.dragging_) {
                        this.dragging_ = true;
                        var map = this.getMap();
                        this.mapDraggable_ = map.get('draggable');
                        map.set('draggable', false);
                        this.mouseX_ = e.clientX;
                        this.mouseY_ = e.clientY;
                        this.setCursor_('dragready');
                        this.markerWrapper_.style['MozUserSelect'] = 'none';
                        this.markerWrapper_.style['KhtmlUserSelect'] = 'none';
                        this.markerWrapper_.style['WebkitUserSelect'] = 'none';
                        this.markerWrapper_['unselectable'] = 'on';
                        this.markerWrapper_['onselectstart'] = function() {
                            return false;
                        };
                        this.addDraggingListeners_();
                        google.maps.event.trigger(this, 'dragstart');
                    }
                };
                RichMarker.prototype.stopDrag = function() {
                    if (!this.getDraggable()) {
                        return;
                    }
                    if (this.dragging_) {
                        this.dragging_ = false;
                        this.getMap().set('draggable', this.mapDraggable_);
                        this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
                        this.markerWrapper_.style['MozUserSelect'] = '';
                        this.markerWrapper_.style['KhtmlUserSelect'] = '';
                        this.markerWrapper_.style['WebkitUserSelect'] = '';
                        this.markerWrapper_['unselectable'] = 'off';
                        this.markerWrapper_['onselectstart'] = function() {};
                        this.removeDraggingListeners_();
                        this.setCursor_('draggable');
                        google.maps.event.trigger(this, 'dragend');
                        this.draw();
                    }
                };
                RichMarker.prototype.drag = function(e) {
                    if (!this.getDraggable() || !this.dragging_) {
                        this.stopDrag();
                        return;
                    }
                    var dx = this.mouseX_ - e.clientX;
                    var dy = this.mouseY_ - e.clientY;
                    this.mouseX_ = e.clientX;
                    this.mouseY_ = e.clientY;
                    var left = parseInt(this.markerWrapper_.style['left'], 10) - dx;
                    var top = parseInt(this.markerWrapper_.style['top'], 10) - dy;
                    this.markerWrapper_.style['left'] = left + 'px';
                    this.markerWrapper_.style['top'] = top + 'px';
                    var offset = this.getOffset_();
                    var point = new google.maps.Point(left - offset.width, top - offset.height);
                    var projection = this.getProjection();
                    this.setPosition(projection.fromDivPixelToLatLng(point));
                    this.setCursor_('dragging');
                    google.maps.event.trigger(this, 'drag');
                };
                RichMarker.prototype.removeDragListeners_ = function() {
                    if (this.draggableListener_) {
                        google.maps.event.removeListener(this.draggableListener_);
                        delete this.draggableListener_;
                    }
                    this.setCursor_('');
                };
                RichMarker.prototype.addDragging_ = function(node) {
                    if (!node) {
                        return;
                    }
                    var that = this;
                    this.draggableListener_ = google.maps.event.addDomListener(node, 'mousedown', function(e) {
                        that.startDrag(e);
                    });
                    this.setCursor_('draggable');
                };
                RichMarker.prototype.addDraggingListeners_ = function() {
                    var that = this;
                    if (this.markerWrapper_.setCapture) {
                        this.markerWrapper_.setCapture(true);
                        this.draggingListeners_ = [google.maps.event.addDomListener(this.markerWrapper_, 'mousemove', function(e) {
                            that.drag(e);
                        }, true), google.maps.event.addDomListener(this.markerWrapper_, 'mouseup', function() {
                            that.stopDrag();
                            that.markerWrapper_.releaseCapture();
                        }, true)];
                    } else {
                        this.draggingListeners_ = [google.maps.event.addDomListener(window, 'mousemove', function(e) {
                            that.drag(e);
                        }, true), google.maps.event.addDomListener(window, 'mouseup', function() {
                            that.stopDrag();
                        }, true)];
                    }
                };
                RichMarker.prototype.removeDraggingListeners_ = function() {
                    if (this.draggingListeners_) {
                        for (var i = 0, listener; listener = this.draggingListeners_[i]; i++) {
                            google.maps.event.removeListener(listener);
                        }
                        this.draggingListeners_.length = 0;
                    }
                };
                RichMarker.prototype.getOffset_ = function() {
                    var anchor = this.getAnchor();
                    if (typeof anchor == 'object') {
                        return (anchor);
                    }
                    var offset = new google.maps.Size(0, 0);
                    if (!this.markerContent_) {
                        return offset;
                    }
                    var width = this.markerContent_.offsetWidth;
                    var height = this.markerContent_.offsetHeight;
                    switch (anchor) {
                        case RichMarkerPosition['TOP_LEFT']:
                            break;
                        case RichMarkerPosition['TOP']:
                            offset.width = -width / 2;
                            break;
                        case RichMarkerPosition['TOP_RIGHT']:
                            offset.width = -width;
                            break;
                        case RichMarkerPosition['LEFT']:
                            offset.height = -height / 2;
                            break;
                        case RichMarkerPosition['MIDDLE']:
                            offset.width = -width / 2;
                            offset.height = -height / 2;
                            break;
                        case RichMarkerPosition['RIGHT']:
                            offset.width = -width;
                            offset.height = -height / 2;
                            break;
                        case RichMarkerPosition['BOTTOM_LEFT']:
                            offset.height = -height;
                            break;
                        case RichMarkerPosition['BOTTOM']:
                            offset.width = -width / 2;
                            offset.height = -height;
                            break;
                        case RichMarkerPosition['BOTTOM_RIGHT']:
                            offset.width = -width;
                            offset.height = -height;
                            break;
                    }
                    return offset;
                };
                RichMarker.prototype.onAdd = function() {
                    if (!this.markerWrapper_) {
                        this.markerWrapper_ = document.createElement('DIV');
                        this.markerWrapper_.style['position'] = 'absolute';
                    }
                    if (this.getZIndex()) {
                        this.markerWrapper_.style['zIndex'] = this.getZIndex();
                    }
                    this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';
                    if (!this.markerContent_) {
                        this.markerContent_ = document.createElement('DIV');
                        this.markerWrapper_.appendChild(this.markerContent_);
                        var that = this;
                        google.maps.event.addDomListener(this.markerContent_, 'click', function(e) {
                            google.maps.event.trigger(that, 'click');
                        });
                        google.maps.event.addDomListener(this.markerContent_, 'mouseover', function(e) {
                            google.maps.event.trigger(that, 'mouseover');
                        });
                        google.maps.event.addDomListener(this.markerContent_, 'mouseout', function(e) {
                            google.maps.event.trigger(that, 'mouseout');
                        });
                    }
                    this.ready_ = true;
                    this.content_changed();
                    this.flat_changed();
                    this.draggable_changed();
                    var panes = this.getPanes();
                    if (panes) {
                        panes.overlayMouseTarget.appendChild(this.markerWrapper_);
                    }
                    google.maps.event.trigger(this, 'ready');
                };
                RichMarker.prototype['onAdd'] = RichMarker.prototype.onAdd;
                RichMarker.prototype.draw = function() {
                    if (!this.ready_ || this.dragging_) {
                        return;
                    }
                    var projection = this.getProjection();
                    if (!projection) {
                        return;
                    }
                    var latLng = (this.get('position'));
                    var pos = projection.fromLatLngToDivPixel(latLng);
                    var offset = this.getOffset_();
                    this.markerWrapper_.style['top'] = (pos.y + offset.height) + 'px';
                    this.markerWrapper_.style['left'] = (pos.x + offset.width) + 'px';
                    var height = this.markerContent_.offsetHeight;
                    var width = this.markerContent_.offsetWidth;
                    if (width != this.get('width')) {
                        this.set('width', width);
                    }
                    if (height != this.get('height')) {
                        this.set('height', height);
                    }
                };
                RichMarker.prototype['draw'] = RichMarker.prototype.draw;
                RichMarker.prototype.onRemove = function() {
                    if (this.markerWrapper_ && this.markerWrapper_.parentNode) {
                        this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
                    }
                    this.removeDragListeners_();
                };
                RichMarker.prototype['onRemove'] = RichMarker.prototype.onRemove;
                var RichMarkerPosition = {
                    'TOP_LEFT': 1,
                    'TOP': 2,
                    'TOP_RIGHT': 3,
                    'LEFT': 4,
                    'MIDDLE': 5,
                    'RIGHT': 6,
                    'BOTTOM_LEFT': 7,
                    'BOTTOM': 8,
                    'BOTTOM_RIGHT': 9
                };
                window['RichMarkerPosition'] = RichMarkerPosition;
                window.InfoBox = InfoBox;
                window.Cluster = Cluster;
                window.ClusterIcon = ClusterIcon;
                window.MarkerClusterer = MarkerClusterer;
                window.MarkerLabel_ = MarkerLabel_;
                window.MarkerWithLabel = MarkerWithLabel;
                window.RichMarker = RichMarker;
            })
        };
    });;
    (function(modules) {
        var installedModules = {};

        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: false
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.loaded = true;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
    })([function(module, exports, __webpack_require__) {
        angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapDataStructures', function() {
            return {
                Graph: __webpack_require__(1).Graph,
                Queue: __webpack_require__(1).Queue
            };
        });
    }, function(module, exports, __webpack_require__) {
        (function() {
            module.exports = {
                Graph: __webpack_require__(2),
                Heap: __webpack_require__(3),
                LinkedList: __webpack_require__(4),
                Map: __webpack_require__(5),
                Queue: __webpack_require__(6),
                RedBlackTree: __webpack_require__(7),
                Trie: __webpack_require__(8)
            };
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Graph, __hasProp = {}.hasOwnProperty;
            Graph = (function() {
                function Graph() {
                    this._nodes = {};
                    this.nodeSize = 0;
                    this.edgeSize = 0;
                }
                Graph.prototype.addNode = function(id) {
                    if (!this._nodes[id]) {
                        this.nodeSize++;
                        return this._nodes[id] = {
                            _outEdges: {},
                            _inEdges: {}
                        };
                    }
                };
                Graph.prototype.getNode = function(id) {
                    return this._nodes[id];
                };
                Graph.prototype.removeNode = function(id) {
                    var inEdgeId, nodeToRemove, outEdgeId, _ref, _ref1;
                    nodeToRemove = this._nodes[id];
                    if (!nodeToRemove) {
                        return;
                    } else {
                        _ref = nodeToRemove._outEdges;
                        for (outEdgeId in _ref) {
                            if (!__hasProp.call(_ref, outEdgeId)) continue;
                            this.removeEdge(id, outEdgeId);
                        }
                        _ref1 = nodeToRemove._inEdges;
                        for (inEdgeId in _ref1) {
                            if (!__hasProp.call(_ref1, inEdgeId)) continue;
                            this.removeEdge(inEdgeId, id);
                        }
                        this.nodeSize--;
                        delete this._nodes[id];
                    }
                    return nodeToRemove;
                };
                Graph.prototype.addEdge = function(fromId, toId, weight) {
                    var edgeToAdd, fromNode, toNode;
                    if (weight == null) {
                        weight = 1;
                    }
                    if (this.getEdge(fromId, toId)) {
                        return;
                    }
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    if (!fromNode || !toNode) {
                        return;
                    }
                    edgeToAdd = {
                        weight: weight
                    };
                    fromNode._outEdges[toId] = edgeToAdd;
                    toNode._inEdges[fromId] = edgeToAdd;
                    this.edgeSize++;
                    return edgeToAdd;
                };
                Graph.prototype.getEdge = function(fromId, toId) {
                    var fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    if (!fromNode || !toNode) {} else {
                        return fromNode._outEdges[toId];
                    }
                };
                Graph.prototype.removeEdge = function(fromId, toId) {
                    var edgeToDelete, fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    edgeToDelete = this.getEdge(fromId, toId);
                    if (!edgeToDelete) {
                        return;
                    }
                    delete fromNode._outEdges[toId];
                    delete toNode._inEdges[fromId];
                    this.edgeSize--;
                    return edgeToDelete;
                };
                Graph.prototype.getInEdgesOf = function(nodeId) {
                    var fromId, inEdges, toNode, _ref;
                    toNode = this._nodes[nodeId];
                    inEdges = [];
                    _ref = toNode != null ? toNode._inEdges : void 0;
                    for (fromId in _ref) {
                        if (!__hasProp.call(_ref, fromId)) continue;
                        inEdges.push(this.getEdge(fromId, nodeId));
                    }
                    return inEdges;
                };
                Graph.prototype.getOutEdgesOf = function(nodeId) {
                    var fromNode, outEdges, toId, _ref;
                    fromNode = this._nodes[nodeId];
                    outEdges = [];
                    _ref = fromNode != null ? fromNode._outEdges : void 0;
                    for (toId in _ref) {
                        if (!__hasProp.call(_ref, toId)) continue;
                        outEdges.push(this.getEdge(nodeId, toId));
                    }
                    return outEdges;
                };
                Graph.prototype.getAllEdgesOf = function(nodeId) {
                    var i, inEdges, outEdges, selfEdge, _i, _ref, _ref1;
                    inEdges = this.getInEdgesOf(nodeId);
                    outEdges = this.getOutEdgesOf(nodeId);
                    if (inEdges.length === 0) {
                        return outEdges;
                    }
                    selfEdge = this.getEdge(nodeId, nodeId);
                    for (i = _i = 0, _ref = inEdges.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                        if (inEdges[i] === selfEdge) {
                            _ref1 = [inEdges[inEdges.length - 1], inEdges[i]], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
                            inEdges.pop();
                            break;
                        }
                    }
                    return inEdges.concat(outEdges);
                };
                Graph.prototype.forEachNode = function(operation) {
                    var nodeId, nodeObject, _ref;
                    _ref = this._nodes;
                    for (nodeId in _ref) {
                        if (!__hasProp.call(_ref, nodeId)) continue;
                        nodeObject = _ref[nodeId];
                        operation(nodeObject, nodeId);
                    }
                };
                Graph.prototype.forEachEdge = function(operation) {
                    var edgeObject, nodeId, nodeObject, toId, _ref, _ref1;
                    _ref = this._nodes;
                    for (nodeId in _ref) {
                        if (!__hasProp.call(_ref, nodeId)) continue;
                        nodeObject = _ref[nodeId];
                        _ref1 = nodeObject._outEdges;
                        for (toId in _ref1) {
                            if (!__hasProp.call(_ref1, toId)) continue;
                            edgeObject = _ref1[toId];
                            operation(edgeObject);
                        }
                    }
                };
                return Graph;
            })();
            module.exports = Graph;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Heap, _leftChild, _parent, _rightChild;
            Heap = (function() {
                function Heap(dataToHeapify) {
                    var i, item, _i, _j, _len, _ref;
                    if (dataToHeapify == null) {
                        dataToHeapify = [];
                    }
                    this._data = [void 0];
                    for (_i = 0, _len = dataToHeapify.length; _i < _len; _i++) {
                        item = dataToHeapify[_i];
                        if (item != null) {
                            this._data.push(item);
                        }
                    }
                    if (this._data.length > 1) {
                        for (i = _j = 2, _ref = this._data.length; 2 <= _ref ? _j < _ref : _j > _ref; i = 2 <= _ref ? ++_j : --_j) {
                            this._upHeap(i);
                        }
                    }
                    this.size = this._data.length - 1;
                }
                Heap.prototype.add = function(value) {
                    if (value == null) {
                        return;
                    }
                    this._data.push(value);
                    this._upHeap(this._data.length - 1);
                    this.size++;
                    return value;
                };
                Heap.prototype.removeMin = function() {
                    var min;
                    if (this._data.length === 1) {
                        return;
                    }
                    this.size--;
                    if (this._data.length === 2) {
                        return this._data.pop();
                    }
                    min = this._data[1];
                    this._data[1] = this._data.pop();
                    this._downHeap();
                    return min;
                };
                Heap.prototype.peekMin = function() {
                    return this._data[1];
                };
                Heap.prototype._upHeap = function(index) {
                    var valueHolder, _ref;
                    valueHolder = this._data[index];
                    while (this._data[index] < this._data[_parent(index)] && index > 1) {
                        _ref = [this._data[_parent(index)], this._data[index]], this._data[index] = _ref[0], this._data[_parent(index)] = _ref[1];
                        index = _parent(index);
                    }
                };
                Heap.prototype._downHeap = function() {
                    var currentIndex, smallerChildIndex, _ref;
                    currentIndex = 1;
                    while (_leftChild(currentIndex < this._data.length)) {
                        smallerChildIndex = _leftChild(currentIndex);
                        if (smallerChildIndex < this._data.length - 1) {
                            if (this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex]) {
                                smallerChildIndex = _rightChild(currentIndex);
                            }
                        }
                        if (this._data[smallerChildIndex] < this._data[currentIndex]) {
                            _ref = [this._data[currentIndex], this._data[smallerChildIndex]], this._data[smallerChildIndex] = _ref[0], this._data[currentIndex] = _ref[1];
                            currentIndex = smallerChildIndex;
                        } else {
                            break;
                        }
                    }
                };
                return Heap;
            })();
            _parent = function(index) {
                return index >> 1;
            };
            _leftChild = function(index) {
                return index << 1;
            };
            _rightChild = function(index) {
                return (index << 1) + 1;
            };
            module.exports = Heap;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var LinkedList;
            LinkedList = (function() {
                function LinkedList(valuesToAdd) {
                    var value, _i, _len;
                    if (valuesToAdd == null) {
                        valuesToAdd = [];
                    }
                    this.head = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.tail = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
                        value = valuesToAdd[_i];
                        this.add(value);
                    }
                }
                LinkedList.prototype.at = function(position) {
                    var currentNode, i, _i, _j, _ref;
                    if (!((-this.size <= position && position < this.size))) {
                        return;
                    }
                    position = this._adjust(position);
                    if (position * 2 < this.size) {
                        currentNode = this.head;
                        for (i = _i = 1; _i <= position; i = _i += 1) {
                            currentNode = currentNode.next;
                        }
                    } else {
                        currentNode = this.tail;
                        for (i = _j = 1, _ref = this.size - position - 1; _j <= _ref; i = _j += 1) {
                            currentNode = currentNode.prev;
                        }
                    }
                    return currentNode;
                };
                LinkedList.prototype.add = function(value, position) {
                    var currentNode, nodeToAdd, _ref, _ref1, _ref2;
                    if (position == null) {
                        position = this.size;
                    }
                    if (!((-this.size <= position && position <= this.size))) {
                        return;
                    }
                    nodeToAdd = {
                        value: value
                    };
                    position = this._adjust(position);
                    if (this.size === 0) {
                        this.head = nodeToAdd;
                    } else {
                        if (position === 0) {
                            _ref = [nodeToAdd, this.head, nodeToAdd], this.head.prev = _ref[0], nodeToAdd.next = _ref[1], this.head = _ref[2];
                        } else {
                            currentNode = this.at(position - 1);
                            _ref1 = [currentNode.next, nodeToAdd, nodeToAdd, currentNode], nodeToAdd.next = _ref1[0], (_ref2 = currentNode.next) != null ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], nodeToAdd.prev = _ref1[3];
                        }
                    }
                    if (position === this.size) {
                        this.tail = nodeToAdd;
                    }
                    this.size++;
                    return value;
                };
                LinkedList.prototype.removeAt = function(position) {
                    var currentNode, valueToReturn, _ref;
                    if (position == null) {
                        position = this.size - 1;
                    }
                    if (!((-this.size <= position && position < this.size))) {
                        return;
                    }
                    if (this.size === 0) {
                        return;
                    }
                    position = this._adjust(position);
                    if (this.size === 1) {
                        valueToReturn = this.head.value;
                        this.head.value = this.tail.value = void 0;
                    } else {
                        if (position === 0) {
                            valueToReturn = this.head.value;
                            this.head = this.head.next;
                            this.head.prev = void 0;
                        } else {
                            currentNode = this.at(position);
                            valueToReturn = currentNode.value;
                            currentNode.prev.next = currentNode.next;
                            if ((_ref = currentNode.next) != null) {
                                _ref.prev = currentNode.prev;
                            }
                            if (position === this.size - 1) {
                                this.tail = currentNode.prev;
                            }
                        }
                    }
                    this.size--;
                    return valueToReturn;
                };
                LinkedList.prototype.remove = function(value) {
                    var currentNode;
                    if (value == null) {
                        return;
                    }
                    currentNode = this.head;
                    while (currentNode && currentNode.value !== value) {
                        currentNode = currentNode.next;
                    }
                    if (!currentNode) {
                        return;
                    }
                    if (this.size === 1) {
                        this.head.value = this.tail.value = void 0;
                    } else if (currentNode === this.head) {
                        this.head = this.head.next;
                        this.head.prev = void 0;
                    } else if (currentNode === this.tail) {
                        this.tail = this.tail.prev;
                        this.tail.next = void 0;
                    } else {
                        currentNode.prev.next = currentNode.next;
                        currentNode.next.prev = currentNode.prev;
                    }
                    this.size--;
                    return value;
                };
                LinkedList.prototype.indexOf = function(value, startingPosition) {
                    var currentNode, position;
                    if (startingPosition == null) {
                        startingPosition = 0;
                    }
                    if (((this.head.value == null) && !this.head.next) || startingPosition >= this.size) {
                        return -1;
                    }
                    startingPosition = Math.max(0, this._adjust(startingPosition));
                    currentNode = this.at(startingPosition);
                    position = startingPosition;
                    while (currentNode) {
                        if (currentNode.value === value) {
                            break;
                        }
                        currentNode = currentNode.next;
                        position++;
                    }
                    if (position === this.size) {
                        return -1;
                    } else {
                        return position;
                    }
                };
                LinkedList.prototype._adjust = function(position) {
                    if (position < 0) {
                        return this.size + position;
                    } else {
                        return position;
                    }
                };
                return LinkedList;
            })();
            module.exports = LinkedList;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Map, SPECIAL_TYPE_KEY_PREFIX, _extractDataType, _isSpecialType, __hasProp = {}.hasOwnProperty;
            SPECIAL_TYPE_KEY_PREFIX = '_mapId_';
            Map = (function() {
                Map._mapIdTracker = 0;
                Map._newMapId = function() {
                    return this._mapIdTracker++;
                };

                function Map(objectToMap) {
                    var key, value;
                    this._content = {};
                    this._itemId = 0;
                    this._id = Map._newMapId();
                    this.size = 0;
                    for (key in objectToMap) {
                        if (!__hasProp.call(objectToMap, key)) continue;
                        value = objectToMap[key];
                        this.set(key, value);
                    }
                }
                Map.prototype.hash = function(key, makeHash) {
                    var propertyForMap, type;
                    if (makeHash == null) {
                        makeHash = false;
                    }
                    type = _extractDataType(key);
                    if (_isSpecialType(key)) {
                        propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
                        if (makeHash && !key[propertyForMap]) {
                            key[propertyForMap] = this._itemId++;
                        }
                        return propertyForMap + '_' + key[propertyForMap];
                    } else {
                        return type + '_' + key;
                    }
                };
                Map.prototype.set = function(key, value) {
                    if (!this.has(key)) {
                        this.size++;
                    }
                    this._content[this.hash(key, true)] = [value, key];
                    return value;
                };
                Map.prototype.get = function(key) {
                    var _ref;
                    return (_ref = this._content[this.hash(key)]) != null ? _ref[0] : void 0;
                };
                Map.prototype.has = function(key) {
                    return this.hash(key) in this._content;
                };
                Map.prototype["delete"] = function(key) {
                    var hashedKey;
                    hashedKey = this.hash(key);
                    if (hashedKey in this._content) {
                        delete this._content[hashedKey];
                        if (_isSpecialType(key)) {
                            delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
                        }
                        this.size--;
                        return true;
                    }
                    return false;
                };
                Map.prototype.forEach = function(operation) {
                    var key, value, _ref;
                    _ref = this._content;
                    for (key in _ref) {
                        if (!__hasProp.call(_ref, key)) continue;
                        value = _ref[key];
                        operation(value[1], value[0]);
                    }
                };
                return Map;
            })();
            _isSpecialType = function(key) {
                var simpleHashableTypes, simpleType, type, _i, _len;
                simpleHashableTypes = ['Boolean', 'Number', 'String', 'Undefined', 'Null', 'RegExp', 'Function'];
                type = _extractDataType(key);
                for (_i = 0, _len = simpleHashableTypes.length; _i < _len; _i++) {
                    simpleType = simpleHashableTypes[_i];
                    if (type === simpleType) {
                        return false;
                    }
                }
                return true;
            };
            _extractDataType = function(type) {
                return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
            };
            module.exports = Map;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var Queue;
            Queue = (function() {
                function Queue(initialArray) {
                    if (initialArray == null) {
                        initialArray = [];
                    }
                    this._content = initialArray;
                    this._dequeueIndex = 0;
                    this.size = this._content.length;
                }
                Queue.prototype.enqueue = function(item) {
                    this.size++;
                    this._content.push(item);
                    return item;
                };
                Queue.prototype.dequeue = function() {
                    var itemToDequeue;
                    if (this.size === 0) {
                        return;
                    }
                    this.size--;
                    itemToDequeue = this._content[this._dequeueIndex];
                    this._dequeueIndex++;
                    if (this._dequeueIndex * 2 > this._content.length) {
                        this._content = this._content.slice(this._dequeueIndex);
                        this._dequeueIndex = 0;
                    }
                    return itemToDequeue;
                };
                Queue.prototype.peek = function() {
                    return this._content[this._dequeueIndex];
                };
                return Queue;
            })();
            module.exports = Queue;
        }).call(this);
    }, function(module, exports) {
        (function() {
            var BLACK, NODE_FOUND, NODE_TOO_BIG, NODE_TOO_SMALL, RED, RedBlackTree, STOP_SEARCHING, _findNode, _grandParentOf, _isLeft, _leftOrRight, _peekMaxNode, _peekMinNode, _siblingOf, _uncleOf;
            NODE_FOUND = 0;
            NODE_TOO_BIG = 1;
            NODE_TOO_SMALL = 2;
            STOP_SEARCHING = 3;
            RED = 1;
            BLACK = 2;
            RedBlackTree = (function() {
                function RedBlackTree(valuesToAdd) {
                    var value, _i, _len;
                    if (valuesToAdd == null) {
                        valuesToAdd = [];
                    }
                    this._root;
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
                        value = valuesToAdd[_i];
                        if (value != null) {
                            this.add(value);
                        }
                    }
                }
                RedBlackTree.prototype.add = function(value) {
                    var currentNode, foundNode, nodeToInsert, _ref;
                    if (value == null) {
                        return;
                    }
                    this.size++;
                    nodeToInsert = {
                        value: value,
                        _color: RED
                    };
                    if (!this._root) {
                        this._root = nodeToInsert;
                    } else {
                        foundNode = _findNode(this._root, function(node) {
                            if (value === node.value) {
                                return NODE_FOUND;
                            } else {
                                if (value < node.value) {
                                    if (node._left) {
                                        return NODE_TOO_BIG;
                                    } else {
                                        nodeToInsert._parent = node;
                                        node._left = nodeToInsert;
                                        return STOP_SEARCHING;
                                    }
                                } else {
                                    if (node._right) {
                                        return NODE_TOO_SMALL;
                                    } else {
                                        nodeToInsert._parent = node;
                                        node._right = nodeToInsert;
                                        return STOP_SEARCHING;
                                    }
                                }
                            }
                        });
                        if (foundNode != null) {
                            return;
                        }
                    }
                    currentNode = nodeToInsert;
                    while (true) {
                        if (currentNode === this._root) {
                            currentNode._color = BLACK;
                            break;
                        }
                        if (currentNode._parent._color === BLACK) {
                            break;
                        }
                        if (((_ref = _uncleOf(currentNode)) != null ? _ref._color : void 0) === RED) {
                            currentNode._parent._color = BLACK;
                            _uncleOf(currentNode)._color = BLACK;
                            _grandParentOf(currentNode)._color = RED;
                            currentNode = _grandParentOf(currentNode);
                            continue;
                        }
                        if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
                            this._rotateLeft(currentNode._parent);
                            currentNode = currentNode._left;
                        } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
                            this._rotateRight(currentNode._parent);
                            currentNode = currentNode._right;
                        }
                        currentNode._parent._color = BLACK;
                        _grandParentOf(currentNode)._color = RED;
                        if (_isLeft(currentNode)) {
                            this._rotateRight(_grandParentOf(currentNode));
                        } else {
                            this._rotateLeft(_grandParentOf(currentNode));
                        }
                        break;
                    }
                    return value;
                };
                RedBlackTree.prototype.has = function(value) {
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        if (value === node.value) {
                            return NODE_FOUND;
                        } else if (value < node.value) {
                            return NODE_TOO_BIG;
                        } else {
                            return NODE_TOO_SMALL;
                        }
                    });
                    if (foundNode) {
                        return true;
                    } else {
                        return false;
                    }
                };
                RedBlackTree.prototype.peekMin = function() {
                    var _ref;
                    return (_ref = _peekMinNode(this._root)) != null ? _ref.value : void 0;
                };
                RedBlackTree.prototype.peekMax = function() {
                    var _ref;
                    return (_ref = _peekMaxNode(this._root)) != null ? _ref.value : void 0;
                };
                RedBlackTree.prototype.remove = function(value) {
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        if (value === node.value) {
                            return NODE_FOUND;
                        } else if (value < node.value) {
                            return NODE_TOO_BIG;
                        } else {
                            return NODE_TOO_SMALL;
                        }
                    });
                    if (!foundNode) {
                        return;
                    }
                    this._removeNode(this._root, foundNode);
                    this.size--;
                    return value;
                };
                RedBlackTree.prototype.removeMin = function() {
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMinNode(this._root);
                    if (!nodeToRemove) {
                        return;
                    }
                    valueToReturn = nodeToRemove.value;
                    this._removeNode(this._root, nodeToRemove);
                    return valueToReturn;
                };
                RedBlackTree.prototype.removeMax = function() {
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMaxNode(this._root);
                    if (!nodeToRemove) {
                        return;
                    }
                    valueToReturn = nodeToRemove.value;
                    this._removeNode(this._root, nodeToRemove);
                    return valueToReturn;
                };
                RedBlackTree.prototype._removeNode = function(root, node) {
                    var sibling, successor, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                    if (node._left && node._right) {
                        successor = _peekMinNode(node._right);
                        node.value = successor.value;
                        node = successor;
                    }
                    successor = node._left || node._right;
                    if (!successor) {
                        successor = {
                            color: BLACK,
                            _right: void 0,
                            _left: void 0,
                            isLeaf: true
                        };
                    }
                    successor._parent = node._parent;
                    if ((_ref = node._parent) != null) {
                        _ref[_leftOrRight(node)] = successor;
                    }
                    if (node._color === BLACK) {
                        if (successor._color === RED) {
                            successor._color = BLACK;
                            if (!successor._parent) {
                                this._root = successor;
                            }
                        } else {
                            while (true) {
                                if (!successor._parent) {
                                    if (!successor.isLeaf) {
                                        this._root = successor;
                                    } else {
                                        this._root = void 0;
                                    }
                                    break;
                                }
                                sibling = _siblingOf(successor);
                                if ((sibling != null ? sibling._color : void 0) === RED) {
                                    successor._parent._color = RED;
                                    sibling._color = BLACK;
                                    if (_isLeft(successor)) {
                                        this._rotateLeft(successor._parent);
                                    } else {
                                        this._rotateRight(successor._parent);
                                    }
                                }
                                sibling = _siblingOf(successor);
                                if (successor._parent._color === BLACK && (!sibling || (sibling._color === BLACK && (!sibling._left || sibling._left._color === BLACK) && (!sibling._right || sibling._right._color === BLACK)))) {
                                    if (sibling != null) {
                                        sibling._color = RED;
                                    }
                                    if (successor.isLeaf) {
                                        successor._parent[_leftOrRight(successor)] = void 0;
                                    }
                                    successor = successor._parent;
                                    continue;
                                }
                                if (successor._parent._color === RED && (!sibling || (sibling._color === BLACK && (!sibling._left || ((_ref1 = sibling._left) != null ? _ref1._color : void 0) === BLACK) && (!sibling._right || ((_ref2 = sibling._right) != null ? _ref2._color : void 0) === BLACK)))) {
                                    if (sibling != null) {
                                        sibling._color = RED;
                                    }
                                    successor._parent._color = BLACK;
                                    break;
                                }
                                if ((sibling != null ? sibling._color : void 0) === BLACK) {
                                    if (_isLeft(successor) && (!sibling._right || sibling._right._color === BLACK) && ((_ref3 = sibling._left) != null ? _ref3._color : void 0) === RED) {
                                        sibling._color = RED;
                                        if ((_ref4 = sibling._left) != null) {
                                            _ref4._color = BLACK;
                                        }
                                        this._rotateRight(sibling);
                                    } else if (!_isLeft(successor) && (!sibling._left || sibling._left._color === BLACK) && ((_ref5 = sibling._right) != null ? _ref5._color : void 0) === RED) {
                                        sibling._color = RED;
                                        if ((_ref6 = sibling._right) != null) {
                                            _ref6._color = BLACK;
                                        }
                                        this._rotateLeft(sibling);
                                    }
                                    break;
                                }
                                sibling = _siblingOf(successor);
                                sibling._color = successor._parent._color;
                                if (_isLeft(successor)) {
                                    sibling._right._color = BLACK;
                                    this._rotateRight(successor._parent);
                                } else {
                                    sibling._left._color = BLACK;
                                    this._rotateLeft(successor._parent);
                                }
                            }
                        }
                    }
                    if (successor.isLeaf) {
                        return (_ref7 = successor._parent) != null ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
                    }
                };
                RedBlackTree.prototype._rotateLeft = function(node) {
                    var _ref, _ref1;
                    if ((_ref = node._parent) != null) {
                        _ref[_leftOrRight(node)] = node._right;
                    }
                    node._right._parent = node._parent;
                    node._parent = node._right;
                    node._right = node._right._left;
                    node._parent._left = node;
                    if ((_ref1 = node._right) != null) {
                        _ref1._parent = node;
                    }
                    if (node._parent._parent == null) {
                        return this._root = node._parent;
                    }
                };
                RedBlackTree.prototype._rotateRight = function(node) {
                    var _ref, _ref1;
                    if ((_ref = node._parent) != null) {
                        _ref[_leftOrRight(node)] = node._left;
                    }
                    node._left._parent = node._parent;
                    node._parent = node._left;
                    node._left = node._left._right;
                    node._parent._right = node;
                    if ((_ref1 = node._left) != null) {
                        _ref1._parent = node;
                    }
                    if (node._parent._parent == null) {
                        return this._root = node._parent;
                    }
                };
                return RedBlackTree;
            })();
            _isLeft = function(node) {
                return node === node._parent._left;
            };
            _leftOrRight = function(node) {
                if (_isLeft(node)) {
                    return '_left';
                } else {
                    return '_right';
                }
            };
            _findNode = function(startingNode, comparator) {
                var comparisonResult, currentNode, foundNode;
                currentNode = startingNode;
                foundNode = void 0;
                while (currentNode) {
                    comparisonResult = comparator(currentNode);
                    if (comparisonResult === NODE_FOUND) {
                        foundNode = currentNode;
                        break;
                    }
                    if (comparisonResult === NODE_TOO_BIG) {
                        currentNode = currentNode._left;
                    } else if (comparisonResult === NODE_TOO_SMALL) {
                        currentNode = currentNode._right;
                    } else if (comparisonResult === STOP_SEARCHING) {
                        break;
                    }
                }
                return foundNode;
            };
            _peekMinNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    if (node._left) {
                        return NODE_TOO_BIG;
                    } else {
                        return NODE_FOUND;
                    }
                });
            };
            _peekMaxNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    if (node._right) {
                        return NODE_TOO_SMALL;
                    } else {
                        return NODE_FOUND;
                    }
                });
            };
            _grandParentOf = function(node) {
                var _ref;
                return (_ref = node._parent) != null ? _ref._parent : void 0;
            };
            _uncleOf = function(node) {
                if (!_grandParentOf(node)) {
                    return;
                }
                if (_isLeft(node._parent)) {
                    return _grandParentOf(node)._right;
                } else {
                    return _grandParentOf(node)._left;
                }
            };
            _siblingOf = function(node) {
                if (_isLeft(node)) {
                    return node._parent._right;
                } else {
                    return node._parent._left;
                }
            };
            module.exports = RedBlackTree;
        }).call(this);
    }, function(module, exports, __webpack_require__) {
        (function() {
            var Queue, Trie, WORD_END, _hasAtLeastNChildren, __hasProp = {}.hasOwnProperty;
            Queue = __webpack_require__(6);
            WORD_END = 'end';
            Trie = (function() {
                function Trie(words) {
                    var word, _i, _len;
                    if (words == null) {
                        words = [];
                    }
                    this._root = {};
                    this.size = 0;
                    for (_i = 0, _len = words.length; _i < _len; _i++) {
                        word = words[_i];
                        this.add(word);
                    }
                }
                Trie.prototype.add = function(word) {
                    var currentNode, letter, _i, _len;
                    if (word == null) {
                        return;
                    }
                    this.size++;
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            currentNode[letter] = {};
                        }
                        currentNode = currentNode[letter];
                    }
                    currentNode[WORD_END] = true;
                    return word;
                };
                Trie.prototype.has = function(word) {
                    var currentNode, letter, _i, _len;
                    if (word == null) {
                        return false;
                    }
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            return false;
                        }
                        currentNode = currentNode[letter];
                    }
                    if (currentNode[WORD_END]) {
                        return true;
                    } else {
                        return false;
                    }
                };
                Trie.prototype.longestPrefixOf = function(word) {
                    var currentNode, letter, prefix, _i, _len;
                    if (word == null) {
                        return '';
                    }
                    currentNode = this._root;
                    prefix = '';
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            break;
                        }
                        prefix += letter;
                        currentNode = currentNode[letter];
                    }
                    return prefix;
                };
                Trie.prototype.wordsWithPrefix = function(prefix) {
                    var accumulatedLetters, currentNode, letter, node, queue, subNode, words, _i, _len, _ref;
                    if (prefix == null) {
                        return [];
                    }(prefix != null) || (prefix = '');
                    words = [];
                    currentNode = this._root;
                    for (_i = 0, _len = prefix.length; _i < _len; _i++) {
                        letter = prefix[_i];
                        currentNode = currentNode[letter];
                        if (currentNode == null) {
                            return [];
                        }
                    }
                    queue = new Queue();
                    queue.enqueue([currentNode, '']);
                    while (queue.size !== 0) {
                        _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
                        if (node[WORD_END]) {
                            words.push(prefix + accumulatedLetters);
                        }
                        for (letter in node) {
                            if (!__hasProp.call(node, letter)) continue;
                            subNode = node[letter];
                            queue.enqueue([subNode, accumulatedLetters + letter]);
                        }
                    }
                    return words;
                };
                Trie.prototype.remove = function(word) {
                    var currentNode, i, letter, prefix, _i, _j, _len, _ref;
                    if (word == null) {
                        return;
                    }
                    currentNode = this._root;
                    prefix = [];
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (currentNode[letter] == null) {
                            return;
                        }
                        currentNode = currentNode[letter];
                        prefix.push([letter, currentNode]);
                    }
                    if (!currentNode[WORD_END]) {
                        return;
                    }
                    this.size--;
                    delete currentNode[WORD_END];
                    if (_hasAtLeastNChildren(currentNode, 1)) {
                        return word;
                    }
                    for (i = _j = _ref = prefix.length - 1; _ref <= 1 ? _j <= 1 : _j >= 1; i = _ref <= 1 ? ++_j : --_j) {
                        if (!_hasAtLeastNChildren(prefix[i][1], 1)) {
                            delete prefix[i - 1][1][prefix[i][0]];
                        } else {
                            break;
                        }
                    }
                    if (!_hasAtLeastNChildren(this._root[prefix[0][0]], 1)) {
                        delete this._root[prefix[0][0]];
                    }
                    return word;
                };
                return Trie;
            })();
            _hasAtLeastNChildren = function(node, n) {
                var child, childCount;
                if (n === 0) {
                    return true;
                }
                childCount = 0;
                for (child in node) {
                    if (!__hasProp.call(node, child)) continue;
                    childCount++;
                    if (childCount >= n) {
                        return true;
                    }
                }
                return false;
            };
            module.exports = Trie;
        }).call(this);
    }]);;
    angular.module('uiGmapgoogle-maps.wrapped').service('uiGmapMarkerSpiderfier', ['uiGmapGoogleMapApi', function(GoogleMapApi) {
        var self = this;
        var hasProp = {}.hasOwnProperty,
            slice = [].slice;
        this['OverlappingMarkerSpiderfier'] = (function() {
            var ge, gm, j, lcH, lcU, len, mt, p, ref, twoPi, x;
            p = _Class.prototype;
            ref = [_Class, p];
            for (j = 0, len = ref.length; j < len; j++) {
                x = ref[j];
                x['VERSION'] = '0.3.3';
            }
            gm = void 0;
            ge = void 0;
            mt = void 0;
            twoPi = Math.PI * 2;
            p['keepSpiderfied'] = false;
            p['markersWontHide'] = false;
            p['markersWontMove'] = false;
            p['nearbyDistance'] = 20;
            p['circleSpiralSwitchover'] = 9;
            p['circleFootSeparation'] = 23;
            p['circleStartAngle'] = twoPi / 12;
            p['spiralFootSeparation'] = 26;
            p['spiralLengthStart'] = 11;
            p['spiralLengthFactor'] = 4;
            p['spiderfiedZIndex'] = 1000;
            p['usualLegZIndex'] = 10;
            p['highlightedLegZIndex'] = 20;
            p['event'] = 'click';
            p['minZoomLevel'] = false;
            p['legWeight'] = 1.5;
            p['legColors'] = {
                'usual': {},
                'highlighted': {}
            };
            lcU = p['legColors']['usual'];
            lcH = p['legColors']['highlighted'];
            _Class['initializeGoogleMaps'] = function(google) {
                gm = google.maps;
                ge = gm.event;
                mt = gm.MapTypeId;
                lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';
                lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';
                lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';
                lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';
                this.ProjHelper = function(map) {
                    return this.setMap(map);
                };
                this.ProjHelper.prototype = new gm.OverlayView();
                return this.ProjHelper.prototype['draw'] = function() {};
            };

            function _Class(map1, opts) {
                var e, k, l, len1, ref1, v;
                this.map = map1;
                if (opts == null) {
                    opts = {};
                }
                for (k in opts) {
                    if (!hasProp.call(opts, k)) continue;
                    v = opts[k];
                    this[k] = v;
                }
                this.projHelper = new this.constructor.ProjHelper(this.map);
                this.initMarkerArrays();
                this.listeners = {};
                ref1 = ['click', 'zoom_changed', 'maptypeid_changed'];
                for (l = 0, len1 = ref1.length; l < len1; l++) {
                    e = ref1[l];
                    ge.addListener(this.map, e, (function(_this) {
                        return function() {
                            return _this['unspiderfy']();
                        };
                    })(this));
                }
            }
            p.initMarkerArrays = function() {
                this.markers = [];
                return this.markerListenerRefs = [];
            };
            p['addMarker'] = function(marker) {
                var listenerRefs;
                if (marker['_oms'] != null) {
                    return this;
                }
                marker['_oms'] = true;
                listenerRefs = [ge.addListener(marker, this['event'], (function(_this) {
                    return function(event) {
                        return _this.spiderListener(marker, event);
                    };
                })(this))];
                if (!this['markersWontHide']) {
                    listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {
                        return function() {
                            return _this.markerChangeListener(marker, false);
                        };
                    })(this)));
                }
                if (!this['markersWontMove']) {
                    listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {
                        return function() {
                            return _this.markerChangeListener(marker, true);
                        };
                    })(this)));
                }
                this.markerListenerRefs.push(listenerRefs);
                this.markers.push(marker);
                return this;
            };
            p.markerChangeListener = function(marker, positionChanged) {
                if ((marker['_omsData'] != null) && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {
                    return this['unspiderfy'](positionChanged ? marker : null);
                }
            };
            p['getMarkers'] = function() {
                return this.markers.slice(0);
            };
            p['removeMarker'] = function(marker) {
                var i, l, len1, listenerRef, listenerRefs;
                if (marker['_omsData'] != null) {
                    this['unspiderfy']();
                }
                i = this.arrIndexOf(this.markers, marker);
                if (i < 0) {
                    return this;
                }
                listenerRefs = this.markerListenerRefs.splice(i, 1)[0];
                for (l = 0, len1 = listenerRefs.length; l < len1; l++) {
                    listenerRef = listenerRefs[l];
                    ge.removeListener(listenerRef);
                }
                delete marker['_oms'];
                this.markers.splice(i, 1);
                return this;
            };
            p['clearMarkers'] = function() {
                var i, l, len1, len2, listenerRef, listenerRefs, marker, n, ref1;
                this['unspiderfy']();
                ref1 = this.markers;
                for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
                    marker = ref1[i];
                    listenerRefs = this.markerListenerRefs[i];
                    for (n = 0, len2 = listenerRefs.length; n < len2; n++) {
                        listenerRef = listenerRefs[n];
                        ge.removeListener(listenerRef);
                    }
                    delete marker['_oms'];
                }
                this.initMarkerArrays();
                return this;
            };
            p['addListener'] = function(event, func) {
                var base;
                ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);
                return this;
            };
            p['removeListener'] = function(event, func) {
                var i;
                i = this.arrIndexOf(this.listeners[event], func);
                if (!(i < 0)) {
                    this.listeners[event].splice(i, 1);
                }
                return this;
            };
            p['clearListeners'] = function(event) {
                this.listeners[event] = [];
                return this;
            };
            p.trigger = function() {
                var args, event, func, l, len1, ref1, ref2, results;
                event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                ref2 = (ref1 = this.listeners[event]) != null ? ref1 : [];
                results = [];
                for (l = 0, len1 = ref2.length; l < len1; l++) {
                    func = ref2[l];
                    results.push(func.apply(null, args));
                }
                return results;
            };
            p.generatePtsCircle = function(count, centerPt) {
                var angle, angleStep, circumference, i, l, legLength, ref1, results;
                circumference = this['circleFootSeparation'] * (2 + count);
                legLength = circumference / twoPi;
                angleStep = twoPi / count;
                results = [];
                for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                    angle = this['circleStartAngle'] + i * angleStep;
                    results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
                }
                return results;
            };
            p.generatePtsSpiral = function(count, centerPt) {
                var angle, i, l, legLength, pt, ref1, results;
                legLength = this['spiralLengthStart'];
                angle = 0;
                results = [];
                for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                    angle += this['spiralFootSeparation'] / legLength + i * 0.0005;
                    pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
                    legLength += twoPi * this['spiralLengthFactor'] / angle;
                    results.push(pt);
                }
                return results;
            };
            p.spiderListener = function(marker, event) {
                var $this, clear, l, len1, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref1;
                markerSpiderfied = marker['_omsData'] != null;
                if (!(markerSpiderfied && this['keepSpiderfied'])) {
                    if (this['event'] === 'mouseover') {
                        $this = this;
                        clear = function() {
                            return $this['unspiderfy']();
                        };
                        window.clearTimeout(p.timeout);
                        p.timeout = setTimeout(clear, 3000);
                    } else {
                        this['unspiderfy']();
                    }
                }
                if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI') {
                    return this.trigger('click', marker, event);
                } else {
                    nearbyMarkerData = [];
                    nonNearbyMarkers = [];
                    nDist = this['nearbyDistance'];
                    pxSq = nDist * nDist;
                    markerPt = this.llToPt(marker.position);
                    ref1 = this.markers;
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        m = ref1[l];
                        if (!((m.map != null) && m.getVisible())) {
                            continue;
                        }
                        mPt = this.llToPt(m.position);
                        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                            nearbyMarkerData.push({
                                marker: m,
                                markerPt: mPt
                            });
                        } else {
                            nonNearbyMarkers.push(m);
                        }
                    }
                    if (nearbyMarkerData.length === 1) {
                        return this.trigger('click', marker, event);
                    } else {
                        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
                    }
                }
            };
            p['markersNearMarker'] = function(marker, firstOnly) {
                var l, len1, m, mPt, markerPt, markers, nDist, pxSq, ref1, ref2, ref3;
                if (firstOnly == null) {
                    firstOnly = false;
                }
                if (this.projHelper.getProjection() == null) {
                    throw "Must wait for 'idle' event on map before calling markersNearMarker";
                }
                nDist = this['nearbyDistance'];
                pxSq = nDist * nDist;
                markerPt = this.llToPt(marker.position);
                markers = [];
                ref1 = this.markers;
                for (l = 0, len1 = ref1.length; l < len1; l++) {
                    m = ref1[l];
                    if (m === marker || (m.map == null) || !m.getVisible()) {
                        continue;
                    }
                    mPt = this.llToPt((ref2 = (ref3 = m['_omsData']) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position);
                    if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                        markers.push(m);
                        if (firstOnly) {
                            break;
                        }
                    }
                }
                return markers;
            };
            p['markersNearAnyOtherMarker'] = function() {
                var i, i1, i2, l, len1, len2, len3, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, q, ref1, ref2, ref3, results;
                if (this.projHelper.getProjection() == null) {
                    throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
                }
                nDist = this['nearbyDistance'];
                pxSq = nDist * nDist;
                mData = (function() {
                    var l, len1, ref1, ref2, ref3, results;
                    ref1 = this.markers;
                    results = [];
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        m = ref1[l];
                        results.push({
                            pt: this.llToPt((ref2 = (ref3 = m['_omsData']) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position),
                            willSpiderfy: false
                        });
                    }
                    return results;
                }).call(this);
                ref1 = this.markers;
                for (i1 = l = 0, len1 = ref1.length; l < len1; i1 = ++l) {
                    m1 = ref1[i1];
                    if (!((m1.map != null) && m1.getVisible())) {
                        continue;
                    }
                    m1Data = mData[i1];
                    if (m1Data.willSpiderfy) {
                        continue;
                    }
                    ref2 = this.markers;
                    for (i2 = n = 0, len2 = ref2.length; n < len2; i2 = ++n) {
                        m2 = ref2[i2];
                        if (i2 === i1) {
                            continue;
                        }
                        if (!((m2.map != null) && m2.getVisible())) {
                            continue;
                        }
                        m2Data = mData[i2];
                        if (i2 < i1 && !m2Data.willSpiderfy) {
                            continue;
                        }
                        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
                            m1Data.willSpiderfy = m2Data.willSpiderfy = true;
                            break;
                        }
                    }
                }
                ref3 = this.markers;
                results = [];
                for (i = q = 0, len3 = ref3.length; q < len3; i = ++q) {
                    m = ref3[i];
                    if (mData[i].willSpiderfy) {
                        results.push(m);
                    }
                }
                return results;
            };
            p.makeHighlightListenerFuncs = function(marker) {
                return {
                    highlight: (function(_this) {
                        return function() {
                            return marker['_omsData'].leg.setOptions({
                                strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],
                                zIndex: _this['highlightedLegZIndex']
                            });
                        };
                    })(this),
                    unhighlight: (function(_this) {
                        return function() {
                            return marker['_omsData'].leg.setOptions({
                                strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],
                                zIndex: _this['usualLegZIndex']
                            });
                        };
                    })(this)
                };
            };
            p.spiderfy = function(markerData, nonNearbyMarkers) {
                var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;
                if (this['minZoomLevel'] && this.map.getZoom() < this['minZoomLevel']) {
                    return false;
                }
                this.spiderfying = true;
                numFeet = markerData.length;
                bodyPt = this.ptAverage((function() {
                    var l, len1, results;
                    results = [];
                    for (l = 0, len1 = markerData.length; l < len1; l++) {
                        md = markerData[l];
                        results.push(md.markerPt);
                    }
                    return results;
                })());
                footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
                spiderfiedMarkers = (function() {
                    var l, len1, results;
                    results = [];
                    for (l = 0, len1 = footPts.length; l < len1; l++) {
                        footPt = footPts[l];
                        footLl = this.ptToLl(footPt);
                        nearestMarkerDatum = this.minExtract(markerData, (function(_this) {
                            return function(md) {
                                return _this.ptDistanceSq(md.markerPt, footPt);
                            };
                        })(this));
                        marker = nearestMarkerDatum.marker;
                        leg = new gm.Polyline({
                            map: this.map,
                            path: [marker.position, footLl],
                            strokeColor: this['legColors']['usual'][this.map.mapTypeId],
                            strokeWeight: this['legWeight'],
                            zIndex: this['usualLegZIndex']
                        });
                        marker['_omsData'] = {
                            usualPosition: marker.position,
                            leg: leg
                        };
                        if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {
                            highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
                            marker['_omsData'].hightlightListeners = {
                                highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),
                                unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)
                            };
                        }
                        marker.setPosition(footLl);
                        marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));
                        results.push(marker);
                    }
                    return results;
                }).call(this);
                delete this.spiderfying;
                this.spiderfied = true;
                return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);
            };
            p['unspiderfy'] = function(markerNotToMove) {
                var l, len1, listeners, marker, nonNearbyMarkers, ref1, unspiderfiedMarkers;
                if (markerNotToMove == null) {
                    markerNotToMove = null;
                }
                if (this.spiderfied == null) {
                    return this;
                }
                this.unspiderfying = true;
                unspiderfiedMarkers = [];
                nonNearbyMarkers = [];
                ref1 = this.markers;
                for (l = 0, len1 = ref1.length; l < len1; l++) {
                    marker = ref1[l];
                    if (marker['_omsData'] != null) {
                        marker['_omsData'].leg.setMap(null);
                        if (marker !== markerNotToMove) {
                            marker.setPosition(marker['_omsData'].usualPosition);
                        }
                        marker.setZIndex(null);
                        listeners = marker['_omsData'].hightlightListeners;
                        if (listeners != null) {
                            ge.removeListener(listeners.highlight);
                            ge.removeListener(listeners.unhighlight);
                        }
                        delete marker['_omsData'];
                        unspiderfiedMarkers.push(marker);
                    } else {
                        nonNearbyMarkers.push(marker);
                    }
                }
                delete this.unspiderfying;
                delete this.spiderfied;
                this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);
                return this;
            };
            p.ptDistanceSq = function(pt1, pt2) {
                var dx, dy;
                dx = pt1.x - pt2.x;
                dy = pt1.y - pt2.y;
                return dx * dx + dy * dy;
            };
            p.ptAverage = function(pts) {
                var l, len1, numPts, pt, sumX, sumY;
                sumX = sumY = 0;
                for (l = 0, len1 = pts.length; l < len1; l++) {
                    pt = pts[l];
                    sumX += pt.x;
                    sumY += pt.y;
                }
                numPts = pts.length;
                return new gm.Point(sumX / numPts, sumY / numPts);
            };
            p.llToPt = function(ll) {
                return this.projHelper.getProjection().fromLatLngToDivPixel(ll);
            };
            p.ptToLl = function(pt) {
                return this.projHelper.getProjection().fromDivPixelToLatLng(pt);
            };
            p.minExtract = function(set, func) {
                var bestIndex, bestVal, index, item, l, len1, val;
                for (index = l = 0, len1 = set.length; l < len1; index = ++l) {
                    item = set[index];
                    val = func(item);
                    if ((typeof bestIndex === "undefined" || bestIndex === null) || val < bestVal) {
                        bestVal = val;
                        bestIndex = index;
                    }
                }
                return set.splice(bestIndex, 1)[0];
            };
            p.arrIndexOf = function(arr, obj) {
                var i, l, len1, o;
                if (arr.indexOf != null) {
                    return arr.indexOf(obj);
                }
                for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
                    o = arr[i];
                    if (o === obj) {
                        return i;
                    }
                }
                return -1;
            };
            return _Class;
        })();
        GoogleMapApi.then(function() {
            self.OverlappingMarkerSpiderfier.initializeGoogleMaps(window.google);
        });
        return this.OverlappingMarkerSpiderfier;
    }]);;
    angular.module('uiGmapgoogle-maps.extensions').service('uiGmapExtendMarkerClusterer', ['uiGmapLodash', 'uiGmapPropMap', function(uiGmapLodash, PropMap) {
        return {
            init: _.once(function() {
                (function() {
                    var __hasProp = {}.hasOwnProperty,
                        __extends = function(child, parent) {
                            for (var key in parent) {
                                if (__hasProp.call(parent, key)) child[key] = parent[key];
                            }

                            function ctor() {
                                this.constructor = child;
                            }
                            ctor.prototype = parent.prototype;
                            child.prototype = new ctor();
                            child.__super__ = parent.prototype;
                            return child;
                        };
                    window.NgMapCluster = (function(_super) {
                        __extends(NgMapCluster, _super);

                        function NgMapCluster(opts) {
                            NgMapCluster.__super__.constructor.call(this, opts);
                            this.markers_ = new PropMap();
                        }
                        NgMapCluster.prototype.addMarker = function(marker) {
                            var i;
                            var mCount;
                            var mz;
                            if (this.isMarkerAlreadyAdded_(marker)) {
                                var oldMarker = this.markers_.get(marker.key);
                                if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon()) return false;
                            }
                            if (!this.center_) {
                                this.center_ = marker.getPosition();
                                this.calculateBounds_();
                            } else {
                                if (this.averageCenter_) {
                                    var l = this.markers_.length + 1;
                                    var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
                                    var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                                    this.center_ = new google.maps.LatLng(lat, lng);
                                    this.calculateBounds_();
                                }
                            }
                            marker.isAdded = true;
                            this.markers_.push(marker);
                            mCount = this.markers_.length;
                            mz = this.markerClusterer_.getMaxZoom();
                            if (mz !== null && this.map_.getZoom() > mz) {
                                if (marker.getMap() !== this.map_) {
                                    marker.setMap(this.map_);
                                }
                            } else if (mCount < this.minClusterSize_) {
                                if (marker.getMap() !== this.map_) {
                                    marker.setMap(this.map_);
                                }
                            } else if (mCount === this.minClusterSize_) {
                                this.markers_.each(function(m) {
                                    m.setMap(null);
                                });
                            } else {
                                marker.setMap(null);
                            }
                            return true;
                        };
                        NgMapCluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                            return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
                        };
                        NgMapCluster.prototype.getBounds = function() {
                            var i;
                            var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                            this.getMarkers().each(function(m) {
                                bounds.extend(m.getPosition());
                            });
                            return bounds;
                        };
                        NgMapCluster.prototype.remove = function() {
                            this.clusterIcon_.setMap(null);
                            this.markers_ = new PropMap();
                            delete this.markers_;
                        };
                        return NgMapCluster;
                    })(Cluster);
                    window.NgMapMarkerClusterer = (function(_super) {
                        __extends(NgMapMarkerClusterer, _super);

                        function NgMapMarkerClusterer(map, opt_markers, opt_options) {
                            NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
                            this.markers_ = new PropMap();
                        }
                        NgMapMarkerClusterer.prototype.clearMarkers = function() {
                            this.resetViewport_(true);
                            this.markers_ = new PropMap();
                        };
                        NgMapMarkerClusterer.prototype.removeMarker_ = function(marker) {
                            if (!this.markers_.get(marker.key)) {
                                return false;
                            }
                            marker.setMap(null);
                            this.markers_.remove(marker.key);
                            return true;
                        };
                        NgMapMarkerClusterer.prototype.createClusters_ = function(iFirst) {
                            var i, marker;
                            var mapBounds;
                            var cMarkerClusterer = this;
                            if (!this.ready_) {
                                return;
                            }
                            if (iFirst === 0) {
                                google.maps.event.trigger(this, 'clusteringbegin', this);
                                if (typeof this.timerRefStatic !== 'undefined') {
                                    clearTimeout(this.timerRefStatic);
                                    delete this.timerRefStatic;
                                }
                            }
                            if (this.getMap().getZoom() > 3) {
                                mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());
                            } else {
                                mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                            }
                            var bounds = this.getExtendedBounds(mapBounds);
                            var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                            var _ms = this.markers_.values();
                            for (i = iFirst; i < iLast; i++) {
                                marker = _ms[i];
                                if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
                                    if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
                                        this.addToClosestCluster_(marker);
                                    }
                                }
                            }
                            if (iLast < this.markers_.length) {
                                this.timerRefStatic = setTimeout(function() {
                                    cMarkerClusterer.createClusters_(iLast);
                                }, 0);
                            } else {
                                for (i = 0; i < this.clusters_.length; i++) {
                                    this.clusters_[i].updateIcon_();
                                }
                                delete this.timerRefStatic;
                                google.maps.event.trigger(this, 'clusteringend', this);
                            }
                        };
                        NgMapMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                            var i, d, cluster, center;
                            var distance = 40000;
                            var clusterToAddTo = null;
                            for (i = 0; i < this.clusters_.length; i++) {
                                cluster = this.clusters_[i];
                                center = cluster.getCenter();
                                if (center) {
                                    d = this.distanceBetweenPoints_(center, marker.getPosition());
                                    if (d < distance) {
                                        distance = d;
                                        clusterToAddTo = cluster;
                                    }
                                }
                            }
                            if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
                                clusterToAddTo.addMarker(marker);
                            } else {
                                cluster = new NgMapCluster(this);
                                cluster.addMarker(marker);
                                this.clusters_.push(cluster);
                            }
                        };
                        NgMapMarkerClusterer.prototype.redraw_ = function() {
                            this.createClusters_(0);
                        };
                        NgMapMarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                            var i, marker;
                            for (i = 0; i < this.clusters_.length; i++) {
                                this.clusters_[i].remove();
                            }
                            this.clusters_ = [];
                            this.markers_.each(function(marker) {
                                marker.isAdded = false;
                                if (opt_hide) {
                                    marker.setMap(null);
                                }
                            });
                        };
                        NgMapMarkerClusterer.prototype.extend = function(obj1, obj2) {
                            return (function(object) {
                                var property;
                                for (property in object.prototype) {
                                    if (property !== 'constructor') this.prototype[property] = object.prototype[property];
                                }
                                return this;
                            }).apply(obj1, [obj2]);
                        };
                        ClusterIcon.prototype.show = function() {
                            if (this.div_) {
                                var img = "";
                                var bp = this.backgroundPosition_.split(" ");
                                var spriteH = parseInt(bp[0].trim(), 10);
                                var spriteV = parseInt(bp[1].trim(), 10);
                                var pos = this.getPosFromLatLng_(this.center_);
                                this.div_.style.cssText = this.createCss(pos);
                                img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                                if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
                                    img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " + ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
                                } else {
                                    img += "width: " + this.width_ + "px;" + "height: " + this.height_ + "px;";
                                }
                                img += "'>";
                                this.div_.innerHTML = img + "<div style='" + "position: absolute;" + "top: " + this.anchorText_[0] + "px;" + "left: " + this.anchorText_[1] + "px;" + "color: " + this.textColor_ + ";" + "font-size: " + this.textSize_ + "px;" + "font-family: " + this.fontFamily_ + ";" + "font-weight: " + this.fontWeight_ + ";" + "font-style: " + this.fontStyle_ + ";" + "text-decoration: " + this.textDecoration_ + ";" + "text-align: center;" + "width: " + this.width_ + "px;" + "line-height:" + this.height_ + "px;" + "'>" + this.sums_.text + "</div>";
                                if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
                                    this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
                                } else {
                                    this.div_.title = this.sums_.title;
                                }
                                this.div_.style.display = "";
                            }
                            this.visible_ = true;
                        };
                        return NgMapMarkerClusterer;
                    })(MarkerClusterer);
                }).call(this);
            })
        };
    }]);
}(window, angular));
'use strict';
angular.module('slick', []).directive('slick', ['$timeout', function($timeout) {
    return {
        restrict: 'AEC',
        scope: {
            initOnload: '@',
            data: '=',
            currentIndex: '=',
            accessibility: '@',
            adaptiveHeight: '@',
            arrows: '@',
            asNavFor: '@',
            appendArrows: '@',
            appendDots: '@',
            autoplay: '@',
            autoplaySpeed: '@',
            centerMode: '@',
            centerPadding: '@',
            cssEase: '@',
            customPaging: '&',
            dots: '@',
            draggable: '@',
            easing: '@',
            fade: '@',
            focusOnSelect: '@',
            infinite: '@',
            initialSlide: '@',
            lazyLoad: '@',
            onBeforeChange: '&',
            onAfterChange: '&',
            onInit: '&',
            onReInit: '&',
            onSetPosition: '&',
            pauseOnHover: '@',
            pauseOnDotsHover: '@',
            responsive: '=',
            rtl: '@',
            slide: '@',
            slidesToShow: '@',
            slidesToScroll: '@',
            speed: '@',
            swipe: '@',
            swipeToSlide: '@',
            touchMove: '@',
            touchThreshold: '@',
            useCSS: '@',
            variableWidth: '@',
            vertical: '@',
            prevArrow: '@',
            nextArrow: '@'
        },
        link: function(scope, element, attrs) {
            var destroySlick, initializeSlick, isInitialized;
            destroySlick = function() {
                return $timeout(function() {
                    var slider;
                    slider = $(element);
                    slider.unslick();
                    slider.find('.slick-list').remove();
                    return slider;
                });
            };
            initializeSlick = function() {
                return $timeout(function() {
                    var currentIndex, customPaging, slider;
                    slider = $(element);
                    if (scope.currentIndex != null) {
                        currentIndex = scope.currentIndex;
                    }
                    customPaging = function(slick, index) {
                        return scope.customPaging({
                            slick: slick,
                            index: index
                        });
                    };
                    slider.slick({
                        accessibility: scope.accessibility !== 'false',
                        adaptiveHeight: scope.adaptiveHeight === 'true',
                        arrows: scope.arrows !== 'false',
                        asNavFor: scope.asNavFor ? scope.asNavFor : void 0,
                        appendArrows: scope.appendArrows ? $(scope.appendArrows) : $(element),
                        appendDots: scope.appendDots ? $(scope.appendDots) : $(element),
                        autoplay: scope.autoplay === 'true',
                        autoplaySpeed: scope.autoplaySpeed != null ? parseInt(scope.autoplaySpeed, 10) : 3000,
                        centerMode: scope.centerMode === 'true',
                        centerPadding: scope.centerPadding || '50px',
                        cssEase: scope.cssEase || 'ease',
                        customPaging: attrs.customPaging ? customPaging : void 0,
                        dots: scope.dots === 'true',
                        draggable: scope.draggable !== 'false',
                        easing: scope.easing || 'linear',
                        fade: scope.fade === 'true',
                        focusOnSelect: scope.focusOnSelect === 'true',
                        infinite: scope.infinite !== 'false',
                        initialSlide: scope.initialSlide || 0,
                        lazyLoad: scope.lazyLoad || 'ondemand',
                        beforeChange: attrs.onBeforeChange ? scope.onBeforeChange : void 0,
                        onReInit: attrs.onReInit ? scope.onReInit : void 0,
                        onSetPosition: attrs.onSetPosition ? scope.onSetPosition : void 0,
                        pauseOnHover: scope.pauseOnHover !== 'false',
                        responsive: scope.responsive || void 0,
                        rtl: scope.rtl === 'true',
                        slide: scope.slide || 'div',
                        slidesToShow: scope.slidesToShow != null ? parseInt(scope.slidesToShow, 10) : 1,
                        slidesToScroll: scope.slidesToScroll != null ? parseInt(scope.slidesToScroll, 10) : 1,
                        speed: scope.speed != null ? parseInt(scope.speed, 10) : 300,
                        swipe: scope.swipe !== 'false',
                        swipeToSlide: scope.swipeToSlide === 'true',
                        touchMove: scope.touchMove !== 'false',
                        touchThreshold: scope.touchThreshold ? parseInt(scope.touchThreshold, 10) : 5,
                        useCSS: scope.useCSS !== 'false',
                        variableWidth: scope.variableWidth === 'true',
                        vertical: scope.vertical === 'true',
                        prevArrow: scope.prevArrow ? $(scope.prevArrow) : void 0,
                        nextArrow: scope.nextArrow ? $(scope.nextArrow) : void 0
                    });
                    slider.on('init', function(sl) {
                        if (attrs.onInit) {
                            scope.onInit();
                        }
                        if (currentIndex != null) {
                            return sl.slideHandler(currentIndex);
                        }
                    });
                    slider.on('afterChange', function(event, slick, currentSlide, nextSlide) {
                        if (scope.onAfterChange) {
                            scope.onAfterChange();
                        }
                        if (currentIndex != null) {
                            return scope.$apply(function() {
                                currentIndex = currentSlide;
                                return scope.currentIndex = currentSlide;
                            });
                        }
                    });
                    return scope.$watch('currentIndex', function(newVal, oldVal) {
                        if (currentIndex != null && newVal != null && newVal !== currentIndex) {
                            return slider.slick('slickGoTo', newVal);
                        }
                    });
                });
            };
            if (scope.initOnload) {
                isInitialized = false;
                return scope.$watch('data', function(newVal, oldVal) {
                    if (newVal != null) {
                        if (isInitialized) {
                            destroySlick();
                        }
                        initializeSlick();
                        return isInitialized = true;
                    }
                });
            } else {
                return initializeSlick();
            }
        }
    };
}]);
'format amd';
(function(root) {
    'use strict';

    function factory(angular, Spinner) {
        return angular.module('angularSpinner', []).constant('SpinJSSpinner', Spinner).provider('usSpinnerConfig', function() {
            var _config = {},
                _themes = {};
            return {
                setDefaults: function(config) {
                    _config = config || _config;
                },
                setTheme: function(name, config) {
                    _themes[name] = config;
                },
                $get: function() {
                    return {
                        config: _config,
                        themes: _themes
                    };
                }
            };
        }).factory('usSpinnerService', ['$rootScope', function($rootScope) {
            var config = {};
            config.spin = function(key) {
                $rootScope.$broadcast('us-spinner:spin', key);
            };
            config.stop = function(key) {
                $rootScope.$broadcast('us-spinner:stop', key);
            };
            return config;
        }]).directive('usSpinner', ['SpinJSSpinner', 'usSpinnerConfig', function(SpinJSSpinner, usSpinnerConfig) {
            return {
                scope: true,
                link: function(scope, element, attr) {
                    scope.spinner = null;
                    scope.key = angular.isDefined(attr.spinnerKey) ? attr.spinnerKey : false;
                    scope.startActive = angular.isDefined(attr.spinnerStartActive) ? scope.$eval(attr.spinnerStartActive) : scope.key ? false : true;

                    function stopSpinner() {
                        if (scope.spinner) {
                            scope.spinner.stop();
                        }
                    }
                    scope.spin = function() {
                        if (scope.spinner) {
                            scope.spinner.spin(element[0]);
                        }
                    };
                    scope.stop = function() {
                        scope.startActive = false;
                        stopSpinner();
                    };
                    scope.$watch(attr.usSpinner, function(options) {
                        stopSpinner();
                        options = angular.extend(usSpinnerConfig.config, usSpinnerConfig.themes[attr.spinnerTheme], options);
                        scope.spinner = new SpinJSSpinner(options);
                        if ((!scope.key || scope.startActive) && !attr.spinnerOn) {
                            scope.spinner.spin(element[0]);
                        }
                    }, true);
                    if (attr.spinnerOn) {
                        scope.$watch(attr.spinnerOn, function(spin) {
                            if (spin) {
                                scope.spin();
                            } else {
                                scope.stop();
                            }
                        });
                    }
                    scope.$on('us-spinner:spin', function(event, key) {
                        if (key === scope.key) {
                            scope.spin();
                        }
                    });
                    scope.$on('us-spinner:stop', function(event, key) {
                        if (key === scope.key) {
                            scope.stop();
                        }
                    });
                    scope.$on('$destroy', function() {
                        scope.stop();
                        scope.spinner = null;
                    });
                }
            };
        }]);
    }
    if ((typeof module === 'object') && module.exports) {
        module.exports = factory(require('angular'), require('spin.js'));
    } else if (typeof define === 'function' && define.amd) {
        define(['angular', 'spin'], factory);
    } else {
        factory(root.angular, root.Spinner);
    }
}(this));

function site_url() {
    return main_url + '/';
}

function char_length() {
    var text_length = $('#ratingformpopup textarea').val().length;
    var min_allowed_char = $(".allowed_char").html();
    var remaining_char = min_allowed_char - text_length;
    if (text_length <= min_allowed_char) {
        $(".remaining_char").html(remaining_char);
    } else {
        $(".remaining_char").html('0');
    }
}

function char_length_notify() {
    var text_length = $('#notificationformpopup textarea').val().length;
    var min_allowed_char = $(".allowed_char").html();
    var remaining_char = min_allowed_char - text_length;
    if (text_length <= min_allowed_char) {
        $(".remaining_char").html(remaining_char);
    } else {
        $(".remaining_char").html('0');
    }
}